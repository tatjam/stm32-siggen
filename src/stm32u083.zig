const mmio = @import("mmio.zig");

pub const devices = struct {
    ///  STM32U083
    pub const STM32U083 = struct {
        pub const properties = struct {
            pub const @"cpu.endian" = "little";
            pub const @"cpu.mpuPresent" = "true";
            pub const @"cpu.revision" = "r0p1";
            pub const @"cpu.name" = "CM0+";
            pub const @"cpu.nvicPrioBits" = "4";
            pub const @"cpu.vendorSystickConfig" = "false";
            pub const @"cpu.fpuPresent" = "false";
        };

        fn default_handler() callconv(.C) noreturn {
            while (true) {}
        }

        const IsrFunction = *const fn () callconv(.C) void;
        // Note that "core peripherals" are not included in this list, they are not handled
        // by NVIC (those are negative, and are "hardwired" so to say, but may be controlled in SCB)
        pub const InterruptIndex = enum(usize) {
            ///  Window watchdog interrupt
            WWDG = 0,
            ///  PVD/PVM1/PVM2/PVM3 interrupt (combined with EXTI lines 16 and 19 and 20 and 21)
            PVD_PVM,
            ///  RTC and TAMP interrupts(combined EXTI lines 19 and 21)
            RTC_TAMP,
            ///  FLASH global interrupt
            FLASH,
            ///  RCC and CRS global interrupt
            RCC_CRS,
            ///  EXTI lines 0 and 1 interrupt
            EXTI0_1,
            ///  EXTI lines 2 and 3 interrupt
            EXTI2_3,
            ///  EXTI lines 4 to 15 interrupt
            EXTI4_15,
            ///  USB global interrupt (combined with EXTI line 33)
            USB,
            ///  DMA1 channel 1 interrupt
            DMA1_CHannel1,
            ///  DMA1 channel 2 and 3 interrupts
            DMA1_Channel2_3,
            ///  DMA1 channel 4, 5, 6, 7, DMAMUX, DMA2 channel 1, 2, 3, 4, 5 interrupts
            DMA1_Channel4_5_6_7,
            ///  ADC and COMP interrupts (ADC combined with EXTI lines 17 and 18)
            ADC_COMP,
            ///  TIM1 break, update, trigger and commutation interrupts
            TIM1_BRK_UP_TRG_COM,
            ///  TIM1 Capture Compare interrupt
            TIM1_CC,
            ///  TIM2 global interrupt
            TIM2,
            ///  TIM3 global interrupt
            TIM3,
            ///  TIM6, LPTIM1 and DAC global interrupt (combined with EXTI line 29)
            TIM6_DAC_LPTIM1,
            ///  TIM7 and LPTIM2 global interrupt (combined with EXTI line 30)
            TIM7_LPTIM2,
            ///  TIM15 and LPTIM3 global interrupt (combined with EXTI line 29)
            TIM15_LPTIM3,
            ///  TIM16 global interrupt
            TIM16,
            ///  TSC global interrupt
            TSC,
            ///  LCD global interrupt (combined with EXTI line 32)
            LCD,
            ///  I2C1 global interrupt (combined with EXTI line 23)
            I2C1,
            ///  I2C2/3/4 global interrupt
            I2C2_I2C3_I2C4,
            ///  SPI1 global interrupt
            SPI1,
            ///  SPI2/3 global interrupt
            SPI2_SPI3,
            ///  USART1 global interrupt (combined with EXTI line 25)
            USART1,
            ///  USART2 and LPUART2 global interrupt (combined with EXTI lines 26 and 35)
            USART2_LPUART2,
            ///  USART3 and LPUART1 global interrupt (combined with EXTI lines 24 and 28)
            USART3_LPUART1,
            ///  USART4 and LPUART3 global interrupt (combined with EXTI lines 20 and 34)
            USART4_LPUART3,
            ///  AES and RNG global interrupts
            AES_RNG,
        };

        const core = @import("cortex_m.zig");
		pub fn enable_interrupt(idx: InterruptIndex) void {
			// Note that we just need to write a "1" in the right place. Access must be word-wide
			core.NVIC.ISER = @as(u32, 1 << @intFromEnum(idx));
		}

		pub fn disable_interrupt(idx: InterruptIndex) void {
			core.NVIC.ICER = @as(u32, 1 << @intFromEnum(idx));
		}

		pub fn get_interrupt_enabled(idx: InterruptIndex) bool {
			return core.NVIC.ISER & @as(u32, 1 << @intFromEnum(idx)) != 0;
		}

		pub fn set_pending_interrupt(idx: InterruptIndex) void {
			core.NVIC.ISPR = @as(u32, 1 << @intFromEnum(idx));
		}

		pub fn clear_pending_interrupt(idx: InterruptIndex) void {
			core.NVIC.ICPR = @as(u32, 1 << @intFromEnum(idx));
		}

		pub fn is_interrupt_pending(idx: InterruptIndex) bool {
			return core.NVIC.ISPR & @as(u32, 1 << @intFromEnum(idx)) != 0;
		}

        pub const VectorTable = extern struct {
            const Handler = IsrFunction;
            const unhandled = default_handler;

            initial_stack_pointer: *anyopaque,
            Reset: Handler,
            NMI: Handler = unhandled,
            HardFault: Handler = unhandled,
            reserved2: [7]u32 = undefined,
            SVCall: Handler = unhandled,
            reserved10: [2]u32 = undefined,
            PendSV: Handler = unhandled,
            SysTick: Handler = unhandled,
            ///  Window watchdog interrupt
            WWDG: Handler = unhandled,
            ///  PVD/PVM1/PVM2/PVM3 interrupt (combined with EXTI lines 16 and 19 and 20 and 21)
            PVD_PVM: Handler = unhandled,
            ///  RTC and TAMP interrupts(combined EXTI lines 19 and 21)
            RTC_TAMP: Handler = unhandled,
            ///  FLASH global interrupt
            FLASH: Handler = unhandled,
            ///  RCC and CRS global interrupt
            RCC_CRS: Handler = unhandled,
            ///  EXTI lines 0 and 1 interrupt
            EXTI0_1: Handler = unhandled,
            ///  EXTI lines 2 and 3 interrupt
            EXTI2_3: Handler = unhandled,
            ///  EXTI lines 4 to 15 interrupt
            EXTI4_15: Handler = unhandled,
            ///  USB global interrupt (combined with EXTI line 33)
            USB: Handler = unhandled,
            ///  DMA1 channel 1 interrupt
            DMA1_CHannel1: Handler = unhandled,
            ///  DMA1 channel 2 and 3 interrupts
            DMA1_Channel2_3: Handler = unhandled,
            ///  DMA1 channel 4, 5, 6, 7, DMAMUX, DMA2 channel 1, 2, 3, 4, 5 interrupts
            DMA1_Channel4_5_6_7: Handler = unhandled,
            ///  ADC and COMP interrupts (ADC combined with EXTI lines 17 and 18)
            ADC_COMP: Handler = unhandled,
            ///  TIM1 break, update, trigger and commutation interrupts
            TIM1_BRK_UP_TRG_COM: Handler = unhandled,
            ///  TIM1 Capture Compare interrupt
            TIM1_CC: Handler = unhandled,
            ///  TIM2 global interrupt
            TIM2: Handler = unhandled,
            ///  TIM3 global interrupt
            TIM3: Handler = unhandled,
            ///  TIM6, LPTIM1 and DAC global interrupt (combined with EXTI line 29)
            TIM6_DAC_LPTIM1: Handler = unhandled,
            ///  TIM7 and LPTIM2 global interrupt (combined with EXTI line 30)
            TIM7_LPTIM2: Handler = unhandled,
            ///  TIM15 and LPTIM3 global interrupt (combined with EXTI line 29)
            TIM15_LPTIM3: Handler = unhandled,
            ///  TIM16 global interrupt
            TIM16: Handler = unhandled,
            ///  TSC global interrupt
            TSC: Handler = unhandled,
            ///  LCD global interrupt (combined with EXTI line 32)
            LCD: Handler = unhandled,
            ///  I2C1 global interrupt (combined with EXTI line 23)
            I2C1: Handler = unhandled,
            ///  I2C2/3/4 global interrupt
            I2C2_I2C3_I2C4: Handler = unhandled,
            ///  SPI1 global interrupt
            SPI1: Handler = unhandled,
            ///  SPI2/3 global interrupt
            SPI2_SPI3: Handler = unhandled,
            ///  USART1 global interrupt (combined with EXTI line 25)
            USART1: Handler = unhandled,
            ///  USART2 and LPUART2 global interrupt (combined with EXTI lines 26 and 35)
            USART2_LPUART2: Handler = unhandled,
            ///  USART3 and LPUART1 global interrupt (combined with EXTI lines 24 and 28)
            USART3_LPUART1: Handler = unhandled,
            ///  USART4 and LPUART3 global interrupt (combined with EXTI lines 20 and 34)
            USART4_LPUART3: Handler = unhandled,
            ///  AES and RNG global interrupts
            AES_RNG: Handler = unhandled,
        };

        pub const peripherals = struct {
            ///  TIM2 address block description
            pub const TIM2: *volatile types.peripherals.TIM2 = @ptrFromInt(0x40000000);
            ///  TIM3 address block description
            pub const TIM3: *volatile types.peripherals.TIM3 = @ptrFromInt(0x40000400);
            ///  TIM6 address block description
            pub const TIM6: *volatile types.peripherals.TIM6 = @ptrFromInt(0x40001000);
            ///  TIM7 address block description
            pub const TIM7: *volatile types.peripherals.TIM7 = @ptrFromInt(0x40001400);
            ///  LCD address block description
            pub const LCD: *volatile types.peripherals.LCD = @ptrFromInt(0x40002400);
            ///  RTC register block
            pub const RTC: *volatile types.peripherals.RTC = @ptrFromInt(0x40002800);
            ///  WWDG address block description
            pub const WWDG: *volatile types.peripherals.WWDG = @ptrFromInt(0x40002c00);
            ///  IWDG address block description
            pub const IWDG: *volatile types.peripherals.IWDG = @ptrFromInt(0x40003000);
            ///  SPI address block description
            pub const SPI2: *volatile types.peripherals.SPI1 = @ptrFromInt(0x40003800);
            ///  SPI address block description
            pub const SPI3: *volatile types.peripherals.SPI1 = @ptrFromInt(0x40003c00);
            ///  USART address block description
            pub const USART2: *volatile types.peripherals.USART1 = @ptrFromInt(0x40004400);
            ///  USART address block description
            pub const USART3: *volatile types.peripherals.USART1 = @ptrFromInt(0x40004800);
            ///  USART address block description
            pub const USART4: *volatile types.peripherals.USART1 = @ptrFromInt(0x40004c00);
            ///  I2C address block description
            pub const I2C1: *volatile types.peripherals.I2C1 = @ptrFromInt(0x40005400);
            ///  I2C address block description
            pub const I2C2: *volatile types.peripherals.I2C1 = @ptrFromInt(0x40005800);
            ///  USB address block description
            pub const USB: *volatile types.peripherals.USB = @ptrFromInt(0x40005c00);
            ///  CRS address block description
            pub const CRS: *volatile types.peripherals.CRS = @ptrFromInt(0x40006c00);
            ///  PWR register block
            pub const PWR: *volatile types.peripherals.PWR = @ptrFromInt(0x40007000);
            ///  DAC address block description
            pub const DAC: *volatile types.peripherals.DAC = @ptrFromInt(0x40007400);
            ///  OPAMP address block description
            pub const OPAMP: *volatile types.peripherals.OPAMP = @ptrFromInt(0x40007800);
            ///  LPTIM1 address block description
            pub const LPTIM1: *volatile types.peripherals.LPTIM1 = @ptrFromInt(0x40007c00);
            ///  LPUART address block description
            pub const LPUART1: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40008000);
            ///  LPUART address block description
            pub const LPUART2: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40008400);
            ///  I2C address block description
            pub const I2C3: *volatile types.peripherals.I2C1 = @ptrFromInt(0x40008800);
            ///  LPUART address block description
            pub const LPUART3: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40008c00);
            ///  LPTIM3 address block description
            pub const LPTIM3: *volatile types.peripherals.LPTIM3 = @ptrFromInt(0x40009000);
            ///  LPTIM2 address block description
            pub const LPTIM2: *volatile types.peripherals.LPTIM2 = @ptrFromInt(0x40009400);
            ///  TAMP register block
            pub const TAMP: *volatile types.peripherals.TAMP = @ptrFromInt(0x4000b000);
            ///  SYSCFG register block
            pub const SYSCFG: *volatile types.peripherals.SYSCFG = @ptrFromInt(0x40010000);
            ///  VREFBUF address block description
            pub const VREFBUF: *volatile types.peripherals.VREFBUF = @ptrFromInt(0x40010030);
            ///  COMP address block description
            pub const COMP: *volatile types.peripherals.COMP = @ptrFromInt(0x40010200);
            ///  ADC address block description
            pub const ADC: *volatile types.peripherals.ADC = @ptrFromInt(0x40012400);
            ///  TIM1 address block description
            pub const TIM1: *volatile types.peripherals.TIM1 = @ptrFromInt(0x40012c00);
            ///  SPI address block description
            pub const SPI1: *volatile types.peripherals.SPI1 = @ptrFromInt(0x40013000);
            ///  USART address block description
            pub const USART1: *volatile types.peripherals.USART1 = @ptrFromInt(0x40013800);
            ///  TIM15 address block description
            pub const TIM15: *volatile types.peripherals.TIM15 = @ptrFromInt(0x40014000);
            ///  TIM16 address block description
            pub const TIM16: *volatile types.peripherals.TIM16 = @ptrFromInt(0x40014400);
            ///  DBGMCU register block
            pub const DBGMCU: *volatile types.peripherals.DBGMCU = @ptrFromInt(0x40015800);
            ///  DMA register bank
            pub const DMA1: *volatile types.peripherals.DMA1 = @ptrFromInt(0x40020000);
            ///  DMA register bank
            pub const DMA2: *volatile types.peripherals.DMA1 = @ptrFromInt(0x40020400);
            ///  DMAMUX address block description
            pub const DMAMUX: *volatile types.peripherals.DMAMUX = @ptrFromInt(0x40020800);
            ///  RCC address block description
            pub const RCC: *volatile types.peripherals.RCC = @ptrFromInt(0x40021000);
            ///  EXTI register block
            pub const EXTI: *volatile types.peripherals.EXTI = @ptrFromInt(0x40021800);
            ///  Mamba FLASH register block
            pub const FLASH: *volatile types.peripherals.FLASH = @ptrFromInt(0x40022000);
            ///  CRC address block description
            pub const CRC: *volatile types.peripherals.CRC = @ptrFromInt(0x40023000);
            ///  TSC address block description
            pub const TSC: *volatile types.peripherals.TSC = @ptrFromInt(0x40024000);
            ///  RNG address block description
            pub const RNG: *volatile types.peripherals.RNG = @ptrFromInt(0x40025000);
            ///  AES register block
            pub const AES: *volatile types.peripherals.AES = @ptrFromInt(0x40026000);
            ///  GPIOA address block description
            pub const GPIOA: *volatile types.peripherals.GPIOA = @ptrFromInt(0x50000000);
            ///  GPIOB address block description
            pub const GPIOB: *volatile types.peripherals.GPIOB = @ptrFromInt(0x50000400);
            ///  GPIOC address block description
            pub const GPIOC: *volatile types.peripherals.GPIOC = @ptrFromInt(0x50000800);
            ///  GPIOD address block description
            pub const GPIOD: *volatile types.peripherals.GPIOD = @ptrFromInt(0x50000c00);
            ///  GPIOE address block description
            pub const GPIOE: *volatile types.peripherals.GPIOE = @ptrFromInt(0x50001000);
            ///  GPIOF address block description
            pub const GPIOF: *volatile types.peripherals.GPIOF = @ptrFromInt(0x50001400);
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        ///  ADC address block description
        pub const ADC = extern struct {
            ///  ADC interrupt and status register
            ADC_ISR: mmio.Mmio(packed struct(u32) {
                ///  ADC ready This bit is set by hardware after the ADC has been enabled (ADEN+1) and when the ADC reaches a state where it is ready to accept conversion requests. It is cleared by software writing 1 to it.
                ADRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  ADC is ready to start conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  End of sampling flag This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to 1.
                EOSMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not at the end of the sampling phase (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  End of sampling phase reached
                        B_0x1 = 0x1,
                    },
                },
                ///  End of conversion flag This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
                EOC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Channel conversion not complete (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  Channel conversion complete
                        B_0x1 = 0x1,
                    },
                },
                ///  End of sequence flag This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
                EOS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Conversion sequence not complete (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  Conversion sequence complete
                        B_0x1 = 0x1,
                    },
                },
                ///  ADC overrun This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
                OVR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overrun occurred (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  Overrun has occurred
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u2,
                ///  Analog watchdog 1 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
                AWD1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  Analog watchdog event occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog 2 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
                AWD2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  Analog watchdog event occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog 3 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
                AWD3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)
                        B_0x0 = 0x0,
                        ///  Analog watchdog event occurred
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u1,
                ///  End Of Calibration flag This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
                EOCAL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calibration is not complete
                        B_0x0 = 0x0,
                        ///  Calibration is complete
                        B_0x1 = 0x1,
                    },
                },
                reserved13: u1,
                ///  Channel Configuration Ready flag This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it. Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
                CCRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Channel configuration update not applied.
                        B_0x0 = 0x0,
                        ///  Channel configuration update is applied.
                        B_0x1 = 0x1,
                    },
                },
                padding: u18,
            }),
            ///  ADC interrupt enable register
            ADC_IER: mmio.Mmio(packed struct(u32) {
                ///  ADC ready interrupt enable This bit is set and cleared by software to enable/disable the ADC Ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                ADRDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADRDY interrupt disabled.
                        B_0x0 = 0x0,
                        ///  ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  End of sampling flag interrupt enable This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                EOSMPIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  EOSMP interrupt disabled.
                        B_0x0 = 0x0,
                        ///  EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  End of conversion interrupt enable This bit is set and cleared by software to enable/disable the end of conversion interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                EOCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  EOC interrupt disabled
                        B_0x0 = 0x0,
                        ///  EOC interrupt enabled. An interrupt is generated when the EOC bit is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  End of conversion sequence interrupt enable This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                EOSIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  EOS interrupt disabled
                        B_0x0 = 0x0,
                        ///  EOS interrupt enabled. An interrupt is generated when the EOS bit is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Overrun interrupt enable This bit is set and cleared by software to enable/disable the overrun interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                OVRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Overrun interrupt disabled
                        B_0x0 = 0x0,
                        ///  Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u2,
                ///  Analog watchdog 1 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                AWD1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Analog watchdog interrupt disabled
                        B_0x0 = 0x0,
                        ///  Analog watchdog interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog 2 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                AWD2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Analog watchdog interrupt disabled
                        B_0x0 = 0x0,
                        ///  Analog watchdog interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog 3 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                AWD3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Analog watchdog interrupt disabled
                        B_0x0 = 0x0,
                        ///  Analog watchdog interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u1,
                ///  End of calibration interrupt enable This bit is set and cleared by software to enable/disable the end of calibration interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                EOCALIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  End of calibration interrupt disabled
                        B_0x0 = 0x0,
                        ///  End of calibration interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved13: u1,
                ///  Channel Configuration Ready Interrupt enable This bit is set and cleared by software to enable/disable the channel configuration ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
                CCRDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Channel configuration ready interrupt disabled
                        B_0x0 = 0x0,
                        ///  Channel configuration ready interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u18,
            }),
            ///  ADC control register
            ADC_CR: mmio.Mmio(packed struct(u32) {
                ///  ADC enable command This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set. It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.
                ADEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC is disabled (OFF state)
                        B_0x0 = 0x0,
                        ///  Write 1 to enable the ADC.
                        B_0x1 = 0x1,
                    },
                },
                ///  ADC disable command
                ADDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No ADDIS command ongoing
                        B_0x0 = 0x0,
                        ///  Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress.
                        B_0x1 = 0x1,
                    },
                },
                ///  ADC start conversion command
                ADSTART: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No ADC conversion is ongoing.
                        B_0x0 = 0x0,
                        ///  Write 1 to start the ADC. Read 1 means that the ADC is operating and may be converting.
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u1,
                ///  ADC stop conversion command
                ADSTP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No ADC stop conversion command ongoing
                        B_0x0 = 0x0,
                        ///  Write 1 to stop the ADC. Read 1 means that an ADSTP command is in progress.
                        B_0x1 = 0x1,
                    },
                },
                reserved28: u23,
                ///  ADC Voltage Regulator Enable
                ADVREGEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC voltage regulator disabled
                        B_0x0 = 0x0,
                        ///  ADC voltage regulator enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved31: u2,
                ///  ADC calibration This bit is set by software to start the calibration of the ADC.
                ADCAL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calibration complete
                        B_0x0 = 0x0,
                        ///  Write 1 to calibrate the ADC. Read at 1 means that a calibration is in progress.
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  ADC configuration register 1
            ADC_CFGR1: mmio.Mmio(packed struct(u32) {
                ///  Direct memory access enable This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to Section113.6.5: Managing converted data using the DMA on page1333.
                DMAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA disabled
                        B_0x0 = 0x0,
                        ///  DMA enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direct memory access configuration This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN1=11. For more details, refer to Section113.6.5: Managing converted data using the DMA on page1333.
                DMACFG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA one shot mode selected
                        B_0x0 = 0x0,
                        ///  DMA circular mode selected
                        B_0x1 = 0x1,
                    },
                },
                ///  Scan sequence direction This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared. Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                SCANDIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Upward scan (from CHSEL0 to CHSEL)
                        B_0x0 = 0x0,
                        ///  Backward scan (from CHSEL to CHSEL0)
                        B_0x1 = 0x1,
                    },
                },
                ///  Data resolution These bits are written by software to select the resolution of the conversion.
                RES: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  12 bits
                        B_0x0 = 0x0,
                        ///  10 bits
                        B_0x1 = 0x1,
                        ///  8 bits
                        B_0x2 = 0x2,
                        ///  6 bits
                        B_0x3 = 0x3,
                    },
                },
                ///  Data alignment This bit is set and cleared by software to select right or left alignment. Refer to Figure141: Data alignment and resolution (oversampling disabled: OVSE = 0) on page1332
                ALIGN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Right alignment
                        B_0x0 = 0x0,
                        ///  Left alignment
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger selection These bits select the external event used to trigger the start of conversion (refer to Table160: External triggers for details):
                EXTSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  TRG0
                        B_0x0 = 0x0,
                        ///  TRG1
                        B_0x1 = 0x1,
                        ///  TRG2
                        B_0x2 = 0x2,
                        ///  TRG3
                        B_0x3 = 0x3,
                        ///  TRG4
                        B_0x4 = 0x4,
                        ///  TRG5
                        B_0x5 = 0x5,
                        ///  TRG6
                        B_0x6 = 0x6,
                        ///  TRG7
                        B_0x7 = 0x7,
                    },
                },
                reserved10: u1,
                ///  External trigger enable and polarity selection These bits are set and cleared by software to select the external trigger polarity and enable the trigger.
                EXTEN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Hardware trigger detection disabled (conversions can be started by software)
                        B_0x0 = 0x0,
                        ///  Hardware trigger detection on the rising edge
                        B_0x1 = 0x1,
                        ///  Hardware trigger detection on the falling edge
                        B_0x2 = 0x2,
                        ///  Hardware trigger detection on both the rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Overrun management mode This bit is set and cleared by software and configure the way data overruns are managed.
                OVRMOD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC_DR register is preserved with the old data when an overrun is detected.
                        B_0x0 = 0x0,
                        ///  ADC_DR register is overwritten with the last conversion result when an overrun is detected.
                        B_0x1 = 0x1,
                    },
                },
                ///  Single / continuous conversion mode This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN1=11 and CONT1=11.
                CONT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Single conversion mode
                        B_0x0 = 0x0,
                        ///  Continuous conversion mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Wait conversion mode This bit is set and cleared by software to enable/disable wait conversion mode.<sup>.</sup>
                WAIT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Wait conversion mode off
                        B_0x0 = 0x0,
                        ///  Wait conversion mode on
                        B_0x1 = 0x1,
                    },
                },
                ///  Auto-off mode This bit is set and cleared by software to enable/disable auto-off mode.<sup>.</sup>
                AUTOFF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Auto-off mode disabled
                        B_0x0 = 0x0,
                        ///  Auto-off mode enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Discontinuous mode This bit is set and cleared by software to enable/disable discontinuous mode. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN1=11 and CONT1=11.
                DISCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Discontinuous mode disabled
                        B_0x0 = 0x0,
                        ///  Discontinuous mode enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved21: u4,
                ///  Mode selection of the ADC_CHSELR register This bit is set and cleared by software to control the ADC_CHSELR feature: Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSELRMOD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Each bit of the ADC_CHSELR register enables an input
                        B_0x0 = 0x0,
                        ///  ADC_CHSELR register is able to sequence up to 8 channels
                        B_0x1 = 0x1,
                    },
                },
                ///  Enable the watchdog on a single channel or on all channels This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels
                AWD1SGL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Analog watchdog 1 enabled on all channels
                        B_0x0 = 0x0,
                        ///  Analog watchdog 1 enabled on a single channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog enable This bit is set and cleared by software.
                AWD1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Analog watchdog 1 disabled
                        B_0x0 = 0x0,
                        ///  Analog watchdog 1 enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved26: u2,
                ///  Analog watchdog channel selection These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. ..... Others: Reserved Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.
                AWD1CH: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  ADC analog input Channel 0 monitored by AWD
                        B_0x0 = 0x0,
                        ///  ADC analog input Channel 1 monitored by AWD
                        B_0x1 = 0x1,
                        ///  ADC analog input Channel 19 monitored by AWD
                        B_0x13 = 0x13,
                        _,
                    },
                },
                padding: u1,
            }),
            ///  ADC configuration register 2
            ADC_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  Oversampler Enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADEN bit is cleared.
                OVSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Oversampler disabled
                        B_0x0 = 0x0,
                        ///  Oversampler enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved2: u1,
                ///  Oversampling ratio This bit filed defines the number of oversampling ratio. Note: The software is allowed to write this bit only when ADEN bit is cleared.
                OVSR: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  2x
                        B_0x0 = 0x0,
                        ///  4x
                        B_0x1 = 0x1,
                        ///  8x
                        B_0x2 = 0x2,
                        ///  16x
                        B_0x3 = 0x3,
                        ///  32x
                        B_0x4 = 0x4,
                        ///  64x
                        B_0x5 = 0x5,
                        ///  128x
                        B_0x6 = 0x6,
                        ///  256x
                        B_0x7 = 0x7,
                    },
                },
                ///  Oversampling shift This bit is set and cleared by software. Others: Reserved Note: The software is allowed to write this bit only when ADEN bit is cleared.
                OVSS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No shift
                        B_0x0 = 0x0,
                        ///  Shift 1-bit
                        B_0x1 = 0x1,
                        ///  Shift 2-bits
                        B_0x2 = 0x2,
                        ///  Shift 3-bits
                        B_0x3 = 0x3,
                        ///  Shift 4-bits
                        B_0x4 = 0x4,
                        ///  Shift 5-bits
                        B_0x5 = 0x5,
                        ///  Shift 6-bits
                        B_0x6 = 0x6,
                        ///  Shift 7-bits
                        B_0x7 = 0x7,
                        ///  Shift 8-bits
                        B_0x8 = 0x8,
                        _,
                    },
                },
                ///  Triggered Oversampling This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADEN bit is cleared.
                TOVS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  All oversampled conversions for a channel are done consecutively after a trigger
                        B_0x0 = 0x0,
                        ///  Each oversampled conversion for a channel needs a trigger
                        B_0x1 = 0x1,
                    },
                },
                reserved29: u19,
                ///  Low frequency trigger mode enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADEN bit is cleared.
                LFTRIG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Low Frequency Trigger Mode disabled
                        B_0x0 = 0x0,
                        ///  Low Frequency Trigger Mode enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  ADC clock mode These bits are set and cleared by software to define how the analog ADC is clocked: In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL1=10, ADSTART1=10, ADSTP1=10, ADDIS1=10 and ADEN1=10).
                CKMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ADCCLK (Asynchronous clock mode), generated at product level (refer to RCC section)
                        B_0x0 = 0x0,
                        ///  PCLK/2 (Synchronous clock mode)
                        B_0x1 = 0x1,
                        ///  PCLK/4 (Synchronous clock mode)
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  ADC sampling time register
            ADC_SMPR: mmio.Mmio(packed struct(u32) {
                ///  Sampling time selection 1 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                SMP1: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  1.5 ADC clock cycles
                        B_0x0 = 0x0,
                        ///  3.5 ADC clock cycles
                        B_0x1 = 0x1,
                        ///  7.5 ADC clock cycles
                        B_0x2 = 0x2,
                        ///  12.5 ADC clock cycles
                        B_0x3 = 0x3,
                        ///  19.5 ADC clock cycles
                        B_0x4 = 0x4,
                        ///  39.5 ADC clock cycles
                        B_0x5 = 0x5,
                        ///  79.5 ADC clock cycles
                        B_0x6 = 0x6,
                        ///  160.5 ADC clock cycles
                        B_0x7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Sampling time selection 2 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                SMP2: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  1.5 ADC clock cycles
                        B_0x0 = 0x0,
                        ///  3.5 ADC clock cycles
                        B_0x1 = 0x1,
                        ///  7.5 ADC clock cycles
                        B_0x2 = 0x2,
                        ///  12.5 ADC clock cycles
                        B_0x3 = 0x3,
                        ///  19.5 ADC clock cycles
                        B_0x4 = 0x4,
                        ///  39.5 ADC clock cycles
                        B_0x5 = 0x5,
                        ///  79.5 ADC clock cycles
                        B_0x6 = 0x6,
                        ///  160.5 ADC clock cycles
                        B_0x7 = 0x7,
                    },
                },
                reserved8: u1,
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x sampling time selection (x1=119 to 0) These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                SMPSEL19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Sampling time of CHANNELx use the setting of SMP1[2:0] register.
                        B_0x0 = 0x0,
                        ///  Sampling time of CHANNELx use the setting of SMP2[2:0] register.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved32: [8]u8,
            ///  ADC watchdog threshold register
            ADC_AWD1TR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 1 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
                LT1: u12,
                reserved16: u4,
                ///  Analog watchdog 1 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
                HT1: u12,
                padding: u4,
            }),
            ///  ADC watchdog threshold register
            ADC_AWD2TR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 2 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
                LT2: u12,
                reserved16: u4,
                ///  Analog watchdog 2 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
                HT2: u12,
                padding: u4,
            }),
            ///  ADC channel selection register
            ADC_CHSELR: mmio.Mmio(packed struct(u32) {
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                ///  Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing). Note: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
                CHSEL19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Input Channel-x is not selected for conversion
                        B_0x0 = 0x0,
                        ///  Input Channel-x is selected for conversion
                        B_0x1 = 0x1,
                    },
                },
                padding: u12,
            }),
            ///  ADC watchdog threshold register
            ADC_AWD3TR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog 3lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
                LT3: u12,
                reserved16: u4,
                ///  Analog watchdog 3 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to Section113.8: Analog window watchdogs on page1337.
                HT3: u12,
                padding: u4,
            }),
            reserved64: [16]u8,
            ///  ADC data register
            ADC_DR: mmio.Mmio(packed struct(u32) {
                ///  Converted data These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in Figure141: Data alignment and resolution (oversampling disabled: OVSE = 0) on page1332. Just after a calibration is complete, DATA[6:0] contains the calibration factor.
                DATA: u16,
                padding: u16,
            }),
            reserved160: [92]u8,
            ///  ADC analog watchdog 2 configuration register
            ADC_AWD2CR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                AWD2CH19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD2
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD2
                        B_0x1 = 0x1,
                    },
                },
                padding: u12,
            }),
            ///  ADC Analog Watchdog 3 Configuration register
            ADC_AWD3CR: mmio.Mmio(packed struct(u32) {
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
                AWD3CH19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADC analog channel-x is not monitored by AWD3
                        B_0x0 = 0x0,
                        ///  ADC analog channel-x is monitored by AWD3
                        B_0x1 = 0x1,
                    },
                },
                padding: u12,
            }),
            reserved180: [12]u8,
            ///  ADC calibration factor
            ADC_CALFACT: mmio.Mmio(packed struct(u32) {
                ///  Calibration factor These bits are written by hardware or by software. Once a calibration is complete,1they are updated by hardware with the calibration factors. Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new conversion is launched. Just after a calibration is complete, DATA[6:0] contains the calibration factor. Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing).
                CALFACT: u7,
                padding: u25,
            }),
            reserved776: [592]u8,
            ///  ADC common configuration register
            ADC_CCR: mmio.Mmio(packed struct(u32) {
                reserved18: u18,
                ///  ADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL1=10, ADSTART1=10, ADSTP1=10, ADDIS1=10 and ADEN1=10).
                PRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  input ADC clock not divided
                        B_0x0 = 0x0,
                        ///  input ADC clock divided by 2
                        B_0x1 = 0x1,
                        ///  input ADC clock divided by 4
                        B_0x2 = 0x2,
                        ///  input ADC clock divided by 6
                        B_0x3 = 0x3,
                        ///  input ADC clock divided by 8
                        B_0x4 = 0x4,
                        ///  input ADC clock divided by 10
                        B_0x5 = 0x5,
                        ///  input ADC clock divided by 12
                        B_0x6 = 0x6,
                        ///  input ADC clock divided by 16
                        B_0x7 = 0x7,
                        ///  input ADC clock divided by 32
                        B_0x8 = 0x8,
                        ///  input ADC clock divided by 64
                        B_0x9 = 0x9,
                        ///  input ADC clock divided by 128
                        B_0xA = 0xa,
                        ///  input ADC clock divided by 256
                        B_0xB = 0xb,
                        _,
                    },
                },
                ///  V<sub>REFINT</sub> enable This bit is set and cleared by software to enable/disable the V<sub>REFINT</sub>. Note: Software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                VREFEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>REFINT</sub> disabled
                        B_0x0 = 0x0,
                        ///  V<sub>REFINT</sub> enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Temperature sensor enable This bit is set and cleared by software to enable/disable the temperature sensor. Note: Software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).
                TSEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Temperature sensor disabled
                        B_0x0 = 0x0,
                        ///  Temperature sensor enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  V<sub>BAT</sub> enable This bit is set and cleared by software to enable/disable the V<sub>BAT</sub> channel. Note: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)
                VBATEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>BAT</sub> channel disabled
                        B_0x0 = 0x0,
                        ///  V<sub>BAT</sub> channel enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
        };

        ///  AES register block
        pub const AES = extern struct {
            ///  AES control register
            AES_CR: mmio.Mmio(packed struct(u32) {
                ///  Enable This bit enables/disables the AES peripheral. At any moment, clearing then setting the bit re-initializes the AES peripheral. This bit is automatically cleared by hardware upon the completion of the key preparation (MODE[1:0] at 0x1) and upon the completion of GCM/GMAC/CCM initialization phase. The bit cannot be set as long as KEYVALID1is cleared
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Data type This bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping. This swapping is defined in Section121.4.14: AES data registers and data swapping. Attempts to write the bitfield are ignored when EN is set before the write access and it is not cleared by that write access.
                DATATYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No swapping (32-bit data).
                        B_0x0 = 0x0,
                        ///  Half-word swapping (16-bit data)
                        B_0x1 = 0x1,
                        ///  Byte swapping (8-bit data)
                        B_0x2 = 0x2,
                        ///  Bit-level swapping
                        B_0x3 = 0x3,
                    },
                },
                ///  Operating mode This bitfield selects the AES operating mode: Attempts to write the bitfield are ignored when EN is set before the write access and it is not cleared by that write access.
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Encryption
                        B_0x0 = 0x0,
                        ///  Key derivation (or key preparation), for ECB/CBC decryption only
                        B_0x1 = 0x1,
                        ///  Decryption
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  CHMOD[1:0]: Chaining mode This bitfield selects the AES chaining mode: others: Reserved Attempts to write the bitfield are ignored when EN is set before the write access and it is not cleared by that write access.
                CHMOD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Electronic codebook (ECB)
                        B_0x0 = 0x0,
                        ///  Cipher-block chaining (CBC)
                        B_0x1 = 0x1,
                        ///  Counter mode (CTR)
                        B_0x2 = 0x2,
                        ///  Galois counter mode (GCM) and Galois message authentication code (GMAC)
                        B_0x3 = 0x3,
                    },
                },
                reserved11: u4,
                ///  DMA input enable This bit enables automatic generation of DMA requests during the data phase, for incoming data transfers to AES via DMA. Setting this bit is ignored when MODE[1:0] is at 0x1 (key derivation).
                DMAINEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA output enable This bit enables automatic generation of DMA requests during the data phase, for outgoing data transfers from AES via DMA. Setting this bit is ignored when MODE[1:0] is at 0x1 (key derivation).
                DMAOUTEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  GCM or CCM phase selection This bitfield selects the phase, applicable only with GCM, GMAC or CCM chaining modes.
                GCMPH: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Initialization phase
                        B_0x0 = 0x0,
                        ///  Header phase
                        B_0x1 = 0x1,
                        ///  Payload phase
                        B_0x2 = 0x2,
                        ///  Final phase
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u1,
                ///  CHMOD[2]
                CHMOD_1: u1,
                reserved18: u1,
                ///  Key size selection This bitfield defines the key length in bits of the key used by AES. Attempts to write the bit are ignored when the EN is set before the write access and it is not cleared by that write access.
                KEYSIZE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  128-bit
                        B_0x0 = 0x0,
                        ///  256-bit
                        B_0x1 = 0x1,
                    },
                },
                reserved20: u1,
                ///  Number of padding bytes in last block This padding information must be filled by software before processing the last block of GCM payload encryption or CCM payload decryption, otherwise authentication tag computation is incorrect. ...
                NPBLB: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  All bytes are valid (no padding)
                        B_0x0 = 0x0,
                        ///  Padding for the last LSB byte
                        B_0x1 = 0x1,
                        ///  Padding for the 15 LSB bytes of last block.
                        B_0xF = 0xf,
                        _,
                    },
                },
                reserved31: u7,
                ///  AES peripheral software reset Setting the bit resets the AES peripheral, putting all registers to their default values, except the IPRST bit itself. Hence, any key-relative data are lost. For this reason, it is recommended to set the bit before handing over the AES to a less secure application. The bit must be kept low while writing any configuration registers.
                IPRST: u1,
            }),
            ///  AES status register
            AES_SR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Read error flag This bit is set when an unexpected read to the AES_DOUTR register occurred. When set RDERRF bit has no impact on the AES operations. The flag setting generates an interrupt if the RWEIE bit of the AES_IER register is set. The flag is cleared by setting the RWEIF bit of the AES_ICR register.
                RDERRF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No error
                        B_0x0 = 0x0,
                        ///  Unexpected read to AES_DOUTR register occurred during computation or data input phase.
                        B_0x1 = 0x1,
                    },
                },
                ///  Write error flag This bit is set when an unexpected write to the AES_DINR register occurred. When set WRERRF bit has no impact on the AES operations. The flag setting generates an interrupt if the RWEIE bit of the AES_IER register is set. The flag is cleared by setting the RWEIF bit of the AES_ICR register.
                WRERRF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No error
                        B_0x0 = 0x0,
                        ///  Unexpected write to AES_DINR register occurred during computation or data output phase.
                        B_0x1 = 0x1,
                    },
                },
                ///  Busy This flag indicates whether AES is idle or busy. AES is flagged as idle when disabled (when EN is low) or when the last processing is completed. AES is flagged as busy when processing a block data, preparing a key (ECB or CBC decryption only). When GCM encryption is selected, this flag must be at zero before suspending current process to manage a higher-priority message.
                BUSY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Idle
                        B_0x0 = 0x0,
                        ///  Busy
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u3,
                ///  Key valid flag This bit is set by hardware when the key of size defined by KEYSIZE is loaded in AES_KEYRx key registers. The EN bit can only be set when KEYVALID is set. The key must be written in the key registers in the correct sequence, otherwise the KEIF flag is set and KEYVALID remains cleared. If set, KEIF must be cleared through the AES_ICR register, otherwise KEYVALID cannot be set. See the KEIF flag description for more details. For further information on key loading, refer to Section121.4.15: AES key registers.
                KEYVALID: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Key not valid
                        B_0x0 = 0x0,
                        ///  Key valid
                        B_0x1 = 0x1,
                    },
                },
                padding: u24,
            }),
            ///  AES data input register
            AES_DINR: mmio.Mmio(packed struct(u32) {
                ///  Data input A four-fold sequential write to this bitfield during the Input phase results in writing a complete 16-bytes block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 16-bytes input buffer. Reads return zero.
                DIN: u32,
            }),
            ///  AES data output register
            AES_DOUTR: mmio.Mmio(packed struct(u32) {
                ///  Data output This read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon the computation completion (CCF flag set), virtually reads a complete 16-byte block of output data from the AES peripheral. Before reaching the output buffer, the data produced by the AES core are handled by the data swap block according to the DATATYPE[1:0] bitfield. Data weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0].
                DOUT: u32,
            }),
            ///  AES key register 0
            AES_KEYR0: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [31:0] These are bits [31:0] of the write-only bitfield KEY[255:0] AES encryption or decryption key, depending on the MODE[1:0] bitfield of the AES_CR register. Writes to AES_KEYRx registers are ignored when AES is enabled (EN bit set). A special writing sequence is required. In this sequence, any valid write to AES_KEYRx register clears the KEYVALID flag except for the sequence-completing write that sets it. Also refer to the description of the KEYVALID flag in the AES_SR register.
                KEY: u32,
            }),
            ///  AES key register 1
            AES_KEYR1: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [63:32] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES key register 2
            AES_KEYR2: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [95:64] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES key register 3
            AES_KEYR3: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [127:96] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES initialization vector register 0
            AES_IVR0: mmio.Mmio(packed struct(u32) {
                ///  Initialization vector input, bits [31:0] AES_IVRx registers store the 128-bit initialization vector or the nonce, depending on the chaining mode selected. This value is updated by hardware after each computation round (when applicable). Write to this register is ignored when EN bit is set in AES_SR register
                IVI: u32,
            }),
            ///  AES initialization vector register 1
            AES_IVR1: mmio.Mmio(packed struct(u32) {
                ///  Initialization vector input, bits [63:32] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.
                IVI: u32,
            }),
            ///  AES initialization vector register 2
            AES_IVR2: mmio.Mmio(packed struct(u32) {
                ///  Initialization vector input, bits [95:64] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.
                IVI: u32,
            }),
            ///  AES initialization vector register 3
            AES_IVR3: mmio.Mmio(packed struct(u32) {
                ///  Initialization vector input, bits [127:96] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.
                IVI: u32,
            }),
            ///  AES key register 4
            AES_KEYR4: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [159:128] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES key register 5
            AES_KEYR5: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [191:160] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES key register 6
            AES_KEYR6: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [223:192] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES key register 7
            AES_KEYR7: mmio.Mmio(packed struct(u32) {
                ///  Cryptographic key, bits [255:224] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers.
                KEY: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR0: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR1: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR2: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR3: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR4: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR5: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR6: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            ///  AES suspend registers
            AES_SUSPR7: mmio.Mmio(packed struct(u32) {
                ///  Suspend data AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details. Read to this register returns zero when EN bit is cleared in AES_SR register. AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.
                SUSP: u32,
            }),
            reserved768: [672]u8,
            ///  AES interrupt enable register
            AES_IER: mmio.Mmio(packed struct(u32) {
                ///  Computation complete flag interrupt enable This bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set.
                CCFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled (masked)
                        B_0x0 = 0x0,
                        ///  Enabled (not masked)
                        B_0x1 = 0x1,
                    },
                },
                ///  Read or write error interrupt enable This bit enables or disables (masks) the AES interrupt generation when RWEIF (read and/or write error flag) is set.
                RWEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled (masked)
                        B_0x0 = 0x0,
                        ///  Enabled (not masked)
                        B_0x1 = 0x1,
                    },
                },
                ///  Key error interrupt enable This bit enables or disables (masks) the AES interrupt generation when KEIF (key error flag) is set.
                KEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled (masked)
                        B_0x0 = 0x0,
                        ///  Enabled (not masked)
                        B_0x1 = 0x1,
                    },
                },
                padding: u29,
            }),
            ///  AES interrupt status register
            AES_ISR: mmio.Mmio(packed struct(u32) {
                ///  Computation complete flag This flag indicates whether the computation is completed. It is significant only when the DMAOUTEN bit is cleared, and it may stay high when DMAOUTEN is set. The flag setting generates an interrupt if the CCFIE bit of the AES_IER register is set. The flag is cleared by setting the corresponding bit of the AES_ICR register.
                CCF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not completed
                        B_0x0 = 0x0,
                        ///  Completed
                        B_0x1 = 0x1,
                    },
                },
                ///  Read or write error interrupt flag This read-only bit is set by hardware when a RDERRF or a WRERRF error flag is set in the AES_SR register. The flag setting generates an interrupt if the RWEIE bit of the AES_IER register is set. The flag is cleared by setting the corresponding bit of the AES_ICR register. The flags has no meaning when key derivation mode is selected. See the AES_SR register for details.
                RWEIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No read or write error detected
                        B_0x0 = 0x0,
                        ///  Read or write error detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Key error interrupt flag This read-only bit is set by hardware when the key information fails to load into key registers. The flag setting generates an interrupt if the KEIE bit of the AES_IER register is set. The flag is cleared by setting the corresponding bit of the AES_ICR register. KEIF is raised upon any of the following events: AES_KEYRx register write does not respect the correct order. (For KEYSIZE1cleared, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 register, or reverse. For KEYSIZE set, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 then AES_KEYR4 then AES_KEYR5 then AES_KEYR6 then AES_KEYR7, or reverse). KEIF must be cleared by the application software, otherwise KEYVALID cannot be set.
                KEIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No key error detected
                        B_0x0 = 0x0,
                        ///  Key information failed to load into key registers
                        B_0x1 = 0x1,
                    },
                },
                padding: u29,
            }),
            ///  AES interrupt clear register
            AES_ICR: mmio.Mmio(packed struct(u32) {
                ///  Computation complete flag clear Setting this bit clears the CCF status bit of the AES_ISR register.
                CCF: u1,
                ///  Read or write error interrupt flag clear Setting this bit clears the RWEIF status bit of the AES_ISR register, and clears both RDERRF and WRERRF flags in the AES_SR register.
                RWEIF: u1,
                ///  Key error interrupt flag clear Setting this bit clears the KEIF status bit of the AES_ISR register.
                KEIF: u1,
                padding: u29,
            }),
        };

        ///  COMP address block description
        pub const COMP = extern struct {
            ///  Comparator 1 control and status register
            COMP1_CSR: mmio.Mmio(packed struct(u32) {
                ///  Comparator 1 enable bit This bit is controlled by software (if not locked). It enables the comparator 1:
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u3,
                ///  Comparator 1 signal selector for inverting input INM This bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP_INM of the comparator 1: Refer to Table176: COMP1 inverting input assignment.
                INMSEL: u4,
                ///  Comparator 1 signal selector for noninverting input This bitfield is controlled by software (if not locked). It selects the signal for the noninverting input COMP_INP of the comparator 1 (also see the WINMODE bit): Refer to Table175: COMP1 noninverting input assignment.
                INPSEL: u3,
                ///  Comparator 1 noninverting input selector for window mode This bit is controlled by software (if not locked). It selects the signal for COMP_INP input of the comparator 1:
                WINMODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Signal selected with INPSEL[2:0] bitfield of this register
                        B_0x0 = 0x0,
                        ///  COMP_INP signal of the comparator 2 (required for window mode, see Figure164)
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u2,
                ///  Comparator 1 output selector This bit is controlled by software (if not locked). It selects the comparator 1 output:
                WINOUT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP_VALUE
                        B_0x0 = 0x0,
                        ///  COMP_VALUE XOR COMP_VALUE (required for window mode, see Figure164)
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator 1 polarity selector This bit is controlled by software (if not locked). It selects the comparator 1 output polarity:
                POLARITY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Non-inverted
                        B_0x0 = 0x0,
                        ///  Inverted
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator 1 hysteresis selector This bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 1:
                HYST: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No hysteresis
                        B_0x0 = 0x0,
                        ///  Low hysteresis
                        B_0x1 = 0x1,
                        ///  Medium hysteresis
                        B_0x2 = 0x2,
                        ///  High hysteresis
                        B_0x3 = 0x3,
                    },
                },
                ///  Comparator 1 power mode selector This bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 1:
                PWRMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  High speed/high power
                        B_0x0 = 0x0,
                        ///  Medium speed/medium power
                        B_0x1 = 0x1,
                        ///  Medium speed/medium power
                        B_0x2 = 0x2,
                        ///  Low speed/low power
                        B_0x3 = 0x3,
                    },
                },
                ///  Comparator 1 blanking source selector This bitfield is controlled by software (if not locked). It selects the blanking source: Others: Reserved, must not be used
                BLANKSEL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  No blanking
                        B_0x0 = 0x0,
                        ///  TIM1 OC4 enabled as blanking source
                        B_0x1 = 0x1,
                        ///  TIM1 OC5 enabled as blanking source
                        B_0x2 = 0x2,
                        ///  TIM2 OC3 enabled as blanking source
                        B_0x4 = 0x4,
                        ///  TIM3 OC3 enabled as blanking source
                        B_0x8 = 0x8,
                        ///  TIM15 OC2 enabled as blanking source
                        B_0x10 = 0x10,
                        _,
                    },
                },
                reserved30: u5,
                ///  Comparator 1 output status This bit is read-only. It reflects the level of the comparator 1 output after the polarity selector and blanking, as indicated in Figure163.
                VALUE: u1,
                ///  COMP_CSR register lock This bit is set by software and cleared by a system reset. It locks the comparator 3 control bits. When locked, all register bits are read-only.
                LOCK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not locked
                        B_0x0 = 0x0,
                        ///  Locked
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  Comparator 2 control and status register
            COMP2_CSR: mmio.Mmio(packed struct(u32) {
                ///  Comparator 2 enable bit This bit is controlled by software (if not locked). It enables the comparator 2:
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u3,
                ///  Comparator 2 signal selector for inverting input INM This bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP_INM of the comparator 2: Refer to Table178: COMP2 inverting input assignment.
                INMSEL: u4,
                ///  Comparator 2 signal selector for noninverting input This bitfield is controlled by software (if not locked). It selects the signal for the noninverting input COMP_INP of the comparator 2 (also see the WINMODE bit): Refer to Table177: COMP2 noninverting input assignment.
                INPSEL: u2,
                reserved11: u1,
                ///  Comparator 2 noninverting input selector for window mode This bit is controlled by software (if not locked). It selects the signal for COMP_INP input of the comparator 2:
                WINMODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Signal selected with INPSEL[1:0] bitfield of this register
                        B_0x0 = 0x0,
                        ///  COMP_INP signal of the comparator 1 (required for window mode, see Figure164)
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u2,
                ///  Comparator 2 output selector This bit is controlled by software (if not locked). It selects the comparator 2 output:
                WINOUT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP_VALUE
                        B_0x0 = 0x0,
                        ///  COMP_VALUE XOR COMP_VALUE (required for window mode, see Figure164)
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator 2 polarity selector This bit is controlled by software (if not locked). It selects the comparator 2 output polarity:
                POLARITY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Non-inverted
                        B_0x0 = 0x0,
                        ///  Inverted
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator 2 hysteresis selector This bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 2:
                HYST: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No hysteresis
                        B_0x0 = 0x0,
                        ///  Low hysteresis
                        B_0x1 = 0x1,
                        ///  Medium hysteresis
                        B_0x2 = 0x2,
                        ///  High hysteresis
                        B_0x3 = 0x3,
                    },
                },
                ///  Comparator 2 power mode selector This bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 2:
                PWRMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  High speed/high power
                        B_0x0 = 0x0,
                        ///  Medium speed/medium power
                        B_0x1 = 0x1,
                        ///  Medium speed/medium power
                        B_0x2 = 0x2,
                        ///  Low speed/low power
                        B_0x3 = 0x3,
                    },
                },
                ///  Comparator 2 blanking source selector This bitfield is controlled by software (if not locked). It selects the blanking source: Others: Reserved, must not be used
                BLANKSEL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  No blanking
                        B_0x0 = 0x0,
                        ///  TIM1 OC4 enabled as blanking source
                        B_0x1 = 0x1,
                        ///  TIM1 OC5 enabled as blanking source
                        B_0x2 = 0x2,
                        ///  TIM2 OC3 enabled as blanking source
                        B_0x4 = 0x4,
                        ///  TIM3 OC3 enabled as blanking source
                        B_0x8 = 0x8,
                        ///  TIM15 OC2 enabled as blanking source
                        B_0x10 = 0x10,
                        _,
                    },
                },
                reserved30: u5,
                ///  Comparator 2 output status This bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in Figure163.
                VALUE: u1,
                ///  COMP_CSR register lock This bit is set by software and cleared by a system reset. It locks the comparator 3 control bits. When locked, all register bits are read-only.
                LOCK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not locked
                        B_0x0 = 0x0,
                        ///  Locked
                        B_0x1 = 0x1,
                    },
                },
            }),
        };

        ///  CRC address block description
        pub const CRC = extern struct {
            ///  CRC data register
            CRC_DR: mmio.Mmio(packed struct(u32) {
                ///  Data register bits This register is used to write new data to the CRC calculator. It holds the previous CRC calculation result when it is read. If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
                DR: u32,
            }),
            ///  CRC independent data register
            CRC_IDR: mmio.Mmio(packed struct(u32) {
                ///  General-purpose 32-bit data register bits These bits can be used as a temporary storage location for four bytes. This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register
                IDR: u32,
            }),
            ///  CRC control register
            CRC_CR: mmio.Mmio(packed struct(u32) {
                ///  RESET bit This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
                RESET: u1,
                reserved3: u2,
                ///  Polynomial size These bits control the size of the polynomial.
                POLYSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  32 bit polynomial
                        B_0x0 = 0x0,
                        ///  16 bit polynomial
                        B_0x1 = 0x1,
                        ///  8 bit polynomial
                        B_0x2 = 0x2,
                        ///  7 bit polynomial
                        B_0x3 = 0x3,
                    },
                },
                ///  Reverse input data This bitfield controls the reversal of the bit order of the input data
                REV_IN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Bit order not affected (RTYPE_IN1=10 or 1)
                        B_0x0 = 0x0,
                        ///  Bit reversal done by byte (RTYPE_IN1=10) or half-word reversal done by word (RTYPE_IN1=11)
                        B_0x1 = 0x1,
                        ///  Bit reversal done by half-word (RTYPE_IN1=10) or byte reversal done by word (RTYPE_IN1=11)
                        B_0x2 = 0x2,
                        ///  Bit reversal done by word (RTYPE_IN1=10) or bit order is not affected (RTYPE_IN1=11)
                        B_0x3 = 0x3,
                    },
                },
                ///  Reverse output data This bitfield controls the reversal of the bit order of the output data.
                REV_OUT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Bit order not affected (RTYPE_OUT1=10 or 1)
                        B_0x0 = 0x0,
                        ///  Bit-reversed output format (RTYPE_OUT1=10) or half-word reversal done by word (RTYPE_OUT1=11)
                        B_0x1 = 0x1,
                        ///  Bit order not affected (RTYPE_OUT1=10) or byte reversal done by word (RTYPE_OUT1=11)
                        B_0x2 = 0x2,
                        ///  Bit order not affected (RTYPE_OUT1=10 or 1)
                        B_0x3 = 0x3,
                    },
                },
                ///  Reverse type input This bit controls the reversal granularity of the input data.
                RTYPE_IN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Bit level input
                        B_0x0 = 0x0,
                        ///  Byte or half-word level input
                        B_0x1 = 0x1,
                    },
                },
                ///  Reverse type output This bit controls the reversal granularity of the output data.
                RTYPE_OUT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Bit level output
                        B_0x0 = 0x0,
                        ///  Byte or half-word level output
                        B_0x1 = 0x1,
                    },
                },
                padding: u21,
            }),
            reserved16: [4]u8,
            ///  CRC initial value
            CRC_INIT: mmio.Mmio(packed struct(u32) {
                ///  Programmable initial CRC value This register is used to write the CRC initial value.
                CRC_INIT: u32,
            }),
            ///  CRC polynomial
            CRC_POL: mmio.Mmio(packed struct(u32) {
                ///  Programmable polynomial This register is used to write the coefficients of the polynomial to be used for CRC calculation. If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
                POL: u32,
            }),
        };

        ///  CRS address block description
        pub const CRS = extern struct {
            ///  CRS control register
            CRS_CR: mmio.Mmio(packed struct(u32) {
                ///  SYNC event OK interrupt enable
                SYNCOKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SYNC event OK (SYNCOKF) interrupt disabled
                        B_0x0 = 0x0,
                        ///  SYNC event OK (SYNCOKF) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  SYNC warning interrupt enable
                SYNCWARNIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SYNC warning (SYNCWARNF) interrupt disabled
                        B_0x0 = 0x0,
                        ///  SYNC warning (SYNCWARNF) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization or trimming error interrupt enable
                ERRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization or trimming error (ERRF) interrupt disabled
                        B_0x0 = 0x0,
                        ///  Synchronization or trimming error (ERRF) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Expected SYNC interrupt enable
                ESYNCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Expected SYNC (ESYNCF) interrupt disabled
                        B_0x0 = 0x0,
                        ///  Expected SYNC (ESYNCF) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u1,
                ///  Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Frequency error counter disabled
                        B_0x0 = 0x0,
                        ///  Frequency error counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section15.4.4 for more details.
                AUTOTRIMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Automatic trimming disabled, TRIM bits can be adjusted by the user.
                        B_0x0 = 0x0,
                        ///  Automatic trimming enabled, TRIM bits are read-only and under hardware control.
                        B_0x1 = 0x1,
                    },
                },
                ///  Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
                SWSYNC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A software SYNC event is generated.
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI48 oscillator smooth trimming The default value of the HSI48 oscillator smooth trimming is 64, which corresponds to the middle of the trimming interval.
                TRIM: u7,
                padding: u17,
            }),
            ///  CRS configuration register
            CRS_CFGR: mmio.Mmio(packed struct(u32) {
                ///  Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section15.4.3 for more details about counter behavior.
                RELOAD: u16,
                ///  Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section15.4.4 for more details about FECAP evaluation.
                FELIM: u8,
                ///  SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
                SYNCDIV: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  SYNC not divided (default)
                        B_0x0 = 0x0,
                        ///  SYNC divided by 2
                        B_0x1 = 0x1,
                        ///  SYNC divided by 4
                        B_0x2 = 0x2,
                        ///  SYNC divided by 8
                        B_0x3 = 0x3,
                        ///  SYNC divided by 16
                        B_0x4 = 0x4,
                        ///  SYNC divided by 32
                        B_0x5 = 0x5,
                        ///  SYNC divided by 64
                        B_0x6 = 0x6,
                        ///  SYNC divided by 128
                        B_0x7 = 0x7,
                    },
                },
                reserved28: u1,
                ///  SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source (see Table122): Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF is not generated by the host. No SYNC signal is therefore provided to the CRS to calibrate the HSI48 oscillator on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs must be used as SYNC signal.
                SYNCSRC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  crs_sync_in_1 selected as SYNC signal source
                        B_0x0 = 0x0,
                        ///  crs_sync_in_2 selected as SYNC signal source
                        B_0x1 = 0x1,
                        ///  crs_sync_in_3 selected as SYNC signal source
                        B_0x2 = 0x2,
                        ///  crs_sync_in_4 selected as SYNC signal source
                        B_0x3 = 0x3,
                    },
                },
                reserved31: u1,
                ///  SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
                SYNCPOL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SYNC active on rising edge (default)
                        B_0x0 = 0x0,
                        ///  SYNC active on falling edge
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  CRS interrupt and status register
            CRS_ISR: mmio.Mmio(packed struct(u32) {
                ///  SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
                SYNCOKF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SYNC event OK signaled
                        B_0x0 = 0x0,
                        ///  SYNC event OK signaled
                        B_0x1 = 0x1,
                    },
                },
                ///  SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
                SYNCWARNF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SYNC warning signaled
                        B_0x0 = 0x0,
                        ///  SYNC warning signaled
                        B_0x1 = 0x1,
                    },
                },
                ///  Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
                ERRF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No synchronization or trimming error signaled
                        B_0x0 = 0x0,
                        ///  Synchronization or trimming error signaled
                        B_0x1 = 0x1,
                    },
                },
                ///  Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
                ESYNCF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No expected SYNC signaled
                        B_0x0 = 0x0,
                        ///  Expected SYNC signaled
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u4,
                ///  SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action has to be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
                SYNCERR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SYNC error signaled
                        B_0x0 = 0x0,
                        ///  SYNC error signaled
                        B_0x1 = 0x1,
                    },
                },
                ///  SYNC missed This flag is set by hardware when the frequency error counter reaches value FELIM * 128 and no SYNC is detected, meaning either that a SYNC pulse was missed, or the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, hence some other action must be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC), and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
                SYNCMISS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SYNC missed error signaled
                        B_0x0 = 0x0,
                        ///  SYNC missed error signaled
                        B_0x1 = 0x1,
                    },
                },
                ///  Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
                TRIMOVF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No trimming error signaled
                        B_0x0 = 0x0,
                        ///  Trimming error signaled
                        B_0x1 = 0x1,
                    },
                },
                reserved15: u4,
                ///  Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
                FEDIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Up-counting direction, the actual frequency is above the target
                        B_0x0 = 0x0,
                        ///  Down-counting direction, the actual frequency is below the target
                        B_0x1 = 0x1,
                    },
                },
                ///  Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section15.4.4 for more details about FECAP usage.
                FECAP: u16,
            }),
            ///  CRS interrupt flag clear register
            CRS_ICR: mmio.Mmio(packed struct(u32) {
                ///  SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
                SYNCOKC: u1,
                ///  SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
                SYNCWARNC: u1,
                ///  Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
                ERRC: u1,
                ///  Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
                ESYNCC: u1,
                padding: u28,
            }),
        };

        ///  DAC address block description
        pub const DAC = extern struct {
            ///  DAC control register
            DAC_CR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
                EN1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DAC channel1 disabled
                        B_0x0 = 0x0,
                        ///  DAC channel1 enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC channel1 trigger enable This bit is set and cleared by software to enable/disable DAC channel1 trigger. Note: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle.
                TEN1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DAC channel1 trigger disabled and data written into the DAC_DHR1 register are transferred one dac_pclk clock cycle later to the DAC_DOR1 register
                        B_0x0 = 0x0,
                        ///  DAC channel1 trigger enabled and data from the DAC_DHR1 register are transferred three dac_pclk clock cycles later to the DAC_DOR1 register
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1 ... Refer to the trigger selection tables in Section114.4.2: DAC pins and internal signals for details on trigger configuration and mapping. Note: Only used if bit TEN11=11 (DAC channel1 trigger enabled).
                TSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  SWTRIG1
                        B_0x0 = 0x0,
                        ///  dac_ch1_trg1
                        B_0x1 = 0x1,
                        ///  dac_ch1_trg2
                        B_0x2 = 0x2,
                        ///  dac_ch1_trg15
                        B_0xF = 0xf,
                        _,
                    },
                },
                ///  DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. 1x: Triangle wave generation enabled Only used if bit TEN11=11 (DAC channel1 trigger enabled).
                WAVE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  wave generation disabled
                        B_0x0 = 0x0,
                        ///  Noise wave generation enabled
                        B_0x1 = 0x1,
                        _,
                    },
                },
                ///  DAC channel1 mask/amplitude selector
                MAMP1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Unmask bit0 of LFSR/ triangle amplitude equal to 1
                        B_0x0 = 0x0,
                        ///  Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3
                        B_0x1 = 0x1,
                        ///  Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7
                        B_0x2 = 0x2,
                        ///  Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15
                        B_0x3 = 0x3,
                        ///  Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31
                        B_0x4 = 0x4,
                        ///  Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63
                        B_0x5 = 0x5,
                        ///  Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127
                        B_0x6 = 0x6,
                        ///  Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255
                        B_0x7 = 0x7,
                        ///  Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511
                        B_0x8 = 0x8,
                        ///  Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023
                        B_0x9 = 0x9,
                        ///  Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047
                        B_0xA = 0xa,
                        _,
                    },
                },
                ///  DAC channel1 DMA enable This bit is set and cleared by software.
                DMAEN1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DAC channel1 DMA mode disabled
                        B_0x0 = 0x0,
                        ///  DAC channel1 DMA mode enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
                DMAUDRIE1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DAC channel1 DMA Underrun Interrupt disabled
                        B_0x0 = 0x0,
                        ///  DAC channel1 DMA Underrun Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC channel1 calibration enable This bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN11=10 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
                CEN1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DAC channel1 in Normal operating mode
                        B_0x0 = 0x0,
                        ///  DAC channel1 in calibration mode
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DAC software trigger register
            DAC_SWTRGR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
                SWTRIG1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No trigger
                        B_0x0 = 0x0,
                        ///  Trigger
                        B_0x1 = 0x1,
                    },
                },
                padding: u31,
            }),
            ///  DAC channel1 12-bit right-aligned data holding register
            DAC_DHR12R1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 12-bit right-aligned data These bits are written by software. They specify 12-bit data for DAC channel1.
                DACC1DHR: u12,
                padding: u20,
            }),
            ///  DAC channel1 12-bit left aligned data holding register
            DAC_DHR12L1: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DAC channel1 12-bit left-aligned data These bits are written by software. They specify 12-bit data for DAC channel1.
                DACC1DHR: u12,
                padding: u16,
            }),
            ///  DAC channel1 8-bit right aligned data holding register
            DAC_DHR8R1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 8-bit right-aligned data These bits are written by software. They specify 8-bit data for DAC channel1.
                DACC1DHR: u8,
                padding: u24,
            }),
            reserved44: [24]u8,
            ///  DAC channel1 data output register
            DAC_DOR1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
                DACC1DOR: u12,
                padding: u20,
            }),
            reserved52: [4]u8,
            ///  DAC status register
            DAC_SR: mmio.Mmio(packed struct(u32) {
                reserved13: u13,
                ///  DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
                DMAUDR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No DMA underrun error condition occurred for DAC channel1
                        B_0x0 = 0x0,
                        ///  DMA underrun error condition occurred for DAC channel1 (the currently selected trigger is driving DAC channel1 conversion at a frequency higher than the DMA service capability rate)
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC channel1 calibration offset status This bit is set and cleared by hardware
                CAL_FLAG1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  calibration trimming value is lower than the offset correction value
                        B_0x0 = 0x0,
                        ///  calibration trimming value is equal or greater than the offset correction value
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC channel1 busy writing sample time flag This bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization).
                BWST1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  There is no write operation of DAC_SHSR1 ongoing: DAC_SHSR1 can be written
                        B_0x0 = 0x0,
                        ///  There is a write operation of DAC_SHSR1 ongoing: DAC_SHSR1 cannot be written
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  DAC calibration control register
            DAC_CCR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 offset trimming value
                OTRIM1: u5,
                padding: u27,
            }),
            ///  DAC mode control register
            DAC_MCR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN11=10 and bit CEN11=10 in the DAC_CR register). If EN11=11 or CEN11=11 the write operation is ignored. They can be set and cleared by software to select the DAC channel1 mode: DAC channel1 in Normal mode DAC channel1 in sample & hold mode Note: This register can be modified only when EN11=10.
                MODE1: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  DAC channel1 is connected to external pin with Buffer enabled
                        B_0x0 = 0x0,
                        ///  DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled
                        B_0x1 = 0x1,
                        ///  DAC channel1 is connected to external pin with Buffer disabled
                        B_0x2 = 0x2,
                        ///  DAC channel1 is connected to on chip peripherals with Buffer disabled
                        B_0x3 = 0x3,
                        ///  DAC channel1 is connected to external pin with Buffer enabled
                        B_0x4 = 0x4,
                        ///  DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled
                        B_0x5 = 0x5,
                        ///  DAC channel1 is connected to external pin and to on chip peripherals with Buffer disabled
                        B_0x6 = 0x6,
                        ///  DAC channel1 is connected to on chip peripherals with Buffer disabled
                        B_0x7 = 0x7,
                    },
                },
                padding: u29,
            }),
            ///  DAC channel1 sample and hold sample time register
            DAC_SHSR1: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 sample time (only valid in Sample and hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST11=11, the write operation is ignored.
                TSAMPLE1: u10,
                padding: u22,
            }),
            reserved72: [4]u8,
            ///  DAC sample and hold time register
            DAC_SHHR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 hold time (only valid in Sample and hold mode) Hold time1=1(THOLD[9:0]) x LSI clock period Note: This register can be modified only when EN11=10.
                THOLD1: u10,
                padding: u22,
            }),
            ///  DAC sample and hold refresh time register
            DAC_SHRR: mmio.Mmio(packed struct(u32) {
                ///  DAC channel1 refresh time (only valid in Sample and hold mode) Refresh time1=1(TREFRESH[7:0]) x LSI clock period Note: This register can be modified only when EN11=10.
                TREFRESH1: u8,
                padding: u24,
            }),
        };

        ///  DBGMCU register block
        pub const DBGMCU = extern struct {
            ///  DBGMCU device ID code register
            DBGMCU_IDCODE: mmio.Mmio(packed struct(u32) {
                ///  Device identifier This field indicates the device ID.
                DEV_ID: packed union {
                    raw: u12,
                    value: enum(u12) {
                        ///  STM32U031xx
                        B_0x459 = 0x459,
                        ///  STM32U073/083xx
                        B_0x489 = 0x489,
                        _,
                    },
                },
                reserved16: u4,
                ///  Revision identifier This field indicates the revision of the device.
                REV_ID: packed union {
                    raw: u16,
                    value: enum(u16) {
                        ///  Revision A for STM32U031/73/83xx
                        B_0x1000 = 0x1000,
                        _,
                    },
                },
            }),
            ///  DBGMCU configuration register
            DBGMCU_CR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Debug Stop mode Debug options in Stop mode.
                DBG_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  All clocks disabled, including FCLK and HCLK. Upon Stop mode exit, the CPU is clocked by the HSI internal RC oscillator.
                        B_0x0 = 0x0,
                        ///  FCLK and HCLK running, derived from the internal RC oscillator remaining active. If SysTick is enabled, it may generate periodic interrupt and wake up events.Upon Stop mode exit, the software must re-establish the desired clock configuration.
                        B_0x1 = 0x1,
                    },
                },
                ///  Debug Standby and Shutdown modes Debug options in Standby or Shutdown mode.
                DBG_STANDBY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Digital part powered. From software point of view, exiting Standby and Shutdown modes is identical as fetching reset vector (except for status bits indicating that the MCU exits Standby)
                        B_0x0 = 0x0,
                        ///  Digital part powered and FCLK and HCLK running, derived from the internal RC oscillator remaining active. The MCU generates a system reset so that exiting Standby and Shutdown has the same effect as starting from reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u29,
            }),
            ///  DBGMCU APB1 freeze register
            DBGMCU_APB1FZR: mmio.Mmio(packed struct(u32) {
                ///  TIM2 stop in debug
                DBG_TIM2_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM2 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM2 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM3 stop in debug
                DBG_TIM3_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM3 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM3 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM4 stop in debug
                DBG_TIM4_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM4 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM34 is frozen while CPU is in debug mode
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u1,
                ///  TIM6 stop in debug
                DBG_TIM6_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM6 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM6 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM7 stop in debug
                DBG_TIM7_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM7 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM7 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                reserved10: u4,
                ///  RTC stop in debug
                DBG_RTC_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. RTC counter continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. RTC counter is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  WWDG stop in debug
                DBG_WWDG_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. WWDG continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. WWDG is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  IWDG stop in debug
                DBG_IWDG_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. IWDG continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. IWDG is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                reserved21: u8,
                ///  I2C3 SMBUS timeout stop in debug
                DBG_I2C3_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. I2C3 SMBUS timeout continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. I2C3 SMBUS timeout is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C1 SMBUS timeout stop in debug
                DBG_I2C1_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. I2C1 SMBUS timeout continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. I2C1 SMBUS timeout is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                reserved30: u7,
                ///  LPTIM2 stop in debug
                DBG_LPTIM2_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. LPTIM2 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. LPTIM2 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM1 stop in debug
                DBG_LPTIM1_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. LPTIM1 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. LPTIM1 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  DBG APB2 freeze register
            DBGMCU_APB2FZR: mmio.Mmio(packed struct(u32) {
                reserved11: u11,
                ///  TIM1 stop in debug
                DBG_TIM1_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM1 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM1 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                reserved15: u3,
                ///  TIM14 stop in debug
                DBG_TIM14_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM14 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM14 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM15 stop in debug
                DBG_TIM15_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM15 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM15 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM16 stop in debug
                DBG_TIM16_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. TIM16 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. TIM16 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM3 stop in debug
                DBG_LPTIM3_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  normal operation. LPTIM3 continues to operate while CPU is in debug mode.
                        B_0x0 = 0x0,
                        ///  stop in debug. LPTIM3 is frozen while CPU is in debug mode.
                        B_0x1 = 0x1,
                    },
                },
                padding: u13,
            }),
            reserved252: [236]u8,
            ///  DBGMCU status register
            DBGMCU_SR: mmio.Mmio(packed struct(u32) {
                ///  Identifies whether access port AP1 is present in device
                AP1_PRESENT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AP1 present
                        B_0x1 = 0x1,
                        _,
                    },
                },
                ///  Identifies whether access port AP0 is present in device
                AP0_PRESENT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AP0 present
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved16: u14,
                ///  Identifies whether access port AP0 is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)
                AP1_ENABLED: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AP1 locked
                        B_0x0 = 0x0,
                        ///  AP1 enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Identifies whether access port AP0 is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)
                AP0_ENABLED: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AP0 locked
                        B_0x0 = 0x0,
                        ///  AP0 enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u14,
            }),
            ///  DBGMCU debug authentication mailbox host register
            DBGMCU_DBG_AUTH_HOST: mmio.Mmio(packed struct(u32) {
                ///  Debug host to device mailbox message. During debug authentication the debug host communicates with the device via this register.
                MESSAGE: u32,
            }),
            ///  DBGMCU debug authentication mailbox device register
            DBGMCU_DBG_AUTH_DEVICE: mmio.Mmio(packed struct(u32) {
                ///  Device to debug host mailbox message. During debug authentication the device communicates with the debug host via this register.
                MESSAGE: u32,
            }),
            reserved4048: [3784]u8,
            ///  DBGMCU CoreSight peripheral identity register 4
            DBGMCU_PIDR4: mmio.Mmio(packed struct(u32) {
                ///  JEP106 continuation code
                JEP106CON: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  STMicroelectronics JEDEC code
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  register file size
                SIZE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The register file occupies a single 4-Kbyte region.
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u24,
            }),
            reserved4064: [12]u8,
            ///  DBGMCU CoreSight peripheral identity register 0
            DBGMCU_PIDR0: mmio.Mmio(packed struct(u32) {
                ///  part number bits [7:0]
                PARTNUM: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  DBGMCU part number
                        B_0x00 = 0x0,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight peripheral identity register 1
            DBGMCU_PIDR1: mmio.Mmio(packed struct(u32) {
                ///  part number bits [11:8]
                PARTNUM: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  DBGMCU part number
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  JEP106 identity code bits [3:0]
                JEP106ID: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  STMicroelectronics JEDEC code
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight peripheral identity register 2
            DBGMCU_PIDR2: mmio.Mmio(packed struct(u32) {
                ///  JEP106 identity code bits [6:4]
                JEP106ID: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  STMicroelectronics JEDEC code
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  JEDEC assigned value
                JEDEC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  designer identification specified by JEDEC
                        B_0x1 = 0x1,
                        _,
                    },
                },
                ///  component revision number
                REVISION: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  r0p0
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight peripheral identity register 3
            DBGMCU_PIDR3: mmio.Mmio(packed struct(u32) {
                ///  customer modified
                CMOD: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  no customer modifications
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  metal fix version
                REVAND: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  no metal fix
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight component identity register 0
            DBGMCU_CIDR0: mmio.Mmio(packed struct(u32) {
                ///  component identification bits [7:0]
                PREAMBLE: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  common identification value
                        B_0x0D = 0xd,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight component identity register 1
            DBGMCU_CIDR1: mmio.Mmio(packed struct(u32) {
                ///  component identification bits [11:8]
                PREAMBLE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  common identification value
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  component identification bits [15:12] - component class
                CLASS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Non-CoreSight component
                        B_0xF = 0xf,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight component identity register 2
            DBGMCU_CIDR2: mmio.Mmio(packed struct(u32) {
                ///  component identification bits [23:16]
                PREAMBLE: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  common identification value
                        B_0x05 = 0x5,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  DBGMCU CoreSight component identity register 3
            DBGMCU_CIDR3: mmio.Mmio(packed struct(u32) {
                ///  component identification bits [31:24]
                PREAMBLE: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  common identification value
                        B_0xB1 = 0xb1,
                        _,
                    },
                },
                padding: u24,
            }),
        };

        ///  DMAMUX address block description
        pub const DMAMUX = extern struct {
            ///  DMAMUX request line multiplexer channel 0 configuration register
            DMAMUX_C0CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 1 configuration register
            DMAMUX_C1CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 2 configuration register
            DMAMUX_C2CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 3 configuration register
            DMAMUX_C3CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 4 configuration register
            DMAMUX_C4CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 5 configuration register
            DMAMUX_C5CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 6 configuration register
            DMAMUX_C6CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 7 configuration register
            DMAMUX_C7CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 8 configuration register
            DMAMUX_C8CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 9 configuration register
            DMAMUX_C9CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 10 configuration register
            DMAMUX_C10CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            ///  DMAMUX request line multiplexer channel 11 configuration register
            DMAMUX_C11CR: mmio.Mmio(packed struct(u32) {
                ///  DMA request identification Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  Synchronization overrun interrupt enable
                SOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt disabled
                        B_0x0 = 0x0,
                        ///  Interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Event generation enable
                EGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Event generation disabled
                        B_0x0 = 0x0,
                        ///  Event generation enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u6,
                ///  Synchronization enable
                SE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Synchronization disabled
                        B_0x0 = 0x0,
                        ///  Synchronization enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization polarity Defines the edge polarity of the selected synchronization input:
                SPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event (no synchronization, no detection).
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests minus 1 to forward Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated. This field must only be written when both SE and EGE bits are low.
                NBREQ: u5,
                ///  Synchronization identification Selects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources).
                SYNC_ID: u5,
                padding: u3,
            }),
            reserved128: [80]u8,
            ///  DMAMUX request line multiplexer interrupt channel status register
            DMAMUX_CSR: mmio.Mmio(packed struct(u32) {
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF0: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF1: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF2: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF3: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF4: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF5: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF6: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF7: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF8: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF9: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF10: u1,
                ///  Synchronization overrun event flag The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ. The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.
                SOF11: u1,
                padding: u20,
            }),
            ///  DMAMUX request line multiplexer interrupt clear flag register
            DMAMUX_CFR: mmio.Mmio(packed struct(u32) {
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF0: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF1: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF2: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF3: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF4: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF5: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF6: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF7: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF8: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF9: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF10: u1,
                ///  Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
                CSOF11: u1,
                padding: u20,
            }),
            reserved256: [120]u8,
            ///  DMAMUX request generator channel 0 configuration register
            DMAMUX_RG0CR: mmio.Mmio(packed struct(u32) {
                ///  Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
                SIG_ID: u5,
                reserved8: u3,
                ///  Trigger overrun interrupt enable
                OIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt on a trigger overrun event occurrence is disabled
                        B_0x0 = 0x0,
                        ///  Interrupt on a trigger overrun event occurrence is enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u7,
                ///  DMA request generator channel x enable
                GE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA request generator channel x disabled
                        B_0x0 = 0x0,
                        ///  DMA request generator channel x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
                GPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event, i.e. no trigger detection nor generation.
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 1 configuration register
            DMAMUX_RG1CR: mmio.Mmio(packed struct(u32) {
                ///  Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
                SIG_ID: u5,
                reserved8: u3,
                ///  Trigger overrun interrupt enable
                OIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt on a trigger overrun event occurrence is disabled
                        B_0x0 = 0x0,
                        ///  Interrupt on a trigger overrun event occurrence is enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u7,
                ///  DMA request generator channel x enable
                GE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA request generator channel x disabled
                        B_0x0 = 0x0,
                        ///  DMA request generator channel x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
                GPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event, i.e. no trigger detection nor generation.
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 2 configuration register
            DMAMUX_RG2CR: mmio.Mmio(packed struct(u32) {
                ///  Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
                SIG_ID: u5,
                reserved8: u3,
                ///  Trigger overrun interrupt enable
                OIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt on a trigger overrun event occurrence is disabled
                        B_0x0 = 0x0,
                        ///  Interrupt on a trigger overrun event occurrence is enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u7,
                ///  DMA request generator channel x enable
                GE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA request generator channel x disabled
                        B_0x0 = 0x0,
                        ///  DMA request generator channel x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
                GPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event, i.e. no trigger detection nor generation.
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 3 configuration register
            DMAMUX_RG3CR: mmio.Mmio(packed struct(u32) {
                ///  Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator
                SIG_ID: u5,
                reserved8: u3,
                ///  Trigger overrun interrupt enable
                OIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt on a trigger overrun event occurrence is disabled
                        B_0x0 = 0x0,
                        ///  Interrupt on a trigger overrun event occurrence is enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u7,
                ///  DMA request generator channel x enable
                GE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA request generator channel x disabled
                        B_0x0 = 0x0,
                        ///  DMA request generator channel x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA request generator trigger polarity Defines the edge polarity of the selected trigger input
                GPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No event, i.e. no trigger detection nor generation.
                        B_0x0 = 0x0,
                        ///  Rising edge
                        B_0x1 = 0x1,
                        ///  Falling edge
                        B_0x2 = 0x2,
                        ///  Rising and falling edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field must be written only when GE bit is disabled.
                GNBREQ: u5,
                padding: u8,
            }),
            reserved320: [48]u8,
            ///  DMAMUX request generator interrupt status register
            DMAMUX_RGSR: mmio.Mmio(packed struct(u32) {
                ///  Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
                OF0: u1,
                ///  Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
                OF1: u1,
                ///  Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
                OF2: u1,
                ///  Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.
                OF3: u1,
                padding: u28,
            }),
            ///  DMAMUX request generator interrupt clear flag register
            DMAMUX_RGCFR: mmio.Mmio(packed struct(u32) {
                ///  Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
                COF0: u1,
                ///  Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
                COF1: u1,
                ///  Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
                COF2: u1,
                ///  Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
                COF3: u1,
                padding: u28,
            }),
        };

        ///  DMA register bank
        pub const DMA1 = extern struct {
            ///  DMA interrupt status register
            DMA_ISR: mmio.Mmio(packed struct(u32) {
                ///  Global interrupt flag for channel 1
                GIF1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 1
                TCIF1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 1
                HTIF1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 1
                TEIF1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Global interrupt flag for channel 2
                GIF2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 2
                TCIF2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 2
                HTIF2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 2
                TEIF2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Global interrupt flag for channel 3
                GIF3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 3
                TCIF3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 3
                HTIF3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 3
                TEIF3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  global interrupt flag for channel 4
                GIF4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 4
                TCIF4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 4
                HTIF4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 4
                TEIF4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  global interrupt flag for channel 5
                GIF5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 5
                TCIF5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 5
                HTIF5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 5
                TEIF5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Global interrupt flag for channel 6
                GIF6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 6
                TCIF6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 6
                HTIF6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 6
                TEIF6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Global interrupt flag for channel 7
                GIF7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE, HT, or TC event
                        B_0x0 = 0x0,
                        ///  A TE, HT, or TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete (TC) flag for channel 7
                TCIF7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TC event
                        B_0x0 = 0x0,
                        ///  A TC event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer (HT) flag for channel 7
                HTIF7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No HT event
                        B_0x0 = 0x0,
                        ///  An HT event occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error (TE) flag for channel 7
                TEIF7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No TE event
                        B_0x0 = 0x0,
                        ///  A TE event occurred.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            ///  DMA interrupt flag clear register
            DMA_IFCR: mmio.Mmio(packed struct(u32) {
                ///  Global interrupt flag clear for channel 1
                CGIF1: u1,
                ///  Transfer complete flag clear for channel 1
                CTCIF1: u1,
                ///  Half transfer flag clear for channel 1
                CHTIF1: u1,
                ///  Transfer error flag clear for channel 1
                CTEIF1: u1,
                ///  Global interrupt flag clear for channel 2
                CGIF2: u1,
                ///  Transfer complete flag clear for channel 2
                CTCIF2: u1,
                ///  Half transfer flag clear for channel 2
                CHTIF2: u1,
                ///  Transfer error flag clear for channel 2
                CTEIF2: u1,
                ///  Global interrupt flag clear for channel 3
                CGIF3: u1,
                ///  Transfer complete flag clear for channel 3
                CTCIF3: u1,
                ///  Half transfer flag clear for channel 3
                CHTIF3: u1,
                ///  Transfer error flag clear for channel 3
                CTEIF3: u1,
                ///  Global interrupt flag clear for channel 4
                CGIF4: u1,
                ///  Transfer complete flag clear for channel 4
                CTCIF4: u1,
                ///  Half transfer flag clear for channel 4
                CHTIF4: u1,
                ///  Transfer error flag clear for channel 4
                CTEIF4: u1,
                ///  Global interrupt flag clear for channel 5
                CGIF5: u1,
                ///  Transfer complete flag clear for channel 5
                CTCIF5: u1,
                ///  Half transfer flag clear for channel 5
                CHTIF5: u1,
                ///  Transfer error flag clear for channel 5
                CTEIF5: u1,
                ///  Global interrupt flag clear for channel 6
                CGIF6: u1,
                ///  Transfer complete flag clear for channel 6
                CTCIF6: u1,
                ///  Half transfer flag clear for channel 6
                CHTIF6: u1,
                ///  Transfer error flag clear for channel 6
                CTEIF6: u1,
                ///  Global interrupt flag clear for channel 7
                CGIF7: u1,
                ///  Transfer complete flag clear for channel 7
                CTCIF7: u1,
                ///  Half transfer flag clear for channel 7
                CHTIF7: u1,
                ///  Transfer error flag clear for channel 7
                CTEIF7: u1,
                padding: u4,
            }),
            ///  DMA channel 1 configuration register
            DMA_CCR1: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 1 number of data to transfer register
            DMA_CNDTR1: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 1 peripheral address register
            DMA_CPAR1: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 1 memory address register
            DMA_CMAR1: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
            reserved28: [4]u8,
            ///  DMA channel 2 configuration register
            DMA_CCR2: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 2 number of data to transfer register
            DMA_CNDTR2: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 2 peripheral address register
            DMA_CPAR2: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 2 memory address register
            DMA_CMAR2: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
            reserved48: [4]u8,
            ///  DMA channel 3 configuration register
            DMA_CCR3: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 3 number of data to transfer register
            DMA_CNDTR3: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 3 peripheral address register
            DMA_CPAR3: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 3 memory address register
            DMA_CMAR3: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
            reserved68: [4]u8,
            ///  DMA channel 4 configuration register
            DMA_CCR4: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 4 number of data to transfer register
            DMA_CNDTR4: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 4 peripheral address register
            DMA_CPAR4: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 4 memory address register
            DMA_CMAR4: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
            reserved88: [4]u8,
            ///  DMA channel 5 configuration register
            DMA_CCR5: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 5 number of data to transfer register
            DMA_CNDTR5: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 5 peripheral address register
            DMA_CPAR5: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 5 memory address register
            DMA_CMAR5: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
            reserved108: [4]u8,
            ///  DMA channel 6 configuration register
            DMA_CCR6: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 6 number of data to transfer register
            DMA_CNDTR6: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 6 peripheral address register
            DMA_CPAR6: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 6 memory address register
            DMA_CMAR6: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
            reserved128: [4]u8,
            ///  DMA channel 7 configuration register
            DMA_CCR7: mmio.Mmio(packed struct(u32) {
                ///  Channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register). Note: This bit is set and cleared by software.
                EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Half transfer interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                HTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer error interrupt enable Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                TEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Read from peripheral
                        B_0x0 = 0x0,
                        ///  Read from memory
                        B_0x1 = 0x1,
                    },
                },
                ///  Circular mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                CIRC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MINC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MSIZE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  8 bits
                        B_0x0 = 0x0,
                        ///  16 bits
                        B_0x1 = 0x1,
                        ///  32 bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Priority level Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                PL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low
                        B_0x0 = 0x0,
                        ///  Medium
                        B_0x1 = 0x1,
                        ///  High
                        B_0x2 = 0x2,
                        ///  Very high
                        B_0x3 = 0x3,
                    },
                },
                ///  Memory-to-memory mode Note: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
                MEM2MEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u17,
            }),
            ///  DMA channel 7 number of data to transfer register
            DMA_CNDTR7: mmio.Mmio(packed struct(u32) {
                ///  Number of data to transfer
                NDT: u16,
                padding: u16,
            }),
            ///  DMA channel 7 peripheral address register
            DMA_CPAR7: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the peripheral data register from/to which the data is read/written. When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0. In peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                PA: u32,
            }),
            ///  DMA channel 7 memory address register
            DMA_CMAR7: mmio.Mmio(packed struct(u32) {
                ///  Peripheral address It contains the base address of the memory from/to which the data is read/written. When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10. In peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0. Note: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
                MA: u32,
            }),
        };

        ///  WWDG address block description
        pub const WWDG = extern struct {
            ///  WWDG control register
            WWDG_CR: mmio.Mmio(packed struct(u32) {
                ///  7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter, decremented every (4096 x 2<sup>WDGTB[2:0]</sup>) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).
                T: u7,
                ///  Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.
                WDGA: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Watchdog disabled
                        B_0x0 = 0x0,
                        ///  Watchdog enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u24,
            }),
            ///  WWDG configuration register
            WWDG_CFR: mmio.Mmio(packed struct(u32) {
                ///  7-bit window value These bits contain the window value to be compared with the down-counter.
                W: u7,
                reserved9: u2,
                ///  Early wake-up interrupt enable Set by software and cleared by hardware after a reset. When set, an interrupt occurs whenever the counter reaches the value 0x40.
                EWI: u1,
                reserved11: u1,
                ///  Timer base The timebase of the prescaler can be modified as follows:
                WDGTB: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  CK counter clock (PCLK div 4096) div 1
                        B_0x0 = 0x0,
                        ///  CK counter clock (PCLK div 4096) div 2
                        B_0x1 = 0x1,
                        ///  CK counter clock (PCLK div 4096) div 4
                        B_0x2 = 0x2,
                        ///  CK counter clock (PCLK div 4096) div 8
                        B_0x3 = 0x3,
                        ///  CK counter clock (PCLK div 4096) div 16
                        B_0x4 = 0x4,
                        ///  CK counter clock (PCLK div 4096) div 32
                        B_0x5 = 0x5,
                        ///  CK counter clock (PCLK div 4096) div 64
                        B_0x6 = 0x6,
                        ///  CK counter clock (PCLK div 4096) div 128
                        B_0x7 = 0x7,
                    },
                },
                padding: u18,
            }),
            ///  WWDG status register
            WWDG_SR: mmio.Mmio(packed struct(u32) {
                ///  Early wake-up interrupt flag This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. Writing 1 has no effect. This bit is also set if the interrupt is not enabled.
                EWIF: u1,
                padding: u31,
            }),
        };

        ///  EXTI register block
        pub const EXTI = extern struct {
            ///  EXTI rising trigger selection register
            EXTI_RTSR1: mmio.Mmio(packed struct(u32) {
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RT21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            ///  EXTI falling trigger selection register 1
            EXTI_FTSR1: mmio.Mmio(packed struct(u32) {
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling trigger event configuration bit of configurable line x (x1=1211to10) Each bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FT21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            ///  EXTI software interrupt event register 1
            EXTI_SWIER1: mmio.Mmio(packed struct(u32) {
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                ///  Software rising edge event trigger on line x (x1=1211to10) Setting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                SWI21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Rising edge event generated on the corresponding line, followed by an interrupt
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            ///  EXTI rising edge pending register 1
            EXTI_RPR1: mmio.Mmio(packed struct(u32) {
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Rising edge event pending for configurable line x (x1=1211to10) Each bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                RPIF21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No rising edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Rising edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            ///  EXTI falling edge pending register 1
            EXTI_FPR1: mmio.Mmio(packed struct(u32) {
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Falling edge event pending for configurable line x (x1=1211to10) Each bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it. Bits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices.
                FPIF21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No falling edge trigger request occurred
                        B_0x0 = 0x0,
                        ///  Falling edge trigger request occurred
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            reserved96: [76]u8,
            ///  EXTI external interrupt selection register 1
            EXTI_EXTICR1: mmio.Mmio(packed struct(u32) {
                ///  EXTI0 GPIO port selection These bits are written by software to select the source input for EXTI0 external interrupt. Others reserved
                EXTI0: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[0] pin
                        B_0x00 = 0x0,
                        ///  PB[0] pin
                        B_0x01 = 0x1,
                        ///  PC[0] pin
                        B_0x02 = 0x2,
                        ///  PD[0] pin
                        B_0x03 = 0x3,
                        ///  PF[0] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI1 GPIO port selection These bits are written by software to select the source input for EXTI1 external interrupt. Others reserved
                EXTI1: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[1] pin
                        B_0x00 = 0x0,
                        ///  PB[1] pin
                        B_0x01 = 0x1,
                        ///  PC[1] pin
                        B_0x02 = 0x2,
                        ///  PD[1] pin
                        B_0x03 = 0x3,
                        ///  PF[1] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI2 GPIO port selection These bits are written by software to select the source input for EXTI2 external interrupt. Others reserved
                EXTI2: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[2] pin
                        B_0x00 = 0x0,
                        ///  PB[2] pin
                        B_0x01 = 0x1,
                        ///  PC[2] pin
                        B_0x02 = 0x2,
                        ///  PD[2] pin
                        B_0x03 = 0x3,
                        ///  PF[2] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI3 GPIO port selection These bits are written by software to select the source input for EXTI3 external interrupt. Others reserved
                EXTI3: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[3] pin
                        B_0x00 = 0x0,
                        ///  PB[3] pin
                        B_0x01 = 0x1,
                        ///  PC[3] pin
                        B_0x02 = 0x2,
                        ///  PD[3] pin
                        B_0x03 = 0x3,
                        ///  PF[3] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
            }),
            ///  EXTI external interrupt selection register 2
            EXTI_EXTICR2: mmio.Mmio(packed struct(u32) {
                ///  EXTI4 GPIO port selection These bits are written by software to select the source input for EXTI4 external interrupt. Others reserved
                EXTI4: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[4] pin
                        B_0x00 = 0x0,
                        ///  PB[4] pin
                        B_0x01 = 0x1,
                        ///  PC[4] pin
                        B_0x02 = 0x2,
                        ///  PD[4] pin
                        B_0x03 = 0x3,
                        ///  PF[4] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI5 GPIO port selection These bits are written by software to select the source input for EXTI5 external interrupt. Others reserved
                EXTI5: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[5] pin
                        B_0x00 = 0x0,
                        ///  PB[5] pin
                        B_0x01 = 0x1,
                        ///  PC[5] pin
                        B_0x02 = 0x2,
                        ///  PD[5] pin
                        B_0x03 = 0x3,
                        ///  PF[5] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI6 GPIO port selection These bits are written by software to select the source input for EXTI6 external interrupt. Others reserved
                EXTI6: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[6] pin
                        B_0x00 = 0x0,
                        ///  PB[6] pin
                        B_0x01 = 0x1,
                        ///  PC[6] pin
                        B_0x02 = 0x2,
                        ///  PD[6] pin
                        B_0x03 = 0x3,
                        ///  PF[6] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI7 GPIO port selection These bits are written by software to select the source input for EXTI7 external interrupt. Others reserved
                EXTI7: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[7] pin
                        B_0x00 = 0x0,
                        ///  PB[7] pin
                        B_0x01 = 0x1,
                        ///  PC[7] pin
                        B_0x02 = 0x2,
                        ///  PD[7] pin
                        B_0x03 = 0x3,
                        ///  PF[7] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
            }),
            ///  EXTI external interrupt selection register 3
            EXTI_EXTICR3: mmio.Mmio(packed struct(u32) {
                ///  EXTI8 GPIO port selection These bits are written by software to select the source input for EXTI8 external interrupt. Others reserved
                EXTI8: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[8] pin
                        B_0x00 = 0x0,
                        ///  PB[8] pin
                        B_0x01 = 0x1,
                        ///  PC[8] pin
                        B_0x02 = 0x2,
                        ///  PD[8] pin
                        B_0x03 = 0x3,
                        ///  PF[8] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI9 GPIO port selection These bits are written by software to select the source input for EXTI9 external interrupt. Others reserved
                EXTI9: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[9] pin
                        B_0x00 = 0x0,
                        ///  PB[9] pin
                        B_0x01 = 0x1,
                        ///  PC[9] pin
                        B_0x02 = 0x2,
                        ///  PD[9] pin
                        B_0x03 = 0x3,
                        ///  PF[9] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI10 GPIO port selection These bits are written by software to select the source input for EXTI10 external interrupt. Others reserved
                EXTI10: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[10] pin
                        B_0x00 = 0x0,
                        ///  PB[10] pin
                        B_0x01 = 0x1,
                        ///  PC[10] pin
                        B_0x02 = 0x2,
                        ///  PD[10] pin
                        B_0x03 = 0x3,
                        ///  PF[10] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI11 GPIO port selection These bits are written by software to select the source input for EXTI11 external interrupt. Others reserved
                EXTI11: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[11] pin
                        B_0x00 = 0x0,
                        ///  PB[11] pin
                        B_0x01 = 0x1,
                        ///  PC[11] pin
                        B_0x02 = 0x2,
                        ///  PD[11] pin
                        B_0x03 = 0x3,
                        ///  PF[11] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
            }),
            ///  EXTI external interrupt selection register 4
            EXTI_EXTICR4: mmio.Mmio(packed struct(u32) {
                ///  EXTI12 GPIO port selection These bits are written by software to select the source input for EXTI12 external interrupt. Others reserved
                EXTI12: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[12] pin
                        B_0x00 = 0x0,
                        ///  PB[12] pin
                        B_0x01 = 0x1,
                        ///  PC[12] pin
                        B_0x02 = 0x2,
                        ///  PD[12] pin
                        B_0x03 = 0x3,
                        ///  PF[12] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI13 GPIO port selection These bits are written by software to select the source input for EXTI13 external interrupt. Others reserved
                EXTI13: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[13] pin
                        B_0x00 = 0x0,
                        ///  PB[13] pin
                        B_0x01 = 0x1,
                        ///  PC[13] pin
                        B_0x02 = 0x2,
                        ///  PD[13] pin
                        B_0x03 = 0x3,
                        ///  PF[13] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI14 GPIO port selection These bits are written by software to select the source input for EXTI14 external interrupt. Others reserved
                EXTI14: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[14] pin
                        B_0x00 = 0x0,
                        ///  PB[14] pin
                        B_0x01 = 0x1,
                        ///  PC[14] pin
                        B_0x02 = 0x2,
                        ///  PD[14] pin
                        B_0x03 = 0x3,
                        ///  PF[14] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
                ///  EXTI15 GPIO port selection These bits are written by software to select the source input for EXTI15 external interrupt. Others reserved
                EXTI15: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  PA[15] pin
                        B_0x00 = 0x0,
                        ///  PB[15] pin
                        B_0x01 = 0x1,
                        ///  PC[15] pin
                        B_0x02 = 0x2,
                        ///  PD[15] pin
                        B_0x03 = 0x3,
                        ///  PF[15] pin
                        B_0x05 = 0x5,
                        _,
                    },
                },
            }),
            reserved128: [16]u8,
            ///  EXTI CPU wake-up with interrupt mask register
            EXTI_IMR1: mmio.Mmio(packed struct(u32) {
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM22: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM23: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM24: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM25: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM26: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM27: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM28: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM29: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM30: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=131 to 0) Setting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                IM31: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt unasked
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  EXTI CPU wake-up with event mask register
            EXTI_EMR1: mmio.Mmio(packed struct(u32) {
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM16: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM17: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM18: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM19: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM20: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM21: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM22: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM23: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM24: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM25: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM26: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM27: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM28: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM29: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM30: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x (x1=1311to10) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices.
                EM31: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
            }),
            reserved144: [8]u8,
            ///  EXTI CPU wake-up with interrupt mask register
            EXTI_IMR2: mmio.Mmio(packed struct(u32) {
                ///  CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                IM32: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt request from Line x is masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt request from Line x is unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                IM33: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt request from Line x is masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt request from Line x is unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                IM34: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt request from Line x is masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt request from Line x is unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                IM35: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt request from Line x is masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt request from Line x is unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                IM36: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt request from Line x is masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt request from Line x is unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with interrupt mask on line x (x1=1371to132) Setting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                IM37: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with interrupt request from Line x is masked
                        B_0x0 = 0x0,
                        ///  wake-up with interrupt request from Line x is unmasked
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            ///  EXTI CPU wake-up with event mask register
            EXTI_EMR2: mmio.Mmio(packed struct(u32) {
                ///  CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                EM32: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                EM33: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                EM34: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                EM35: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                EM36: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU wake-up with event generation mask on line x, (x1=1371to132) Setting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line. Bit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices.
                EM37: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  wake-up with event generation masked
                        B_0x0 = 0x0,
                        ///  wake-up with event generation unmasked
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
        };

        ///  Mamba FLASH register block
        pub const FLASH = extern struct {
            ///  FLASH access control register
            FLASH_ACR: mmio.Mmio(packed struct(u32) {
                ///  Flash memory access latency The value in this bitfield represents the number of CPU wait states when accessing the flash memory. Other: Reserved A new write into the bitfield becomes effective when it returns the same value upon read.
                LATENCY: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Zero wait states
                        B_0x0 = 0x0,
                        ///  One wait state
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved8: u5,
                ///  CPU Prefetch enable
                PRFTEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CPU Prefetch disabled
                        B_0x0 = 0x0,
                        ///  CPU Prefetch enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  CPU Instruction cache enable
                ICEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CPU Instruction cache is disabled
                        B_0x0 = 0x0,
                        ///  CPU Instruction cache is enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u1,
                ///  CPU Instruction cache reset This bit can be written only when the instruction cache is disabled.
                ICRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CPU Instruction cache is not reset
                        B_0x0 = 0x0,
                        ///  CPU Instruction cache is reset
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u4,
                ///  Main flash memory area empty This bit indicates whether the first location of the main flash memory area is erased or has a programmed value. The bit can be set and reset by software.
                EMPTY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Main flash memory area programmed
                        B_0x0 = 0x0,
                        ///  Main flash memory area empty
                        B_0x1 = 0x1,
                    },
                },
                reserved18: u1,
                ///  Debug access software enable Software may use this bit to enable/disable the debugger read access.
                DBG_SWEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Debugger disabled
                        B_0x0 = 0x0,
                        ///  Debugger enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u13,
            }),
            reserved8: [4]u8,
            ///  FLASH key register
            FLASH_KEYR: mmio.Mmio(packed struct(u32) {
                ///  FLASH key The following values must be written consecutively to unlock the FLASH control register (FLASH_CR), thus enabling programming/erasing operations: KEY1: 0x4567 0123 KEY2: 0xCDEF 89AB
                KEY: u32,
            }),
            ///  FLASH option key register
            FLASH_OPTKEYR: mmio.Mmio(packed struct(u32) {
                ///  Option byte key The following values must be written consecutively to unlock the flash memory option registers, enabling option byte programming/erasing operations: KEY1: 0x0819 2A3B KEY2: 0x4C5D 6E7F
                OPTKEY: u32,
            }),
            ///  FLASH status register
            FLASH_SR: mmio.Mmio(packed struct(u32) {
                ///  End of operation Set by hardware when one or more flash memory operation (programming / erase) has been completed successfully. This bit is set only if the end of operation interrupts are enabled (EOPIE=1). Cleared by writing 1.
                EOP: u1,
                ///  Operation error Set by hardware when a flash memory operation (program / erase) completes unsuccessfully. This bit is set only if error interrupts are enabled (ERRIE=1). Cleared by writing 1.
                OPERR: u1,
                reserved3: u1,
                ///  Programming error Set by hardware when a double-word address to be programmed contains a value different from '0xFFFF FFFF' before programming, except if the data to write is '0x0000 0000'. Cleared by writing 1.
                PROGERR: u1,
                ///  Write protection error Set by hardware when an address to be erased/programmed belongs to a write-protected part (by WRP, PCROP or RDP Level 1) of the flash memory. Cleared by writing 1.
                WRPERR: u1,
                ///  Programming alignment error Set by hardware when the data to program cannot be contained in the same double word (64-bit) flash memory in case of standard programming, or if there is a change of page during fast programming. Cleared by writing 1.
                PGAERR: u1,
                ///  Size error Set by hardware when the size of the access is a byte or half-word during a program or a fast program sequence. Only double word programming is allowed (consequently: word access). Cleared by writing 1.
                SIZERR: u1,
                ///  Programming sequence error Set by hardware when a write access to the flash memory is performed by the code while PG or FSTPG have not been set previously. Set also by hardware when PROGERR, SIZERR, PGAERR, WRPERR, MISSERR or FASTERR is set due to a previous programming error. Cleared by writing 1.
                PGSERR: u1,
                ///  Fast programming data miss error In Fast programming mode, 16 double words (128 bytes) must be sent to flash memory successively, and the new data must be sent to the logic control before the current data is fully programmed. MISSERR is set by hardware when the new data is not present in time. Cleared by writing 1.
                MISSERR: u1,
                ///  Fast programming error Set by hardware when a fast programming sequence (activated by FSTPG) is interrupted due to an error (alignment, size, write protection or data miss). The corresponding status bit (PGAERR, SIZERR, WRPERR or MISSERR) is set at the same time. Cleared by writing 1.
                FASTERR: u1,
                reserved14: u4,
                ///  PCROP read error Set by hardware when an address to be read belongs to a read protected area of the flash memory (PCROP protection). An interrupt is generated if RDERRIE is set in FLASH_CR. Cleared by writing 1.
                RDERR: u1,
                ///  Option and Engineering bits loading validity error
                OPTVERR: u1,
                ///  Busy This flag indicates that a flash memory operation requested by FLASH control register (FLASH_CR) is in progress. This bit is set at the beginning of the flash memory operation, and cleared when the operation finishes or when an error occurs.
                BSY1: u1,
                reserved18: u1,
                ///  Programming or erase configuration busy. This flag is set and cleared by hardware. It is set when the first word is sent for program or when setting the STRT bit of FLASH control register (FLASH_CR) for erase. It is cleared when the flash memory program or erase operation completes or ends with an error. When set, launching any other operation through the FLASH control register (FLASH_CR) is impossible, and must be postponed (a programming or erase operation is ongoing). When cleared, the program and erase settings in the FLASH control register (FLASH_CR) can be modified.
                CFGBSY: u1,
                padding: u13,
            }),
            ///  FLASH control register
            FLASH_CR: mmio.Mmio(packed struct(u32) {
                ///  Flash memory programming enable
                PG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Page erase enable
                PER: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Mass erase When set, this bit triggers the mass erase, that is, all user pages.
                MER1: u1,
                ///  Page number selection These bits select the page to erase: ... Note: Values corresponding to addresses outside the main memory are not allowed.
                PNB: packed union {
                    raw: u7,
                    value: enum(u7) {
                        ///  page 0
                        B_0x0 = 0x0,
                        ///  page 1
                        B_0x1 = 0x1,
                        ///  page 15
                        B_0xF = 0xf,
                        _,
                    },
                },
                reserved16: u6,
                ///  Start erase operation This bit triggers an erase operation when set. This bit is possible to set only by software and to clear only by hardware. The hardware clears it when one of BSY1 and BSY2 flags in the FLASH_SR register transits to zero.
                STRT: u1,
                ///  Start of modification of option bytes This bit triggers an options operation when set. This bit is set only by software, and is cleared when the BSY1 bit is cleared in FLASH_SR.
                OPTSTRT: u1,
                ///  Fast programming enable
                FSTPG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u5,
                ///  End-of-operation interrupt enable This bit enables the interrupt generation upon setting the EOP flag in the FLASH_SR register.
                EOPIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Error interrupt enable This bit enables the interrupt generation upon setting the OPERR flag in the FLASH_SR register.
                ERRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  PCROP read error interrupt enable This bit enables the interrupt generation upon setting the RDERR flag in the FLASH_SR register.
                RDERRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Option byte load launch When set, this bit triggers the load of option bytes into option registers. It is automatically cleared upon the completion of the load. The high state of the bit indicates pending option byte load. The bit cannot be cleared by software. It cannot be written as long as OPTLOCK is set.
                OBL_LAUNCH: u1,
                ///  Securable memory area protection enable This bit enables the protection on securable area, provided that a non-null securable memory area size (SEC_SIZE[4:0]) is defined in option bytes. This bit is possible to set only by software and to clear only through a system reset.
                SEC_PROT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable (securable area accessible)
                        B_0x0 = 0x0,
                        ///  Enable (securable area not accessible)
                        B_0x1 = 0x1,
                    },
                },
                reserved30: u1,
                ///  Options Lock This bit is set only. When set, all bits concerning user option in FLASH_CR register and so option page are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit must be cleared before doing the unlock sequence for OPTLOCK bit. In case of an unsuccessful unlock operation, this bit remains set until the next reset.
                OPTLOCK: u1,
                ///  FLASH_CR Lock This bit is set only. When set, the FLASH_CR register is locked. It is cleared by hardware after detecting the unlock sequence. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
                LOCK: u1,
            }),
            ///  FLASH ECC register
            FLASH_ECCR: mmio.Mmio(packed struct(u32) {
                ///  ECC fail double-word address offset In case of ECC error or ECC correction detected, this bitfield contains double-word offset (multiple of 64 bits) to main Flash memory.
                ADDR_ECC: u14,
                reserved20: u6,
                ///  System Flash memory ECC fail This bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory.
                SYSF_ECC: u1,
                reserved24: u3,
                ///  ECC correction interrupt enable
                ECCCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ECCC interrupt disabled
                        B_0x0 = 0x0,
                        ///  ECCC interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved30: u5,
                ///  ECC correction Set by hardware when one ECC error has been detected and corrected. An interrupt is generated if ECCIE is set. Cleared by writing 1.
                ECCC: u1,
                ///  ECC detection Set by hardware when two ECC errors have been detected. When this bit is set, a NMI is generated. Cleared by writing 1.
                ECCD: u1,
            }),
            reserved32: [4]u8,
            ///  FLASH option register
            FLASH_OPTR: mmio.Mmio(packed struct(u32) {
                ///  Read protection level Other: Level 1, memories read protection active
                RDP: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  Level 0, read protection not active
                        B_0xAA = 0xaa,
                        ///  Level 2, chip read protection active
                        B_0xCC = 0xcc,
                        _,
                    },
                },
                ///  BOR reset level
                BORR_LEV: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  BOR rising level 1 with threshold around 2.1 V
                        B_0x0 = 0x0,
                        ///  BOR rising level 2 with threshold around 2.3 V
                        B_0x1 = 0x1,
                        ///  BOR rising level 3 with threshold around 2.6 V
                        B_0x2 = 0x2,
                        ///  BOR rising level 4 with threshold around 2.9 V
                        B_0x3 = 0x3,
                        _,
                    },
                },
                reserved13: u2,
                ///  Reset generated when entering Stop mode
                NRST_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Reset generated when entering the Stop mode
                        B_0x0 = 0x0,
                        ///  No reset generated when entering the Stop mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Reset generated when entering Standby mode
                NRST_STDBY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Reset generated when entering the Standby mode
                        B_0x0 = 0x0,
                        ///  No reset generate when entering the Standby mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Reset generated when entering Shutdown mode
                NRST_SHDW: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Reset generated when entering the Shutdown mode
                        B_0x0 = 0x0,
                        ///  No reset generated when entering the Shutdown mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Independent watchdog selection
                IWDG_SW: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Hardware independent watchdog
                        B_0x0 = 0x0,
                        ///  Software independent watchdog
                        B_0x1 = 0x1,
                    },
                },
                ///  Independent watchdog counter freeze in Stop mode
                IWDG_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Independent watchdog counter is frozen in Stop mode
                        B_0x0 = 0x0,
                        ///  Independent watchdog counter is running in Stop mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Independent watchdog counter freeze in Standby mode
                IWDG_STDBY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Independent watchdog counter is frozen in Standby mode
                        B_0x0 = 0x0,
                        ///  Independent watchdog counter is running in Standby mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Window watchdog selection
                WWDG_SW: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Hardware window watchdog
                        B_0x0 = 0x0,
                        ///  Software window watchdog
                        B_0x1 = 0x1,
                    },
                },
                reserved21: u1,
                ///  Backup domain reset
                BDRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Enable
                        B_0x0 = 0x0,
                        ///  Disable
                        B_0x1 = 0x1,
                    },
                },
                ///  SRAM parity check control enable/disable
                RAM_PARITY_CHECK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Enable
                        B_0x0 = 0x0,
                        ///  Disable
                        B_0x1 = 0x1,
                    },
                },
                ///  Backup SRAM erase prevention
                BKPSRAM_HW_ERASE_DISABLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  BOOT0 signal source selection This option bit defines the source of the BOOT0 signal.
                NBOOT_SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BOOT0 pin (legacy mode)
                        B_0x0 = 0x0,
                        ///  NBOOT0 option bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Boot configuration Together with the BOOT0 pin or option bit NBOOT0 (depending on NBOOT_SEL option bit configuration), this bit selects boot mode from the main flash memory, SRAM or the system memory. Refer to Section12.5: Boot configuration.
                NBOOT1: u1,
                ///  NBOOT0 option bit
                NBOOT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  NBOOT01=10
                        B_0x0 = 0x0,
                        ///  NBOOT01=11
                        B_0x1 = 0x1,
                    },
                },
                ///  NRST pin configuration
                NRST_MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Reset input only: a low level on the NRST pin generates system reset; internal RESET is not propagated to the NRST pin.
                        B_0x1 = 0x1,
                        ///  Standard GPIO: only internal RESET is possible
                        B_0x2 = 0x2,
                        ///  Bidirectional reset: the NRST pin is configured in reset input/output (legacy) mode
                        B_0x3 = 0x3,
                        _,
                    },
                },
                ///  Internal reset holder enable bit
                IRHEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal resets are propagated as simple pulse on NRST pin
                        B_0x0 = 0x0,
                        ///  Internal resets drives NRST pin low until it is seen as low level
                        B_0x1 = 0x1,
                    },
                },
                padding: u2,
            }),
            reserved44: [8]u8,
            ///  FLASH WRP area A address register
            FLASH_WRP1AR: mmio.Mmio(packed struct(u32) {
                ///  WRP area A start offset This bitfield contains the offset of the first page of the WRP area A. Note: The number of effective bits depends on the size of the flash memory in the device.
                WRP1A_STRT: u7,
                reserved16: u9,
                ///  WRP area A end offset This bitfield contains the offset of the last page of the WRP area A. Note: The number of effective bits depends on the size of the flash memory in the device.
                WRP1A_END: u7,
                padding: u9,
            }),
            ///  FLASH WRP area B address register
            FLASH_WRP1BR: mmio.Mmio(packed struct(u32) {
                ///  WRP area B start offset This bitfield contains the offset of the first page of the WRP area B. Note: The number of effective bits depends on the size of the flash memory in the device.
                WRP1B_STRT: u7,
                reserved16: u9,
                ///  WRP area B end offset This bitfield contains the offset of the last page of the WRP area B. Note: The number of effective bits depends on the size of the flash memory in the device.
                WRP1B_END: u7,
                padding: u9,
            }),
            reserved128: [76]u8,
            ///  FLASH security register
            FLASH_SECR: mmio.Mmio(packed struct(u32) {
                ///  Last page of the first hide protection area
                HDP1_PEND: u7,
                reserved16: u9,
                ///  used to force boot from user area If the bit is set in association with RDP level 1, the debug capabilities are disabled, except in the case of a bad OBL (mismatch).
                BOOT_LOCK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Boot based on the pad/option bit configuration
                        B_0x0 = 0x0,
                        ///  Boot forced from main flash memory
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u7,
                ///  Hide protection area enable
                HDP1EN: u8,
            }),
        };

        ///  GPIOA address block description
        pub const GPIOA = extern struct {
            ///  GPIO port mode register
            GPIOA_MODER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port output type register
            GPIOA_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOA_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOA_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  GPIO port input data register
            GPIOA_IDR: mmio.Mmio(packed struct(u32) {
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOA_ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD0: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD1: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD2: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD3: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD4: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD5: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD6: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD7: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD8: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD9: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD10: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD11: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD12: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD13: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD14: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOA_BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  GPIO port configuration lock register
            GPIOA_LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
                LCKK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration lock key not active
                        B_0x0 = 0x0,
                        ///  Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOA_AFRL: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO alternate function high register
            GPIOA_AFRH: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO port bit reset register
            GPIOA_BRR: mmio.Mmio(packed struct(u32) {
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  GPIOB address block description
        pub const GPIOB = extern struct {
            ///  GPIO port mode register
            GPIOB_MODER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port output type register
            GPIOB_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOB_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOB_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  GPIO port input data register
            GPIOB_IDR: mmio.Mmio(packed struct(u32) {
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOB_ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD0: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD1: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD2: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD3: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD4: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD5: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD6: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD7: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD8: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD9: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD10: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD11: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD12: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD13: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD14: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOB_BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  GPIO port configuration lock register
            GPIOB_LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
                LCKK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration lock key not active
                        B_0x0 = 0x0,
                        ///  Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOB_AFRL: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO alternate function high register
            GPIOB_AFRH: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO port bit reset register
            GPIOB_BRR: mmio.Mmio(packed struct(u32) {
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  GPIOC address block description
        pub const GPIOC = extern struct {
            ///  GPIO port mode register
            GPIOC_MODER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port output type register
            GPIOC_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOC_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOC_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  GPIO port input data register
            GPIOC_IDR: mmio.Mmio(packed struct(u32) {
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOC_ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD0: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD1: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD2: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD3: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD4: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD5: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD6: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD7: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD8: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD9: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD10: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD11: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD12: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD13: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD14: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOC_BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  GPIO port configuration lock register
            GPIOC_LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
                LCKK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration lock key not active
                        B_0x0 = 0x0,
                        ///  Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOC_AFRL: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO alternate function high register
            GPIOC_AFRH: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO port bit reset register
            GPIOC_BRR: mmio.Mmio(packed struct(u32) {
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  GPIOD address block description
        pub const GPIOD = extern struct {
            ///  GPIO port mode register
            GPIOD_MODER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port output type register
            GPIOD_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOD_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOD_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  GPIO port input data register
            GPIOD_IDR: mmio.Mmio(packed struct(u32) {
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOD_ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD0: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD1: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD2: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD3: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD4: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD5: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD6: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD7: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD8: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD9: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD10: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD11: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD12: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD13: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD14: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOD_BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  GPIO port configuration lock register
            GPIOD_LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
                LCKK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration lock key not active
                        B_0x0 = 0x0,
                        ///  Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOD_AFRL: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO alternate function high register
            GPIOD_AFRH: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO port bit reset register
            GPIOD_BRR: mmio.Mmio(packed struct(u32) {
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  GPIOE address block description
        pub const GPIOE = extern struct {
            ///  GPIO port mode register
            GPIOE_MODER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port output type register
            GPIOE_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOE_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOE_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  GPIO port input data register
            GPIOE_IDR: mmio.Mmio(packed struct(u32) {
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOE_ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD0: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD1: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD2: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD3: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD4: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD5: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD6: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD7: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD8: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD9: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD10: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD11: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD12: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD13: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD14: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOE_BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  GPIO port configuration lock register
            GPIOE_LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
                LCKK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration lock key not active
                        B_0x0 = 0x0,
                        ///  Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOE_AFRL: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO alternate function high register
            GPIOE_AFRH: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO port bit reset register
            GPIOE_BRR: mmio.Mmio(packed struct(u32) {
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  GPIOF address block description
        pub const GPIOF = extern struct {
            ///  GPIO port mode register
            GPIOF_MODER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O mode.
                MODE15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input mode
                        B_0x0 = 0x0,
                        ///  General purpose output mode
                        B_0x1 = 0x1,
                        ///  Alternate function mode
                        B_0x2 = 0x2,
                        ///  Analog mode (reset state)
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port output type register
            GPIOF_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output type.
                OT15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output push-pull (reset state)
                        B_0x0 = 0x0,
                        ///  Output open-drain
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOF_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..
                OSPEED15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed
                        B_0x0 = 0x0,
                        ///  Medium speed
                        B_0x1 = 0x1,
                        ///  High speed
                        B_0x2 = 0x2,
                        ///  Very high speed
                        B_0x3 = 0x3,
                    },
                },
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOF_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down
                PUPD15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No pull-up, pull-down
                        B_0x0 = 0x0,
                        ///  Pull-up
                        B_0x1 = 0x1,
                        ///  Pull-down
                        B_0x2 = 0x2,
                        _,
                    },
                },
            }),
            ///  GPIO port input data register
            GPIOF_IDR: mmio.Mmio(packed struct(u32) {
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID0: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID1: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID2: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID3: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID4: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID5: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID6: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID7: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID8: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID9: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID10: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID11: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID12: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID13: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID14: u1,
                ///  Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port.
                ID15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOF_ODR: mmio.Mmio(packed struct(u32) {
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD0: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD1: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD2: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD3: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD4: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD5: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD6: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD7: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD8: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD9: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD10: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD11: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD12: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD13: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD14: u1,
                ///  Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F).
                OD15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOF_BSRR: mmio.Mmio(packed struct(u32) {
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BS15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Sets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Resets the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  GPIO port configuration lock register
            GPIOF_LCKR: mmio.Mmio(packed struct(u32) {
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0.
                LCK15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration not locked
                        B_0x0 = 0x0,
                        ///  Port configuration locked
                        B_0x1 = 0x1,
                    },
                },
                ///  Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the lock. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
                LCKK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Port configuration lock key not active
                        B_0x0 = 0x0,
                        ///  Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOF_AFRL: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO alternate function high register
            GPIOF_AFRH: mmio.Mmio(packed struct(u32) {
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
                ///  Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os.
                AFSEL15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  AF0
                        B_0x0 = 0x0,
                        ///  AF1
                        B_0x1 = 0x1,
                        ///  AF2
                        B_0x2 = 0x2,
                        ///  AF3
                        B_0x3 = 0x3,
                        ///  AF4
                        B_0x4 = 0x4,
                        ///  AF5
                        B_0x5 = 0x5,
                        ///  AF6
                        B_0x6 = 0x6,
                        ///  AF7
                        B_0x7 = 0x7,
                        ///  AF8
                        B_0x8 = 0x8,
                        ///  AF9
                        B_0x9 = 0x9,
                        ///  AF10
                        B_0xA = 0xa,
                        ///  AF11
                        B_0xB = 0xb,
                        ///  AF12
                        B_0xC = 0xc,
                        ///  AF13
                        B_0xD = 0xd,
                        ///  AF14
                        B_0xE = 0xe,
                        ///  AF15
                        B_0xF = 0xf,
                    },
                },
            }),
            ///  GPIO port bit reset register
            GPIOF_BRR: mmio.Mmio(packed struct(u32) {
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR6: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR9: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR11: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR12: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR13: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR14: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000.
                BR15: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action on the corresponding ODx bit
                        B_0x0 = 0x0,
                        ///  Reset the corresponding ODx bit
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  IWDG address block description
        pub const IWDG = extern struct {
            ///  IWDG key register
            IWDG_KR: mmio.Mmio(packed struct(u32) {
                ///  Key value (write only, read 0x0000) These bits can be used for several functions, depending upon the value written by the application: - 0xAAAA: reloads the RL[11:0] value into the IWDCNT down-counter (watchdog refresh), and write-protects registers. This value must be written by software at regular intervals, otherwise the watchdog generates a reset when the counter reaches 0. - 0x5555: enables write-accesses to the registers. - 0xCCCC: enables the watchdog (except if the hardware watchdog option is selected) and write-protects registers. - values different from 0x5555: write-protects registers. Note that only IWDG_PR, IWDG_RLR, IWDG_EWCR and IWDG_WINR registers have a write-protection mechanism.
                KEY: u16,
                padding: u16,
            }),
            ///  IWDG prescaler register
            IWDG_PR: mmio.Mmio(packed struct(u32) {
                ///  Prescaler divider These bits are write access protected, see Section126.4.6. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset to be able to change the prescaler divider. Others: divider / 1024 Note: Reading this register returns the prescaler value from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG status register (IWDG_SR) is reset.
                PR: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  divider / 4
                        B_0x0 = 0x0,
                        ///  divider / 8
                        B_0x1 = 0x1,
                        ///  divider / 16
                        B_0x2 = 0x2,
                        ///  divider / 32
                        B_0x3 = 0x3,
                        ///  divider / 64
                        B_0x4 = 0x4,
                        ///  divider / 128
                        B_0x5 = 0x5,
                        ///  divider / 256
                        B_0x6 = 0x6,
                        ///  divider / 512
                        B_0x7 = 0x7,
                        _,
                    },
                },
                padding: u28,
            }),
            ///  IWDG reload register
            IWDG_RLR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog counter reload value These bits are write access protected, see Section126.4.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_KR). The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2. The RVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value. Note: Reading this register returns the reload value from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the RVU bit in the IWDG status register (IWDG_SR) is reset.
                RL: u12,
                padding: u20,
            }),
            ///  IWDG status register
            IWDG_SR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the V<sub>DD</sub> voltage domain (takes up to six periods of the IWDG kernel clock iwdg_ker_ck). The prescaler value can be updated only when PVU bit is reset.
                PVU: u1,
                ///  Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to six periods of the IWDG kernel clock iwdg_ker_ck). The reload value can be updated only when RVU bit is reset.
                RVU: u1,
                ///  Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to one period of presc_ck and two periods of the IWDG kernel clock iwdg_ker_ck). The window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1.
                WVU: u1,
                ///  Watchdog interrupt comparator value update This bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the V<sub>DD</sub> voltage domain (takes up to one period of presc_ck and two periods of the IWDG kernel clock iwdg_ker_ck). The EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset.
                EWU: u1,
                reserved8: u4,
                ///  Watchdog enable status bit Set to 1 by hardware as soon as the IWDG is started. In software mode, it remains to '1' until the IWDG is reset. In hardware mode, this bit is always set to '1'.
                ONF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The IWDG is not activated
                        B_0x0 = 0x0,
                        ///  The IWDG is activated and needs to be refreshed regularly by the application
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u5,
                ///  Watchdog early interrupt flag This bit is set to 1 by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to 1.
                EWIF: u1,
                padding: u17,
            }),
            ///  IWDG window register
            IWDG_WINR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog counter window value These bits are write access protected, see Section126.4.6.They contain the high limit of the window value to be compared with the downcounter. To prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]1+11 and greater than 1. The WVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value. Note: Reading this register returns the reload value from the V<sub>DD</sub> voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG status register (IWDG_SR) is reset.
                WIN: u12,
                padding: u20,
            }),
            ///  IWDG early wake-up interrupt register
            IWDG_EWCR: mmio.Mmio(packed struct(u32) {
                ///  Watchdog counter window value These bits are write access protected (see Section126.4.6). They are written by software to define at which position of the IWDCNT down-counter the early wake-up interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0]1-11. EWIT[11:0] must be bigger than 1. An interrupt is generated only if EWIE = 1. The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value. Note: Reading this register returns the Early wake-up comparator value and the Interrupt enable bit from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the IWDG status register (IWDG_SR) is reset.
                EWIT: u12,
                reserved14: u2,
                ///  Watchdog early interrupt acknowledge The software must write a 1 into this bit in order to acknowledge the early wake-up interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0.
                EWIC: u1,
                ///  Watchdog early interrupt enable Set and reset by software. The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the value of this bit.
                EWIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The early interrupt interface is disabled.
                        B_0x0 = 0x0,
                        ///  The early interrupt interface is enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
        };

        ///  I2C address block description
        pub const I2C1 = extern struct {
            ///  I2C control register 1
            I2C_CR1: mmio.Mmio(packed struct(u32) {
                ///  Peripheral enable Note: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least three APB clock cycles.
                PE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Peripheral disable
                        B_0x0 = 0x0,
                        ///  Peripheral enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TX interrupt enable
                TXIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Transmit (TXIS) interrupt disabled
                        B_0x0 = 0x0,
                        ///  Transmit (TXIS) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  RX interrupt enable
                RXIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receive (RXNE) interrupt disabled
                        B_0x0 = 0x0,
                        ///  Receive (RXNE) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Address match interrupt enable (slave only)
                ADDRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Address match (ADDR) interrupts disabled
                        B_0x0 = 0x0,
                        ///  Address match (ADDR) interrupts enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Not acknowledge received interrupt enable
                NACKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not acknowledge (NACKF) received interrupts disabled
                        B_0x0 = 0x0,
                        ///  Not acknowledge (NACKF) received interrupts enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Stop detection interrupt enable
                STOPIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Stop detection (STOPF) interrupt disabled
                        B_0x0 = 0x0,
                        ///  Stop detection (STOPF) interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Transfer complete interrupt enable Note: Any of these events generate an interrupt: Note: Transfer complete (TC) Note: Transfer complete reload (TCR)
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Transfer complete interrupt disabled
                        B_0x0 = 0x0,
                        ///  Transfer complete interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Error interrupts enable Note: Any of these errors generate an interrupt: Note: Arbitration loss (ARLO) Note: Bus error detection (BERR) Note: Overrun/Underrun (OVR)
                ERRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Error detection interrupts disabled
                        B_0x0 = 0x0,
                        ///  Error detection interrupts enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * t<sub>I2CCLK</sub> <sub>...</sub> Note: If the analog filter is enabled, the digital filter is added to it. This filter can be programmed only when the I2C is disabled (PE = 0).
                DNF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Digital filter disabled
                        B_0x0 = 0x0,
                        ///  Digital filter enabled and filtering capability up to 1 t<sub>I2CCLK</sub>
                        B_0x1 = 0x1,
                        ///  digital filter enabled and filtering capability up to15 t<sub>I2CCLK</sub>
                        B_0xF = 0xf,
                        _,
                    },
                },
                ///  Analog noise filter OFF Note: This bit can be programmed only when the I2C is disabled (PE = 0).
                ANFOFF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Analog noise filter enabled
                        B_0x0 = 0x0,
                        ///  Analog noise filter disabled
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  DMA transmission requests enable
                TXDMAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA mode disabled for transmission
                        B_0x0 = 0x0,
                        ///  DMA mode enabled for transmission
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA reception requests enable
                RXDMAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA mode disabled for reception
                        B_0x0 = 0x0,
                        ///  DMA mode enabled for reception
                        B_0x1 = 0x1,
                    },
                },
                ///  Slave byte control This bit is used to enable hardware byte control in slave mode.
                SBC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Slave byte control disabled
                        B_0x0 = 0x0,
                        ///  Slave byte control enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can be programmed only when the I2C is disabled (PE = 0).
                NOSTRETCH: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Clock stretching enabled
                        B_0x0 = 0x0,
                        ///  Clock stretching disabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from Stop mode enable
                WUPEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Wake-up from Stop mode disable.
                        B_0x0 = 0x0,
                        ///  Wake-up from Stop mode enable.
                        B_0x1 = 0x1,
                    },
                },
                ///  General call enable
                GCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  General call disabled. Address 0b00000000 is NACKed.
                        B_0x0 = 0x0,
                        ///  General call enabled. Address 0b00000000 is ACKed.
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u4,
                ///  Fast-mode Plus 20 mA drive enable
                FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  20 mA I/O drive disabled
                        B_0x0 = 0x0,
                        ///  20 mA I/O drive enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved30: u5,
                ///  Address match flag (ADDR) automatic clear
                ADDRACLR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ADDR flag is set by hardware, cleared by software by setting ADDRCF bit.
                        B_0x0 = 0x0,
                        ///  ADDR flag remains cleared by hardware. This mode can be used in slave mode, to avoid the ADDR clock stretching if the I2C enables only one slave address. This allows a slave data management by DMA only, without any interrupt from peripheral.
                        B_0x1 = 0x1,
                    },
                },
                ///  STOP detection flag (STOPF) automatic clear
                STOPFACLR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  STOPF flag is set by hardware, cleared by software by setting STOPCF bit.
                        B_0x0 = 0x0,
                        ///  STOPF flag remains cleared by hardware. This mode can be used in NOSTRETCH slave mode, to avoid the overrun error if the STOPF flag is not cleared before next data transmission. This allows a slave data management by DMA only, without any interrupt from peripheral.
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  I2C control register 2
            I2C_CR2: mmio.Mmio(packed struct(u32) {
                ///  Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] must be written with the 7-bit slave address to be sent. Bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] must be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
                SADD: u10,
                ///  Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
                RD_WRN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Master requests a write transfer
                        B_0x0 = 0x0,
                        ///  Master requests a read transfer
                        B_0x1 = 0x1,
                    },
                },
                ///  10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
                ADD10: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The master operates in 7-bit addressing mode
                        B_0x0 = 0x0,
                        ///  The master operates in 10-bit addressing mode
                        B_0x1 = 0x1,
                    },
                },
                ///  10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
                HEAD10R: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The master sends the complete 10-bit slave address read sequence: Start + 2 bytes 10-bit address in write direction + Restart + first seven bits of the 10-bit address in read direction.
                        B_0x0 = 0x0,
                        ///  The master only sends the first seven bits of the 10-bit address, followed by Read direction.
                        B_0x1 = 0x1,
                    },
                },
                ///  Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated start condition when RELOAD = 0, after the end of the NBYTES transfer. Otherwise, setting this bit generates a START condition once the bus is free. Note: Writing 0 to this bit has no effect. Note: The START bit can be set even if the bus is BUSY or I2C is in slave mode. Note: This bit has no effect when RELOAD is set.
                START: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Start generation
                        B_0x0 = 0x0,
                        ///  Restart/Start generation:
                        B_0x1 = 0x1,
                    },
                },
                ///  Stop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In master mode: Note: Writing 0 to this bit has no effect.
                STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Stop generation
                        B_0x0 = 0x0,
                        ///  Stop generation after current byte transfer
                        B_0x1 = 0x1,
                    },
                },
                ///  NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0. Note: Writing 0 to this bit has no effect. Note: This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. Note: When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated, whatever the NACK bit value. Note: When hardware PEC checking is enabled (PECBYTE = 1), the PEC acknowledge value does not depend on the NACK value.
                NACK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  an ACK is sent after current received byte.
                        B_0x0 = 0x0,
                        ///  a NACK is sent after current received byte.
                        B_0x1 = 0x1,
                    },
                },
                ///  Number of bytes
                NBYTES: u8,
                ///  NBYTES reload mode This bit is set and cleared by software.
                RELOAD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).
                        B_0x0 = 0x0,
                        ///  The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.
                        B_0x1 = 0x1,
                    },
                },
                ///  Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
                AUTOEND: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.
                        B_0x0 = 0x0,
                        ///  Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.
                        B_0x1 = 0x1,
                    },
                },
                padding: u6,
            }),
            ///  I2C own address 1 register
            I2C_OAR1: mmio.Mmio(packed struct(u32) {
                ///  Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. Bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN = 0.
                OA1: u10,
                ///  Own address 1 10-bit mode Note: This bit can be written only when OA1EN = 0.
                OA1MODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Own address 1 is a 7-bit address.
                        B_0x0 = 0x0,
                        ///  Own address 1 is a 10-bit address.
                        B_0x1 = 0x1,
                    },
                },
                reserved15: u4,
                ///  Own address 1 enable
                OA1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Own address 1 disabled. The received slave address OA1 is NACKed.
                        B_0x0 = 0x0,
                        ///  Own address 1 enabled. The received slave address OA1 is ACKed.
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  I2C own address 2 register
            I2C_OAR2: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN = 0.
                OA2: u7,
                ///  Own address 2 masks Note: These bits can be written only when OA2EN = 0. Note: As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
                OA2MSK: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No mask
                        B_0x0 = 0x0,
                        ///  OA2[1] is masked and dont care. Only OA2[7:2] are compared.
                        B_0x1 = 0x1,
                        ///  OA2[2:1] are masked and dont care. Only OA2[7:3] are compared.
                        B_0x2 = 0x2,
                        ///  OA2[3:1] are masked and dont care. Only OA2[7:4] are compared.
                        B_0x3 = 0x3,
                        ///  OA2[4:1] are masked and dont care. Only OA2[7:5] are compared.
                        B_0x4 = 0x4,
                        ///  OA2[5:1] are masked and dont care. Only OA2[7:6] are compared.
                        B_0x5 = 0x5,
                        ///  OA2[6:1] are masked and dont care. Only OA2[7] is compared.
                        B_0x6 = 0x6,
                        ///  OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.
                        B_0x7 = 0x7,
                    },
                },
                reserved15: u4,
                ///  Own address 2 enable
                OA2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Own address 2 disabled. The received slave address OA2 is NACKed.
                        B_0x0 = 0x0,
                        ///  Own address 2 enabled. The received slave address OA2 is ACKed.
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  I2C timing register
            I2C_TIMINGR: mmio.Mmio(packed struct(u32) {
                ///  SCL low period (master mode) This field is used to generate the SCL low period in master mode. t<sub>SCLL </sub>= (SCLL + 1) x t<sub>PRESC</sub> Note: SCLL is also used to generate t<sub>BUF </sub>and t<sub>SU:STA </sub>timings.
                SCLL: u8,
                ///  SCL high period (master mode) This field is used to generate the SCL high period in master mode. t<sub>SCLH </sub>= (SCLH + 1) x t<sub>PRESC</sub> Note: SCLH is also used to generate t<sub>SU:STO </sub>and t<sub>HD:STA </sub>timing.
                SCLH: u8,
                ///  Data hold time This field is used to generate the delay t<sub>SDADEL </sub>between SCL falling edge and SDA edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SDADEL</sub>. t<sub>SDADEL</sub>= SDADEL x t<sub>PRESC</sub> Note: SDADEL is used to generate t<sub>HD:DAT </sub>timing.
                SDADEL: u4,
                ///  Data setup time This field is used to generate a delay t<sub>SCLDEL </sub>between SDA edge and SCL rising edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SCLDEL</sub>. t<sub>SCLDEL </sub>= (SCLDEL + 1) x t<sub>PRESC</sub> Note: t<sub>SCLDEL</sub> is used to generate t<sub>SU:DAT </sub>timing.
                SCLDEL: u4,
                reserved28: u4,
                ///  Timing prescaler This field is used to prescale I2CCLK to generate the clock period t<sub>PRESC </sub>used for data setup and hold counters (refer to I2C timings) and for SCL high and low level counters (refer to I2C master initialization). t<sub>PRESC </sub>= (PRESC + 1) x t<sub>I2CCLK</sub>
                PRESC: u4,
            }),
            ///  I2C timeout register
            I2C_TIMEOUTR: mmio.Mmio(packed struct(u32) {
                ///  Bus timeout A This field is used to configure: The SCL low timeout condition t<sub>TIMEOUT</sub> when TIDLE = 0 t<sub>TIMEOUT</sub>= (TIMEOUTA + 1) x 2048 x t<sub>I2CCLK</sub> The bus idle condition (both SCL and SDA high) when TIDLE = 1 t<sub>IDLE</sub>= (TIMEOUTA + 1) x 4 x t<sub>I2CCLK</sub> Note: These bits can be written only when TIMOUTEN = 0.
                TIMEOUTA: u12,
                ///  Idle clock timeout detection Note: This bit can be written only when TIMOUTEN = 0.
                TIDLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMEOUTA is used to detect SCL low timeout
                        B_0x0 = 0x0,
                        ///  TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
                        B_0x1 = 0x1,
                    },
                },
                reserved15: u2,
                ///  Clock timeout enable
                TIMOUTEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SCL timeout detection is disabled
                        B_0x0 = 0x0,
                        ///  SCL timeout detection is enabled: when SCL is low for more than t<sub>TIMEOUT</sub> (TIDLE = 0) or high for more than t<sub>IDLE </sub>(TIDLE = 1), a timeout error is detected (TIMEOUT = 1).
                        B_0x1 = 0x1,
                    },
                },
                ///  Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (t<sub>LOW:MEXT</sub>) is detected In slave mode, the slave cumulative clock low extend time (t<sub>LOW:SEXT</sub>) is detected t<sub>LOW:EXT </sub>= (TIMEOUTB + TIDLE = 01) x 2048 x t<sub>I2CCLK</sub> Note: These bits can be written only when TEXTEN = 0.
                TIMEOUTB: u12,
                reserved31: u3,
                ///  Extended clock timeout enable
                TEXTEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Extended clock timeout detection is disabled
                        B_0x0 = 0x0,
                        ///  Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than t<sub>LOW:EXT </sub>is done by the I2C interface, a timeout error is detected (TIMEOUT = 1).
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  I2C interrupt and status register
            I2C_ISR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE = 0.
                TXE: u1,
                ///  Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software only when NOSTRETCH = 1, to generate a TXIS event (interrupt if TXIE = 1 or DMA request if TXDMAEN = 1). Note: This bit is cleared by hardware when PE = 0.
                TXIS: u1,
                ///  Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE = 0.
                RXNE: u1,
                ///  Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE = 0.
                ADDR: u1,
                ///  Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE = 0.
                NACKF: u1,
                ///  Stop detection flag This flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE = 0.
                STOPF: u1,
                ///  Transfer Complete (master mode) This flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE = 0.
                TC: u1,
                ///  Transfer Complete Reload This flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE = 0. Note: This flag is only for master mode, or for slave mode when the SBC bit is set.
                TCR: u1,
                ///  Bus error This flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE = 0.
                BERR: u1,
                ///  Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE = 0.
                ARLO: u1,
                ///  Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE = 0.
                OVR: u1,
                reserved15: u4,
                ///  Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected, and cleared by hardware when a STOP condition is detected, or when PE = 0.
                BUSY: u1,
                ///  Transfer direction (slave mode) This flag is updated when an address match event occurs (ADDR = 1).
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Write transfer, slave enters receiver mode.
                        B_0x0 = 0x0,
                        ///  Read transfer, slave enters transmitter mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Address match code (slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the two MSBs of the address.
                ADDCODE: u7,
                padding: u8,
            }),
            ///  I2C interrupt clear register
            I2C_ICR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
                ADDRCF: u1,
                ///  Not Acknowledge flag clear Writing 1 to this bit clears the NACKF flag in I2C_ISR register.
                NACKCF: u1,
                ///  STOP detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
                STOPCF: u1,
                reserved8: u2,
                ///  Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
                BERRCF: u1,
                ///  Arbitration lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
                ARLOCF: u1,
                ///  Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
                OVRCF: u1,
                padding: u21,
            }),
            ///  I2C PEC register
            I2C_PECR: mmio.Mmio(packed struct(u32) {
                ///  Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE = 0.
                PEC: u8,
                padding: u24,
            }),
            ///  I2C receive data register
            I2C_RXDR: mmio.Mmio(packed struct(u32) {
                ///  8-bit receive data Data byte received from the I<sup>2</sup>C bus
                RXDATA: u8,
                padding: u24,
            }),
            ///  I2C transmit data register
            I2C_TXDR: mmio.Mmio(packed struct(u32) {
                ///  8-bit transmit data Data byte to be transmitted to the I<sup>2</sup>C bus Note: These bits can be written only when TXE = 1.
                TXDATA: u8,
                padding: u24,
            }),
        };

        ///  VREFBUF address block description
        pub const VREFBUF = extern struct {
            ///  VREFBUF control and status register
            VREFBUF_CSR: mmio.Mmio(packed struct(u32) {
                ///  Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
                ENVR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal voltage reference mode disable (external voltage reference mode).
                        B_0x0 = 0x0,
                        ///  Internal voltage reference mode (reference buffer enable or hold mode) enable.
                        B_0x1 = 0x1,
                    },
                },
                ///  High impedance mode This bit controls the analog switch to connect or not the V<sub>REF+</sub> pin. Refer to Table172: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
                HIZ: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>REF+</sub> pin is internally connected to the voltage reference buffer output.
                        B_0x0 = 0x0,
                        ///  V<sub>REF+</sub> pin is high impedance.
                        B_0x1 = 0x1,
                    },
                },
                ///  Voltage reference scale This bit selects the value generated by the voltage reference buffer.
                VRS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Voltage reference set to V<sub>REF_OUT1</sub> (around 2.0481V).
                        B_0x0 = 0x0,
                        ///  Voltage reference set to V<sub>REF_OUT2</sub> (around 2.51V).
                        B_0x1 = 0x1,
                    },
                },
                ///  Voltage reference buffer ready
                VRR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  the voltage reference buffer output is not ready.
                        B_0x0 = 0x0,
                        ///  the voltage reference buffer output reached the requested level.
                        B_0x1 = 0x1,
                    },
                },
                padding: u28,
            }),
            ///  VREFBUF calibration control register
            VREFBUF_CCR: mmio.Mmio(packed struct(u32) {
                ///  None
                TRIM: u6,
                padding: u26,
            }),
        };

        ///  USB address block description
        pub const USB = extern struct {
            ///  USB endpoint/channel 0 register
            USB_CHEP0R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 1 register
            USB_CHEP1R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 2 register
            USB_CHEP2R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 3 register
            USB_CHEP3R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 4 register
            USB_CHEP4R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 5 register
            USB_CHEP5R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 6 register
            USB_CHEP6R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  USB endpoint/channel 7 register
            USB_CHEP7R: mmio.Mmio(packed struct(u32) {
                ///  endpoint/channel address Device mode Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint. Host mode Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.
                EA: u4,
                ///  Status bits, for transmission transfers
                STATTX: u2,
                ///  Data toggle, for transmission transfers If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode). If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.
                DTOGTX: u1,
                ///  Valid USB transaction transmitted Device mode This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written. Host mode Same as VTRX behavior but for USB OUT and SETUP transactions.
                VTTX: u1,
                ///  endpoint/channel kind The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings. DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode. STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.
                EPKIND: u1,
                ///  USB type of transaction These bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one. Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit. The usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode
                UTYPE: u2,
                ///  Setup transaction completed Device mode This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only. Host mode This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.
                SETUP: u1,
                ///  Status bits, for reception transfers Device mode These bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction. Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1. Host mode These bits are the host application controls to start, retry, or abort host transactions driven by the channel. These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states: - DISABLE DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated. - VALID A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction. VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled. - NAK NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE - STALL STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate.
                STATRX: u2,
                ///  Data Toggle, for reception transfers If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode). If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode). If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers. This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.
                DTOGRX: u1,
                ///  USB valid transaction received Device mode This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only 0 can be written, writing 1 has no effect. Host mode This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated. - A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID. - A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate. - A transaction ended with ACK handshake sets this bit If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register. If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register. - A transaction ended with error sets this bit. Errors can be seen via the bits ERR_RX (host mode only). This bit is read/write but only 0 can be written, writing 1 has no effect.
                VTRX: u1,
                ///  Host mode Device address assigned to the endpoint during the enumeration process.
                DEVADDR: u7,
                ///  Host mode This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.
                NAK: u1,
                ///  Low speed endpoint
                LS_EP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full speed endpoint
                        B_0x0 = 0x0,
                        ///  Low speed endpoint
                        B_0x1 = 0x1,
                    },
                },
                ///  Received error for an OUT/SETUP transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_TX: u1,
                ///  Received error for an IN transaction Host mode This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.
                ERR_RX: u1,
                ///  Three errors for an OUT or SETUP transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_TX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                ///  Three errors for an IN transaction Host mode This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit. Coding of the received error:
                THREE_ERR_RX: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Less than 3 errors received.
                        B_0x0 = 0x0,
                        ///  More than 3 errors received, last error is timeout error.
                        B_0x1 = 0x1,
                        ///  More than 3 errors received, last error is data error (CRC error).
                        B_0x2 = 0x2,
                        ///  More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).
                        B_0x3 = 0x3,
                    },
                },
                padding: u1,
            }),
            reserved64: [32]u8,
            ///  USB control register
            USB_CNTR: mmio.Mmio(packed struct(u32) {
                ///  USB Reset Software can set this bit to reset the USB core, exactly as it happens when receiving a RESET signaling on the USB.The USB peripheral, in response to a RESET, resets its internal protocol state machine. Reception and transmission are disabled until the RST_DCON bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RST_DCON interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event. Software sets this bit to drive USB reset state on the bus and initialize the device. USB reset terminates as soon as this bit is cleared by software.
                USBRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0_DEVICE_MODE = 0x0,
                        ///  USB core is under reset
                        B_0x1_DEVICE_MODE = 0x1,
                    },
                },
                ///  Power down This bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB peripheral for any reason. When this bit is set, the USB peripheral is disconnected from the transceivers and it cannot be used.
                PDWN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Exit power down
                        B_0x0 = 0x0,
                        ///  Enter power down mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Suspend state effective This bit is set by hardware as soon as the suspend state entered through the SUSPEN control gets internally effective. In this state USB activity is suspended, USB clock is gated, transceiver is set in low power mode by disabling the differential receiver. Only asynchronous wake-up logic and single ended receiver is kept alive to detect remote wake-up or resume events. Software must poll this bit to confirm it to be set before any STOP mode entry. This bit is cleared by hardware simultaneously to the WAKEUP flag being set.
                SUSPRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Normal operation
                        B_0x0 = 0x0,
                        ///  Suspend state
                        B_0x1 = 0x1,
                    },
                },
                ///  Suspend state enable Software can set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB peripheral for 31ms. Software can also set this bit when the L1REQ interrupt is received with positive acknowledge sent. As soon as the suspend state is propagated internally all device activity is stopped, USB clock is gated, USB transceiver is set into low power mode and the SUSPRDY bit is set by hardware. In the case that device application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the microcontroller to stop mode, as in the case of bus powered device application, it must first wait few cycles to see the SUSPRDY1=11 acknowledge the suspend request. This bit is cleared by hardware simultaneous with the WAKEUP flag set. Software can set this bit when host application has nothing scheduled for the next frames and wants to enter long term power saving. When set, it stops immediately SOF generation and any other host activity, gates the USB clock and sets the transceiver in low power mode. If any USB transaction is on-going at the time SUSPEN is set, suspend is entered at the end of the current transaction. As soon as suspend state is propagated internally and gets effective the SUSPRDY bit is set. In the case that host application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the micro-controller to STOP mode, it must first wait few cycles to see SUSPRDY=1 acknowledge to the suspend request. This bit is cleared by hardware simultaneous with the WAKEUP flag set.
                SUSPEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0_DEVICE_MODE = 0x0,
                        ///  Enter L1/L2 suspend
                        B_0x1_DEVICE_MODE = 0x1,
                    },
                },
                ///  L2 remote wake-up / resume driver Device mode The microcontroller can set this bit to send remote wake-up signaling to the host. It must be activated, according to USB specifications, for no less than 11ms and no more than 151ms after which the host PC is ready to drive the resume sequence up to its end. Host mode Software sets this bit to send resume signaling to the device. Software clears this bit to send end of resume to device and restart SOF generation. In the context of remote wake up, this bit is to be set following the WAKEUP interrupt.
                L2RES: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Send L2 resume signaling to device
                        B_0x1 = 0x1,
                    },
                },
                ///  L1 remote wake-up / resume driver
                L1RES: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  send 50 micro s remote wake up signaling to host
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  LPM L1 state request interrupt mask
                L1REQM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPM L1 state request (L1REQ) interrupt disabled.
                        B_0x0 = 0x0,
                        ///  L1REQ interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Expected start of frame interrupt mask
                ESOFM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Expected start of frame (ESOF) interrupt disabled.
                        B_0x0 = 0x0,
                        ///  ESOF interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Start of frame interrupt mask
                SOFM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SOF interrupt disabled.
                        B_0x0 = 0x0,
                        ///  SOF interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  USB reset request (Device mode) or device connect/disconnect (Host mode) interrupt mask
                RST_DCONM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RESET interrupt disabled.
                        B_0x0 = 0x0,
                        ///  RESET interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Suspend mode interrupt mask
                SUSPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Suspend mode request (SUSP) interrupt disabled.
                        B_0x0 = 0x0,
                        ///  SUSP interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up interrupt mask
                WKUPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  WKUP interrupt disabled.
                        B_0x0 = 0x0,
                        ///  WKUP interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Error interrupt mask
                ERRM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ERR interrupt disabled.
                        B_0x0 = 0x0,
                        ///  ERR interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Packet memory area over / underrun interrupt mask
                PMAOVRM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PMAOVR interrupt disabled.
                        B_0x0 = 0x0,
                        ///  PMAOVR interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Correct transfer interrupt mask
                CTRM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Correct transfer (CTR) interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CTR interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  512 byte threshold interrupt mask
                THR512M: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  512 byte threshold interrupt disabled
                        B_0x0 = 0x0,
                        ///  512 byte threshold interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Device disconnection mask Host mode
                DDISCM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Device disconnection interrupt disabled
                        B_0x0 = 0x0,
                        ///  Device disconnection interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved31: u13,
                ///  HOST mode HOST bit selects betweens host or device USB mode of operation. It must be set before enabling the USB peripheral by the function enable bit.
                HOST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  USB Device function
                        B_0x0 = 0x0,
                        ///  USB host function (Reserved, host function is not available in these products, see Section134.3: USB implementation)
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  USB interrupt status register
            USB_ISTR: mmio.Mmio(packed struct(u32) {
                ///  Device Endpoint / host channel identification number These bits are written by the hardware according to the host channel or device endpoint number, which generated the interrupt request. If several endpoint/channel transactions are pending, the hardware writes the identification number related to the endpoint/channel having the highest priority defined in the following way: two levels are defined, in order of priority: isochronous and double-buffered bulk channels/endpoints are considered first and then the others are examined. If more than one endpoint/channel from the same set is requesting an interrupt, the IDN bits in USB_ISTR register are assigned according to the lowest requesting register, CHEP0R having the highest priority followed by CHEP1R and so on. The application software can assign a register to each endpoint/channel according to this priority scheme, so as to order the concurring endpoint/channel requests in a suitable way. These bits are read only.
                IDN: u4,
                ///  Direction of transaction This bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request. If DIR bit1=10, VTTX bit is set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB peripheral to the host PC). If DIR bit1=11, VTRX bit or both VTTX/VTRX are set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB peripheral from the host PC) or two pending transactions are waiting to be processed. This information can be used by the application software to access the USB_CHEPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only.
                DIR: u1,
                reserved7: u2,
                ///  LPM L1 state request Device mode This bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged. This bit is read/write but only 0 can be written and writing 1 has no effect.
                L1REQ: u1,
                ///  Expected start of frame Device mode This bit is set by the hardware when an SOF packet is expected but not received. The host sends an SOF packet each 11ms, but if the device does not receive it properly, the suspend timer issues this interrupt. If three consecutive ESOF interrupts are generated (for example three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the suspend timer is not yet locked. This bit is read/write but only 0 can be written and writing 1 has no effect.
                ESOF: u1,
                ///  Start of frame This bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 11ms synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this can be useful for isochronous applications). This bit is read/write but only 0 can be written and writing 1 has no effect.
                SOF: u1,
                ///  USB reset request (Device mode) or device connect/disconnect (Host mode) Device mode This bit is set by hardware when an USB reset is released by the host and the bus returns to idle. USB reset state is internally detected after the sampling of 60 consecutive SE0 cycles. Host mode This bit is set by hardware when device connection or device disconnection is detected. Device connection is signaled after J state is sampled for 22 cycles consecutively from unconnected state. Device disconnection is signaled after SE0 state is seen for 22 bit times consecutively from connected state.
                RST_DCON: u1,
                ///  Suspend mode request Device mode This bit is set by the hardware when no traffic has been received for 31ms, indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (SUSPEN=1) until the end of resume sequence. This bit is read/write but only 0 can be written and writing 1 has no effect.
                SUSP: u1,
                ///  Wake-up This bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB peripheral. This event asynchronously clears the SUSPRDY bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (for example wake-up unit) about the start of the resume process. This bit is read/write but only 0 can be written and writing 1 has no effect.
                WKUP: u1,
                ///  Error This flag is set whenever one of the errors listed below has occurred: NANS: No ANSwer. The timeout for a host response has expired. CRC: Cyclic redundancy check error. One of the received CRCs, either in the token or in the data, was wrong. BST: Bit stuffing error. A bit stuffing error was detected anywhere in the PID, data, and/or CRC. FVIO: Framing format violation. A non-standard frame was received (EOP not in the right place, wrong token sequence, etc.). The USB software can usually ignore errors, since the USB peripheral and the PC host manage retransmission in case of errors in a fully transparent way. This interrupt can be useful during the software development phase, or to monitor the quality of transmission over the USB bus, to flag possible problems to the user (for example loose connector, too noisy environment, broken conductor in the USB cable and so on). This bit is read/write but only 0 can be written and writing 1 has no effect.
                ERR: u1,
                ///  Packet memory area over / underrun This bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host retries the transaction. The PMAOVR interrupt must never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during isochronous transfers (no isochronous transaction is anyway retried) leading to a loss of data in this case. This bit is read/write but only 0 can be written and writing 1 has no effect.
                PMAOVR: u1,
                ///  Completed transfer in host mode This bit is set by the hardware to indicate that an endpoint/channel has successfully completed a transaction; using DIR and IDN bits software can determine which endpoint/channel requested the interrupt. This bit is read-only.
                CTR: u1,
                ///  512 byte threshold interrupt This bit is set to 1 by the hardware when 512 bytes have been transmitted or received during isochronous transfers. This bit is read/write but only 0 can be written and writing 1 has no effect. Note that no information is available to indicate the associated channel/endpoint, however in practice only one ISO endpoint/channel with such large packets can be supported, so that channel.
                THR512: u1,
                ///  Device connection Host mode This bit is set when a device connection is detected. This bit is read/write but only 0 can be written and writing 1 has no effect.
                DDISC: u1,
                reserved29: u11,
                ///  Device connection status Host mode: This bit contains information about device connection status. It is set by hardware when a LS/FS device is attached to the host while it is reset when the device is disconnected.
                DCON_STAT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No device connected
                        B_0x0 = 0x0,
                        ///  FS or LS device connected to the host
                        B_0x1 = 0x1,
                    },
                },
                ///  Low speed device connected Host mode: This bit is set by hardware when an LS device connection is detected. Device connection is signaled after LS J-state is sampled for 22 consecutive cycles of the USB clock (481MHz) from the unconnected state.
                LS_DCON: u1,
                padding: u1,
            }),
            ///  USB frame number register
            USB_FNR: mmio.Mmio(packed struct(u32) {
                ///  Frame number This bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for isochronous transfers. This bit field is updated on the generation of an SOF interrupt.
                FN: u11,
                ///  Lost SOF Device mode These bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared.
                LSOF: u2,
                ///  Locked Device mode This bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs.
                LCK: u1,
                ///  Receive data - line status This bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wake-up event.
                RXDM: u1,
                ///  Receive data + line status This bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wake-up event.
                RXDP: u1,
                padding: u16,
            }),
            ///  USB Device address
            USB_DADDR: mmio.Mmio(packed struct(u32) {
                ///  Device address Device mode These bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the endpoint/channel address (EA) field in the associated USB_CHEPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint. Host mode These bits contain the address transmitted with the LPM transaction
                ADD: u7,
                ///  Enable function This bit is set by the software to enable the USB Device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at 0 no transactions are handled, irrespective of the settings of USB_CHEPnR registers.
                EF: u1,
                padding: u24,
            }),
            reserved84: [4]u8,
            ///  LPM control and status register
            USB_LPMCSR: mmio.Mmio(packed struct(u32) {
                ///  LPM support enable Device mode This bit is set by the software to enable the LPM support within the USB Device. If this bit is at 0 no LPM transactions are handled.
                LPMEN: u1,
                ///  LPM token acknowledge enable Device mode: The NYET/ACK is returned only on a successful LPM transaction: No errors in both the EXT token and the LPM token (else ERROR) A valid bLinkState = 0001B (L1) is received (else STALL)
                LPMACK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  the valid LPM token is NYET.
                        B_0x0 = 0x0,
                        ///  the valid LPM token is ACK.
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u1,
                ///  bRemoteWake value Device mode This bit contains the bRemoteWake value received with last ACKed LPM Token
                REMWAKE: u1,
                ///  BESL value Device mode These bits contain the BESL value received with last ACKed LPM Token
                BESL: u4,
                padding: u24,
            }),
            ///  Battery charging detector
            USB_BCDR: mmio.Mmio(packed struct(u32) {
                ///  Battery charging detector (BCD) enable Device mode This bit is set by the software to enable the BCD support within the USB Device. When enabled, the USB PHY is fully controlled by BCD and cannot be used for normal communication. Once the BCD discovery is finished, the BCD must be placed in OFF mode by clearing this bit to 0 in order to allow the normal USB operation.
                BCDEN: u1,
                ///  Data contact detection (DCD) mode enable Device mode This bit is set by the software to put the BCD into DCD mode. Only one detection mode (DCD, PD, SD or OFF) must be selected to work correctly.
                DCDEN: u1,
                ///  Primary detection (PD) mode enable Device mode This bit is set by the software to put the BCD into PD mode. Only one detection mode (DCD, PD, SD or OFF) must be selected to work correctly.
                PDEN: u1,
                ///  Secondary detection (SD) mode enable Device mode This bit is set by the software to put the BCD into SD mode. Only one detection mode (DCD, PD, SD or OFF) must be selected to work correctly.
                SDEN: u1,
                ///  Data contact detection (DCD) status Device mode This bit gives the result of DCD.
                DCDET: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  data lines contact not detected.
                        B_0x0 = 0x0,
                        ///  data lines contact detected.
                        B_0x1 = 0x1,
                    },
                },
                ///  Primary detection (PD) status Device mode This bit gives the result of PD.
                PDET: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no BCD support detected (connected to SDP or proprietary device).
                        B_0x0 = 0x0,
                        ///  BCD support detected (connected to ACA, CDP or DCP).
                        B_0x1 = 0x1,
                    },
                },
                ///  Secondary detection (SD) status Device mode This bit gives the result of SD.
                SDET: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CDP detected.
                        B_0x0 = 0x0,
                        ///  DCP detected.
                        B_0x1 = 0x1,
                    },
                },
                ///  DM pull-up detection status Device mode This bit is active only during PD and gives the result of comparison between DM voltage level and V<sub>LGC</sub> threshold. In normal situation, the DM level must be below this threshold. If it is above, it means that the DM is externally pulled high. This can be caused by connection to a PS2 port (which pulls-up both DP and DM lines) or to some proprietary charger not following the BCD specification.
                PS2DET: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Normal port detected (connected to SDP, ACA, CDP or DCP).
                        B_0x0 = 0x0,
                        ///  PS2 port or proprietary charger detected.
                        B_0x1 = 0x1,
                    },
                },
                reserved15: u7,
                ///  DP pull-up / DPDM pull-down Device mode This bit is set by software to enable the embedded pull-up on DP line. Clearing it to 0 can be used to signal disconnect to the host when needed by the user software. Host mode This bit is set by software to enable the embedded pull-down on DP and DM lines.
                DPPU_DPD: u1,
                padding: u16,
            }),
        };

        ///  LCD address block description
        pub const LCD = extern struct {
            ///  LCD control register
            LCD_CR: mmio.Mmio(packed struct(u32) {
                ///  LCD controller enable This bit is set by software to enable the LCD controller/driver. It is cleared by software to turn off the LCD at the beginning of the next frame. When the LCD is disabled, all COM and SEG pins are driven to V<sub>SS</sub>.
                LCDEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LCD controller disabled
                        B_0x0 = 0x0,
                        ///  LCD controller enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Voltage source selection This bit determines the voltage source for the LCD.
                VSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal source (voltage stepup converter)
                        B_0x0 = 0x0,
                        ///  External source (VLCD pin)
                        B_0x1 = 0x1,
                    },
                },
                ///  Duty selection These bits determine the duty cycle. Values 101, 110 and 111 are forbidden. Others: Reserved
                DUTY: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Static duty
                        B_0x0 = 0x0,
                        ///  1/2 duty
                        B_0x1 = 0x1,
                        ///  1/3 duty
                        B_0x2 = 0x2,
                        ///  1/4 duty
                        B_0x3 = 0x3,
                        ///  1/8 duty
                        B_0x4 = 0x4,
                        _,
                    },
                },
                ///  Bias selector These bits determine the bias used. Value 11 is forbidden.
                BIAS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Bias 1/4
                        B_0x0 = 0x0,
                        ///  Bias 1/2
                        B_0x1 = 0x1,
                        ///  Bias 1/3
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  Mux segment enable This bit is used to enable SEG pin remapping. Four SEG pins can be multiplexed with1SEG[31:28] or SEG[15:12]. See Section118.3.7.
                MUX_SEG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SEG pin multiplexing disabled
                        B_0x0 = 0x0,
                        ///  SEG[31:28] multiplexed with SEG[43:40]
                        B_0x1 = 0x1,
                    },
                },
                ///  Voltage output buffer enable This bit is used to enable/disable the voltage output buffer for higher driving capability.
                BUFEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output buffer disabled
                        B_0x0 = 0x0,
                        ///  Output buffer enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u23,
            }),
            ///  LCD frame control register
            LCD_FCR: mmio.Mmio(packed struct(u32) {
                ///  High drive enable This bit is written by software to enable a low resistance divider. Displays with high internal resistance may need a longer drive time to achieve satisfactory contrast. This bit is useful in this case if some additional power consumption can be tolerated.
                HD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Permanent high drive disabled
                        B_0x0 = 0x0,
                        ///  Permanent high drive enabled. When HD = 1, PON[2:0] must be programmed to 001.
                        B_0x1 = 0x1,
                    },
                },
                ///  Start of frame interrupt enable This bit is set and cleared by software.
                SOFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LCD start-of-frame interrupt disabled
                        B_0x0 = 0x0,
                        ///  LCD start-of-frame interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u1,
                ///  Update display done interrupt enable This bit is set and cleared by software.
                UDDIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LCD update display done interrupt disabled
                        B_0x0 = 0x0,
                        ///  LCD update display done interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Pulse ON duration These bits are written by software to define the pulse duration in terms of ck_ps pulses. A1short pulse leads to lower power consumption, but displays with high internal resistance may need a longer pulse to achieve satisfactory contrast. Note that the pulse is never longer than one half prescaled LCD clock period. PON duration example with LCDCLK = 32.7681kHz and PS=0x03:
                PON: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  0 1s
                        B_0x0 = 0x0,
                        ///  244 1s
                        B_0x1 = 0x1,
                        ///  488 1s
                        B_0x2 = 0x2,
                        ///  782 1s
                        B_0x3 = 0x3,
                        ///  976 1s
                        B_0x4 = 0x4,
                        ///  1.22 ms
                        B_0x5 = 0x5,
                        ///  1.46 ms
                        B_0x6 = 0x6,
                        ///  1.71 ms
                        B_0x7 = 0x7,
                    },
                },
                ///  Dead time duration These bits are written by software to configure the length of the dead time between frames. During the dead time the COM and SEG voltage levels are held at 0 V to reduce the contrast without modifying the frame rate. ......
                DEAD: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No dead time
                        B_0x0 = 0x0,
                        ///  1 phase period dead time
                        B_0x1 = 0x1,
                        ///  2 phase period dead time
                        B_0x2 = 0x2,
                        ///  7 phase period dead time
                        B_0x7 = 0x7,
                        _,
                    },
                },
                ///  Contrast control These bits specify one of the V<sub>LCD </sub>maximum voltages (independent of V<sub>DD</sub>). It ranges from12.60 V to 3.51V. Note: Refer to the datasheet for the V<sub>LCDx</sub> values.
                CC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  V<sub>LCD0</sub>
                        B_0x0 = 0x0,
                        ///  V<sub>LCD1</sub>
                        B_0x1 = 0x1,
                        ///  V<sub>LCD2</sub>
                        B_0x2 = 0x2,
                        ///  V<sub>LCD3</sub>
                        B_0x3 = 0x3,
                        ///  V<sub>LCD4</sub>
                        B_0x4 = 0x4,
                        ///  V<sub>LCD5</sub>
                        B_0x5 = 0x5,
                        ///  V<sub>LCD6</sub>
                        B_0x6 = 0x6,
                        ///  V<sub>LCD7</sub>
                        B_0x7 = 0x7,
                    },
                },
                ///  Blink frequency selection
                BLINKF: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  f<sub>LCD</sub>/8
                        B_0x0 = 0x0,
                        ///  f<sub>LCD</sub>/16
                        B_0x1 = 0x1,
                        ///  f<sub>LCD</sub>/32
                        B_0x2 = 0x2,
                        ///  f<sub>LCD</sub>/64
                        B_0x3 = 0x3,
                        ///  f<sub>LCD</sub>/128
                        B_0x4 = 0x4,
                        ///  f<sub>LCD</sub>/256
                        B_0x5 = 0x5,
                        ///  f<sub>LCD</sub>/512
                        B_0x6 = 0x6,
                        ///  f<sub>LCD</sub>/1024
                        B_0x7 = 0x7,
                    },
                },
                ///  Blink mode selection
                BLINK: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Blink disabled
                        B_0x0 = 0x0,
                        ///  Blink enabled on SEG[0], COM[0] (1 pixel)
                        B_0x1 = 0x1,
                        ///  Blink enabled on SEG[0], all COMs (up to 8 pixels depending on the programmed duty)
                        B_0x2 = 0x2,
                        ///  Blink enabled on all SEGs and all COMs (all pixels)
                        B_0x3 = 0x3,
                    },
                },
                ///  DIV clock divider These bits are written by software to define the division factor of the DIV divider (see1Section118.3.2.) ...
                DIV: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  ck_div = ck_ps/16
                        B_0x0 = 0x0,
                        ///  ck_div = ck_ps/17
                        B_0x1 = 0x1,
                        ///  ck_div = ck_ps/31
                        B_0xF = 0xf,
                        _,
                    },
                },
                ///  PS 16-bit prescaler These bits are written by software to define the division factor of the PS 16-bit prescaler. ck_ps = LCDCLK/(2<sup>PS[3:0]</sup>). See<sub> </sub>Section118.3.2. ...
                PS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  ck_ps = LCDCLK
                        B_0x0 = 0x0,
                        ///  ck_ps = LCDCLK/2
                        B_0x1 = 0x1,
                        ///  ck_ps = LCDCLK/32768
                        B_0xF = 0xf,
                        _,
                    },
                },
                padding: u6,
            }),
            ///  LCD status register
            LCD_SR: mmio.Mmio(packed struct(u32) {
                ///  LCD enabled status This bit is set and cleared by hardware. It indicates the LCD controller status. Note: This bit is set immediately when LCDEN in LCD_CR goes from 0 to 1. On deactivation, it reflects the real LCD status. It becomes 0 at the end of the last displayed frame.
                ENS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LCD controller disabled
                        B_0x0 = 0x0,
                        ///  LCD controller enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Start-of-frame flag This bit is set by hardware at the beginning of a new frame, at the same time as the display data is updated. It is cleared by writing a 1 to SOFC in LCD_CLR. The bit clear has priority over the set.
                SOF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No event
                        B_0x0 = 0x0,
                        ///  Start-of-frame event occurred. An LCD SOF interrupt is generated if SOFIE is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update display request Each time software modifies the LCD_RAM, it must set this bit to transfer the updated data to the second level buffer. This bit stays set until the end of the update. During this time, the LCD_RAM is write protected. When the display is disabled, the update is performed for all LCD_DISPLAY locations. When the display is enabled, the update is performed only for locations for which commons are active (depending on DUTY). For example if DUTY = 1/2, Note: only the LCD_DISPLAY of COM0 and COM1 are updated. Note: Writing 0 on this bit or writing 1 when it is already 1 has no effect. This bit can be cleared by hardware only. It can be cleared only when LCDEN = 1
                UDR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Update display request
                        B_0x1 = 0x1,
                    },
                },
                ///  Update display done This bit is set by hardware. It is cleared by writing 1 to UDDC in LCD_CLR. The bit set has priority over the clear. Note: If the device is in Stop mode (PCLK not provided), UDD does not generate an interrupt even if UDDIE = 1. If the display is not enabled, the UDD interrupt never occurs.
                UDD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No event
                        B_0x0 = 0x0,
                        ///  Update display request done. A UDD interrupt is generated if UDDIE = 1 in LCD_FCR.
                        B_0x1 = 0x1,
                    },
                },
                ///  Ready flag This bit is set and cleared by hardware. It indicates the status of the stepup converter.
                RDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not ready
                        B_0x0 = 0x0,
                        ///  Stepup converter enabled and ready to provide the correct voltage
                        B_0x1 = 0x1,
                    },
                },
                ///  LCD frame control register synchronization flag This bit is set by hardware each time the LCD_FCR register is updated in the LCDCLK domain. It is cleared by hardware when writing to the LCD_FCR register.
                FCRSF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LCD frame control register not yet synchronized
                        B_0x0 = 0x0,
                        ///  LCD frame control register synchronized
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            ///  LCD clear register
            LCD_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Start-of-frame flag clear This bit is written by software to clear SOF in LCD_SR.
                SOFC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear SOF flag.
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u1,
                ///  Update display done clear This bit is written by software to clear UDD in LCD_SR.
                UDDC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear UDD flag.
                        B_0x1 = 0x1,
                    },
                },
                padding: u28,
            }),
            reserved20: [4]u8,
            ///  LCD display memory
            LCD_RAM0: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM1: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u20,
                    value: enum(u20) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u12,
            }),
            ///  LCD display memory
            LCD_RAM2: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM3: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u20,
                    value: enum(u20) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u12,
            }),
            ///  LCD display memory
            LCD_RAM4: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM5: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u20,
                    value: enum(u20) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u12,
            }),
            ///  LCD display memory
            LCD_RAM6: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM7: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u20,
                    value: enum(u20) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u12,
            }),
            ///  LCD display memory
            LCD_RAM8: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM9: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u16,
                    value: enum(u16) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            ///  LCD display memory
            LCD_RAM10: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM11: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u16,
                    value: enum(u16) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            ///  LCD display memory
            LCD_RAM12: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM13: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u16,
                    value: enum(u16) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            ///  LCD display memory
            LCD_RAM14: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u32,
                    value: enum(u32) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
            }),
            ///  LCD display memory
            LCD_RAM15: mmio.Mmio(packed struct(u32) {
                ///  Each bit corresponds to one pixel of the LCD display.
                SEGMENT_DATA: packed union {
                    raw: u16,
                    value: enum(u16) {
                        ///  Pixel inactive
                        B_0x0 = 0x0,
                        ///  Pixel active
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  LPTIM1 address block description
        pub const LPTIM1 = extern struct {
            ///  LPTIM1 interrupt and status register [alternate]
            LPTIM1_ISR_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 interrupt flag If channel CC1 is configured as output: The CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR1 register's value
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
                ARRM: u1,
                ///  External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
                EXTTRIG: u1,
                ///  Compare register 1 update OK CMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register.
                CMP1OK: u1,
                ///  Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
                ARROK: u1,
                ///  Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UP: u1,
                ///  Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWN: u1,
                ///  LPTIM update event occurred UE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA.
                UE: u1,
                ///  Repetition register update OK REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.
                REPOK: u1,
                ///  Compare 2 interrupt flag If channel CC2 is configured as output: The CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR2 register's value
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare 3 interrupt flag If channel CC3 is configured as output: The CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR3 register's value.
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare 4 interrupt flag If channel CC4 is configured as output: The CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR4 register's value
                        B_0x1 = 0x1,
                    },
                },
                reserved19: u7,
                ///  Compare register 2 update OK CMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OK: u1,
                ///  Compare register 3 update OK CMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OK: u1,
                ///  Compare register 4 update OK CMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OK: u1,
                reserved24: u2,
                ///  Interrupt enable register update OK DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.
                DIEROK: u1,
                padding: u7,
            }),
            ///  LPTIM1 interrupt clear register [alternate]
            LPTIM1_ICR_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 clear flag Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.
                CC1CF: u1,
                ///  Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
                ARRMCF: u1,
                ///  External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
                EXTTRIGCF: u1,
                ///  Compare register 1 update OK clear flag Writing 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register.
                CMP1OKCF: u1,
                ///  Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
                ARROKCF: u1,
                ///  Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UPCF: u1,
                ///  Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWNCF: u1,
                ///  Update event clear flag Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
                UECF: u1,
                ///  Repetition register update OK clear flag Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.
                REPOKCF: u1,
                ///  Capture/compare 2 clear flag Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2CF: u1,
                ///  Capture/compare 3 clear flag Writing 1 to this bit clears the CC3IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3CF: u1,
                ///  Capture/compare 4 clear flag Writing 1 to this bit clears the CC4IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4CF: u1,
                reserved19: u7,
                ///  Compare register 2 update OK clear flag Writing 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OKCF: u1,
                ///  Compare register 3 update OK clear flag Writing 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OKCF: u1,
                ///  Compare register 4 update OK clear flag Writing 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OKCF: u1,
                reserved24: u2,
                ///  Interrupt enable register update OK clear flag Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.
                DIEROKCF: u1,
                padding: u7,
            }),
            ///  LPTIM1 interrupt enable register [alternate]
            LPTIM1_DIER_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload match Interrupt Enable
                ARRMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ARRM interrupt disabled
                        B_0x0 = 0x0,
                        ///  ARRM interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger valid edge Interrupt Enable
                EXTTRIGIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  EXTTRIG interrupt disabled
                        B_0x0 = 0x0,
                        ///  EXTTRIG interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 1 update OK interrupt enable
                CMP1OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload register update OK Interrupt Enable
                ARROKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ARROK interrupt disabled
                        B_0x0 = 0x0,
                        ///  ARROK interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UPIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UP interrupt disabled
                        B_0x0 = 0x0,
                        ///  UP interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWNIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DOWN interrupt disabled
                        B_0x0 = 0x0,
                        ///  DOWN interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update event interrupt enable
                UEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update event interrupt disabled
                        B_0x0 = 0x0,
                        ///  Update event interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Repetition register update OK interrupt Enable
                REPOKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Repetition register update OK interrupt disabled
                        B_0x0 = 0x0,
                        ///  Repetition register update OK interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved19: u7,
                ///  Compare register 2 update OK interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 3 update OK interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 4 update OK interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved23: u1,
                ///  Update event DMA request enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
                UEDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UE DMA request disabled. Writing '0' to the UEDE bit resets the associated ue_dma_req signal.
                        B_0x0 = 0x0,
                        ///  UE DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            ///  LPTIM configuration register
            LPTIM1_CFGR: mmio.Mmio(packed struct(u32) {
                ///  Clock selector The CKSEL bit selects which clock source the LPTIM uses:
                CKSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
                        B_0x0 = 0x0,
                        ///  LPTIM is clocked by an external clock source through the LPTIM external Input1
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock Polarity When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active. Refer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes.
                CKPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  the rising edge is the active edge used for counting.
                        B_0x0 = 0x0,
                        ///  the falling edge is the active edge used for counting.
                        B_0x1 = 0x1,
                        ///  both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.
                        B_0x2 = 0x2,
                        ///  not allowed
                        B_0x3 = 0x3,
                    },
                },
                ///  Configurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
                CKFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external clock signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved6: u1,
                ///  Configurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
                TRGFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any trigger active level change is considered as a valid trigger
                        B_0x0 = 0x0,
                        ///  trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
                        B_0x1 = 0x1,
                        ///  trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
                        B_0x2 = 0x2,
                        ///  trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
                        B_0x3 = 0x3,
                    },
                },
                reserved9: u1,
                ///  Clock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
                PRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  /1
                        B_0x0 = 0x0,
                        ///  /2
                        B_0x1 = 0x1,
                        ///  /4
                        B_0x2 = 0x2,
                        ///  /8
                        B_0x3 = 0x3,
                        ///  /16
                        B_0x4 = 0x4,
                        ///  /32
                        B_0x5 = 0x5,
                        ///  /64
                        B_0x6 = 0x6,
                        ///  /128
                        B_0x7 = 0x7,
                    },
                },
                reserved13: u1,
                ///  Trigger selector The TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources: See Section125.4.3: LPTIM input and trigger mapping for details.
                TRIGSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  LPTIM1_ext_trig0
                        B_0x0 = 0x0,
                        ///  LPTIM1_ext_trig1
                        B_0x1 = 0x1,
                        ///  LPTIM1_ext_trig2
                        B_0x2 = 0x2,
                        ///  LPTIM1_ext_trig3
                        B_0x3 = 0x3,
                        ///  LPTIM1_ext_trig4
                        B_0x4 = 0x4,
                        ///  LPTIM1_ext_trig5
                        B_0x5 = 0x5,
                        ///  LPTIM1_ext_trig6
                        B_0x6 = 0x6,
                        ///  LPTIM1_ext_trig7
                        B_0x7 = 0x7,
                    },
                },
                reserved17: u1,
                ///  Trigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
                TRIGEN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  software trigger (counting start is initiated by software)
                        B_0x0 = 0x0,
                        ///  rising edge is the active edge
                        B_0x1 = 0x1,
                        ///  falling edge is the active edge
                        B_0x2 = 0x2,
                        ///  both edges are active edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Timeout enable The TIMOUT bit controls the Timeout feature
                TIMOUT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  A trigger event arriving when the timer is already started is ignored
                        B_0x0 = 0x0,
                        ///  A trigger event arriving when the timer is already started resets and restarts the LPTIM counter and the repetition counter
                        B_0x1 = 0x1,
                    },
                },
                ///  Waveform shape The WAVE bit controls the output shape
                WAVE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Deactivate Set-once mode
                        B_0x0 = 0x0,
                        ///  Activate the Set-once mode
                        B_0x1 = 0x1,
                    },
                },
                reserved22: u1,
                ///  Registers update mode The PRELOAD bit controls the LPTIM1_ARR, LPTIM1_RCR and the LPTIM1_CCRx registers update modality
                PRELOAD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Registers are updated after each APB bus write access
                        B_0x0 = 0x0,
                        ///  Registers are updated at the end of the current LPTIM period
                        B_0x1 = 0x1,
                    },
                },
                ///  counter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:
                COUNTMODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  the counter is incremented following each internal clock pulse
                        B_0x0 = 0x0,
                        ///  the counter is incremented following each valid clock pulse on the LPTIM external Input1
                        B_0x1 = 0x1,
                    },
                },
                ///  Encoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                ENC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Encoder mode disabled
                        B_0x0 = 0x0,
                        ///  Encoder mode enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            ///  LPTIM control register
            LPTIM1_CR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM enable The ENABLE bit is set and cleared by software.
                ENABLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPTIM is disabled. Writing '0' to the ENABLE bit resets all the DMA request signals (input capture and update event DMA requests).
                        B_0x0 = 0x0,
                        ///  LPTIM is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM1_ARR and LPTIM1_CNT registers. This bit can only be set when the LPTIM is enabled. It is automatically reset by hardware.
                SNGSTRT: u1,
                ///  Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM1_ARR and LPTIM1_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.
                CNTSTRT: u1,
                ///  Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM1_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware. COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.
                COUNTRST: u1,
                ///  Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM1_CNT register asynchronously resets LPTIM1_CNT register content. This bit can be set only when the LPTIM is enabled.
                RSTARE: u1,
                padding: u27,
            }),
            ///  LPTIM compare register 1
            LPTIM1_CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the capture/compare 1 register. Depending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 1 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC1 output. If channel CC1 is configured as input: CCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM1_CCR1 register is read-only and cannot be programmed.
                CCR1: u16,
                padding: u16,
            }),
            ///  LPTIM autoreload register
            LPTIM1_ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto reload value ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CCRx[15:0] value.
                ARR: u16,
                padding: u16,
            }),
            ///  LPTIM counter register
            LPTIM1_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value When the LPTIM is running with an asynchronous clock, reading the LPTIM1_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
                CNT: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  LPTIM configuration register 2
            LPTIM1_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  LPTIM input 1 selection The IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IN1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM1_in1_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM1_in1_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM1_in1_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM1_in1_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved4: u2,
                ///  LPTIM input 2 selection The IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IN2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM1_in2_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM1_in2_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM1_in2_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM1_in2_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u10,
                ///  LPTIM input capture 1 selection The IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IC1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM1_ic1_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM1_ic1_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM1_ic1_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM1_ic1_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved20: u2,
                ///  LPTIM input capture 2 selection The IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IC2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM1_ic2_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM1_ic2_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM1_ic2_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM1_ic2_mux3
                        B_0x3 = 0x3,
                    },
                },
                padding: u10,
            }),
            ///  LPTIM repetition register
            LPTIM1_RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition register value REP is the repetition value for the LPTIM.
                REP: u8,
                padding: u24,
            }),
            ///  LPTIM capture/compare mode register 1
            LPTIM1_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 selection This bitfield defines the direction of the channel input (capture) or output mode.
                CC1SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM1_CCR1) or not.
                CC1E: u1,
                ///  Capture/compare 1 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC1 polarity for capture operations.
                CC1P: u2,
                reserved8: u4,
                ///  Input capture 1 prescaler This bitfield defines the ratio of the prescaler acting on the CC1 input (IC1).
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  Input capture 1 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC1F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u2,
                ///  Capture/compare 2 selection This bitfield defines the direction of the channel, input (capture) or output mode.
                CC2SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM1_CCR2) or not.
                CC2E: u1,
                ///  Capture/compare 2 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC2 polarity for capture operations.
                CC2P: u2,
                reserved24: u4,
                ///  Input capture 2 prescaler This bitfield defines the ratio of the prescaler acting on the CC2 input (IC2).
                IC2PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved28: u2,
                ///  Input capture 2 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC2F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  LPTIM capture/compare mode register 2
            LPTIM1_CCMR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 selection This bitfield defines the direction of the channel input (capture) or output mode.
                CC3SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC3 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 output enable. Condition: CC3 as output: Condition: CC3 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM1_CCR3) or not.
                CC3E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture disabled. Writing '0' to the CC3E bit resets the associated ic3_dma_req signal.
                        B_0x0 = 0x0,
                        ///  Capture enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 output polarity. Condition: CC3 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC3 as input: This field is used to select the IC3 polarity for capture operations.
                CC3P: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  rising edge, circuit is sensitive to IC3 rising edge
                        B_0x0 = 0x0,
                        ///  falling edge, circuit is sensitive to IC3 falling edge
                        B_0x1 = 0x1,
                        ///  reserved, do not use this configuration.
                        B_0x2 = 0x2,
                        ///  both edges, circuit is sensitive to both IC3 rising and falling edges.
                        B_0x3 = 0x3,
                    },
                },
                reserved8: u4,
                ///  Input capture 3 prescaler This bitfield defines the ratio of the prescaler acting on the CC3 input (IC3).
                IC3PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  Input capture 3 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC3F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u2,
                ///  Capture/compare 4 selection This bitfield defines the direction of the channel, input (capture) or output mode.
                CC4SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC4 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 output enable. Condition: CC4 as output: Condition: CC4 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM1_CCR4) or not.
                CC4E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture disabled. Writing '0' to the CC4E bit resets the associated ic4_dma_req signal.
                        B_0x0 = 0x0,
                        ///  Capture enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 output polarity. Condition: CC4 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC4 as input: This field is used to select the IC4 polarity for capture operations.
                CC4P: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  rising edge, circuit is sensitive to IC4 rising edge
                        B_0x0 = 0x0,
                        ///  falling edge, circuit is sensitive to IC4 falling edge
                        B_0x1 = 0x1,
                        ///  reserved, do not use this configuration.
                        B_0x2 = 0x2,
                        ///  both edges, circuit is sensitive to both IC4 rising and falling edges.
                        B_0x3 = 0x3,
                    },
                },
                reserved24: u4,
                ///  Input capture 4 prescaler This bitfield defines the ratio of the prescaler acting on the CC4 input (IC4).
                IC4PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved28: u2,
                ///  Input capture 4 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC4F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  LPTIM compare register 2
            LPTIM1_CCR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the capture/compare 2 register. Depending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 2 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC2 output. If channel CC2 is configured as input: CCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM1_CCR2 register is read-only and cannot be programmed.
                CCR2: u16,
                padding: u16,
            }),
            ///  LPTIM compare register 3
            LPTIM1_CCR3: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 value If channel CC3 is configured as output: CCR3 is the value to be loaded in the capture/compare 3 register. Depending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 3 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC3 output. If channel CC3 is configured as input: CCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM1_CCR3 register is read-only and cannot be programmed.
                CCR3: u16,
                padding: u16,
            }),
            ///  LPTIM compare register 4
            LPTIM1_CCR4: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 4 value If channel CC4 is configured as output: CCR4 is the value to be loaded in the capture/compare 4 register. Depending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 4 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC4 output. If channel CC4 is configured as input: CCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM1_CCR4 register is read-only and cannot be programmed.
                CCR4: u16,
                padding: u16,
            }),
        };

        ///  LPTIM2 address block description
        pub const LPTIM2 = extern struct {
            ///  LPTIM2 interrupt and status register [alternate]
            LPTIM2_ISR_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 interrupt flag If channel CC1 is configured as output: The CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR1 register's value
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
                ARRM: u1,
                ///  External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
                EXTTRIG: u1,
                ///  Compare register 1 update OK CMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register.
                CMP1OK: u1,
                ///  Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
                ARROK: u1,
                ///  Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UP: u1,
                ///  Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWN: u1,
                ///  LPTIM update event occurred UE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA.
                UE: u1,
                ///  Repetition register update OK REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.
                REPOK: u1,
                ///  Compare 2 interrupt flag If channel CC2 is configured as output: The CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR2 register's value
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare 3 interrupt flag If channel CC3 is configured as output: The CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR3 register's value.
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare 4 interrupt flag If channel CC4 is configured as output: The CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR4 register's value
                        B_0x1 = 0x1,
                    },
                },
                reserved19: u7,
                ///  Compare register 2 update OK CMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OK: u1,
                ///  Compare register 3 update OK CMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OK: u1,
                ///  Compare register 4 update OK CMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OK: u1,
                reserved24: u2,
                ///  Interrupt enable register update OK DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.
                DIEROK: u1,
                padding: u7,
            }),
            ///  LPTIM2 interrupt clear register [alternate]
            LPTIM2_ICR_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 clear flag Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.
                CC1CF: u1,
                ///  Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
                ARRMCF: u1,
                ///  External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
                EXTTRIGCF: u1,
                ///  Compare register 1 update OK clear flag Writing 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register.
                CMP1OKCF: u1,
                ///  Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
                ARROKCF: u1,
                ///  Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UPCF: u1,
                ///  Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWNCF: u1,
                ///  Update event clear flag Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
                UECF: u1,
                ///  Repetition register update OK clear flag Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.
                REPOKCF: u1,
                ///  Capture/compare 2 clear flag Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2CF: u1,
                ///  Capture/compare 3 clear flag Writing 1 to this bit clears the CC3IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3CF: u1,
                ///  Capture/compare 4 clear flag Writing 1 to this bit clears the CC4IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4CF: u1,
                reserved19: u7,
                ///  Compare register 2 update OK clear flag Writing 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OKCF: u1,
                ///  Compare register 3 update OK clear flag Writing 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OKCF: u1,
                ///  Compare register 4 update OK clear flag Writing 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OKCF: u1,
                reserved24: u2,
                ///  Interrupt enable register update OK clear flag Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.
                DIEROKCF: u1,
                padding: u7,
            }),
            ///  LPTIM2 interrupt enable register [alternate]
            LPTIM2_DIER_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload match Interrupt Enable
                ARRMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ARRM interrupt disabled
                        B_0x0 = 0x0,
                        ///  ARRM interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger valid edge Interrupt Enable
                EXTTRIGIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  EXTTRIG interrupt disabled
                        B_0x0 = 0x0,
                        ///  EXTTRIG interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 1 update OK interrupt enable
                CMP1OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload register update OK Interrupt Enable
                ARROKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ARROK interrupt disabled
                        B_0x0 = 0x0,
                        ///  ARROK interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UPIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UP interrupt disabled
                        B_0x0 = 0x0,
                        ///  UP interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWNIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DOWN interrupt disabled
                        B_0x0 = 0x0,
                        ///  DOWN interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update event interrupt enable
                UEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update event interrupt disabled
                        B_0x0 = 0x0,
                        ///  Update event interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Repetition register update OK interrupt Enable
                REPOKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Repetition register update OK interrupt disabled
                        B_0x0 = 0x0,
                        ///  Repetition register update OK interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved19: u7,
                ///  Compare register 2 update OK interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 3 update OK interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 4 update OK interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved23: u1,
                ///  Update event DMA request enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
                UEDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UE DMA request disabled. Writing '0' to the UEDE bit resets the associated ue_dma_req signal.
                        B_0x0 = 0x0,
                        ///  UE DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            ///  LPTIM configuration register
            LPTIM2_CFGR: mmio.Mmio(packed struct(u32) {
                ///  Clock selector The CKSEL bit selects which clock source the LPTIM uses:
                CKSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
                        B_0x0 = 0x0,
                        ///  LPTIM is clocked by an external clock source through the LPTIM external Input1
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock Polarity When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active. Refer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes.
                CKPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  the rising edge is the active edge used for counting.
                        B_0x0 = 0x0,
                        ///  the falling edge is the active edge used for counting.
                        B_0x1 = 0x1,
                        ///  both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.
                        B_0x2 = 0x2,
                        ///  not allowed
                        B_0x3 = 0x3,
                    },
                },
                ///  Configurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
                CKFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external clock signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved6: u1,
                ///  Configurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
                TRGFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any trigger active level change is considered as a valid trigger
                        B_0x0 = 0x0,
                        ///  trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
                        B_0x1 = 0x1,
                        ///  trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
                        B_0x2 = 0x2,
                        ///  trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
                        B_0x3 = 0x3,
                    },
                },
                reserved9: u1,
                ///  Clock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
                PRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  /1
                        B_0x0 = 0x0,
                        ///  /2
                        B_0x1 = 0x1,
                        ///  /4
                        B_0x2 = 0x2,
                        ///  /8
                        B_0x3 = 0x3,
                        ///  /16
                        B_0x4 = 0x4,
                        ///  /32
                        B_0x5 = 0x5,
                        ///  /64
                        B_0x6 = 0x6,
                        ///  /128
                        B_0x7 = 0x7,
                    },
                },
                reserved13: u1,
                ///  Trigger selector The TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources: See Section125.4.3: LPTIM input and trigger mapping for details.
                TRIGSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  LPTIM2_ext_trig0
                        B_0x0 = 0x0,
                        ///  LPTIM2_ext_trig1
                        B_0x1 = 0x1,
                        ///  LPTIM2_ext_trig2
                        B_0x2 = 0x2,
                        ///  LPTIM2_ext_trig3
                        B_0x3 = 0x3,
                        ///  LPTIM2_ext_trig4
                        B_0x4 = 0x4,
                        ///  LPTIM2_ext_trig5
                        B_0x5 = 0x5,
                        ///  LPTIM2_ext_trig6
                        B_0x6 = 0x6,
                        ///  LPTIM2_ext_trig7
                        B_0x7 = 0x7,
                    },
                },
                reserved17: u1,
                ///  Trigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
                TRIGEN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  software trigger (counting start is initiated by software)
                        B_0x0 = 0x0,
                        ///  rising edge is the active edge
                        B_0x1 = 0x1,
                        ///  falling edge is the active edge
                        B_0x2 = 0x2,
                        ///  both edges are active edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Timeout enable The TIMOUT bit controls the Timeout feature
                TIMOUT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  A trigger event arriving when the timer is already started is ignored
                        B_0x0 = 0x0,
                        ///  A trigger event arriving when the timer is already started resets and restarts the LPTIM counter and the repetition counter
                        B_0x1 = 0x1,
                    },
                },
                ///  Waveform shape The WAVE bit controls the output shape
                WAVE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Deactivate Set-once mode
                        B_0x0 = 0x0,
                        ///  Activate the Set-once mode
                        B_0x1 = 0x1,
                    },
                },
                reserved22: u1,
                ///  Registers update mode The PRELOAD bit controls the LPTIM2_ARR, LPTIM2_RCR and the LPTIM2_CCRx registers update modality
                PRELOAD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Registers are updated after each APB bus write access
                        B_0x0 = 0x0,
                        ///  Registers are updated at the end of the current LPTIM period
                        B_0x1 = 0x1,
                    },
                },
                ///  counter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:
                COUNTMODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  the counter is incremented following each internal clock pulse
                        B_0x0 = 0x0,
                        ///  the counter is incremented following each valid clock pulse on the LPTIM external Input1
                        B_0x1 = 0x1,
                    },
                },
                ///  Encoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                ENC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Encoder mode disabled
                        B_0x0 = 0x0,
                        ///  Encoder mode enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            ///  LPTIM control register
            LPTIM2_CR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM enable The ENABLE bit is set and cleared by software.
                ENABLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPTIM is disabled. Writing '0' to the ENABLE bit resets all the DMA request signals (input capture and update event DMA requests).
                        B_0x0 = 0x0,
                        ///  LPTIM is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM2_ARR and LPTIM2_CNT registers. This bit can only be set when the LPTIM is enabled. It is automatically reset by hardware.
                SNGSTRT: u1,
                ///  Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM2_ARR and LPTIM2_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.
                CNTSTRT: u1,
                ///  Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM2_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware. COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.
                COUNTRST: u1,
                ///  Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM2_CNT register asynchronously resets LPTIM2_CNT register content. This bit can be set only when the LPTIM is enabled.
                RSTARE: u1,
                padding: u27,
            }),
            ///  LPTIM compare register 1
            LPTIM2_CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the capture/compare 1 register. Depending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 1 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC1 output. If channel CC1 is configured as input: CCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM2_CCR1 register is read-only and cannot be programmed.
                CCR1: u16,
                padding: u16,
            }),
            ///  LPTIM autoreload register
            LPTIM2_ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto reload value ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CCRx[15:0] value.
                ARR: u16,
                padding: u16,
            }),
            ///  LPTIM counter register
            LPTIM2_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value When the LPTIM is running with an asynchronous clock, reading the LPTIM2_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
                CNT: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  LPTIM configuration register 2
            LPTIM2_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  LPTIM input 1 selection The IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IN1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM2_in1_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM2_in1_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM2_in1_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM2_in1_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved4: u2,
                ///  LPTIM input 2 selection The IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IN2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM2_in2_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM2_in2_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM2_in2_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM2_in2_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u10,
                ///  LPTIM input capture 1 selection The IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IC1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM2_ic1_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM2_ic1_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM2_ic1_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM2_ic1_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved20: u2,
                ///  LPTIM input capture 2 selection The IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IC2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM2_ic2_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM2_ic2_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM2_ic2_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM2_ic2_mux3
                        B_0x3 = 0x3,
                    },
                },
                padding: u10,
            }),
            ///  LPTIM repetition register
            LPTIM2_RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition register value REP is the repetition value for the LPTIM.
                REP: u8,
                padding: u24,
            }),
            ///  LPTIM capture/compare mode register 1
            LPTIM2_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 selection This bitfield defines the direction of the channel input (capture) or output mode.
                CC1SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM2_CCR1) or not.
                CC1E: u1,
                ///  Capture/compare 1 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC1 polarity for capture operations.
                CC1P: u2,
                reserved8: u4,
                ///  Input capture 1 prescaler This bitfield defines the ratio of the prescaler acting on the CC1 input (IC1).
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  Input capture 1 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC1F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u2,
                ///  Capture/compare 2 selection This bitfield defines the direction of the channel, input (capture) or output mode.
                CC2SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM2_CCR2) or not.
                CC2E: u1,
                ///  Capture/compare 2 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC2 polarity for capture operations.
                CC2P: u2,
                reserved24: u4,
                ///  Input capture 2 prescaler This bitfield defines the ratio of the prescaler acting on the CC2 input (IC2).
                IC2PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved28: u2,
                ///  Input capture 2 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC2F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  LPTIM capture/compare mode register 2
            LPTIM2_CCMR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 selection This bitfield defines the direction of the channel input (capture) or output mode.
                CC3SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC3 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 output enable. Condition: CC3 as output: Condition: CC3 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM2_CCR3) or not.
                CC3E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture disabled. Writing '0' to the CC3E bit resets the associated ic3_dma_req signal.
                        B_0x0 = 0x0,
                        ///  Capture enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 output polarity. Condition: CC3 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC3 as input: This field is used to select the IC3 polarity for capture operations.
                CC3P: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  rising edge, circuit is sensitive to IC3 rising edge
                        B_0x0 = 0x0,
                        ///  falling edge, circuit is sensitive to IC3 falling edge
                        B_0x1 = 0x1,
                        ///  reserved, do not use this configuration.
                        B_0x2 = 0x2,
                        ///  both edges, circuit is sensitive to both IC3 rising and falling edges.
                        B_0x3 = 0x3,
                    },
                },
                reserved8: u4,
                ///  Input capture 3 prescaler This bitfield defines the ratio of the prescaler acting on the CC3 input (IC3).
                IC3PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  Input capture 3 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC3F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u2,
                ///  Capture/compare 4 selection This bitfield defines the direction of the channel, input (capture) or output mode.
                CC4SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC4 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 output enable. Condition: CC4 as output: Condition: CC4 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM2_CCR4) or not.
                CC4E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture disabled. Writing '0' to the CC4E bit resets the associated ic4_dma_req signal.
                        B_0x0 = 0x0,
                        ///  Capture enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 output polarity. Condition: CC4 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC4 as input: This field is used to select the IC4 polarity for capture operations.
                CC4P: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  rising edge, circuit is sensitive to IC4 rising edge
                        B_0x0 = 0x0,
                        ///  falling edge, circuit is sensitive to IC4 falling edge
                        B_0x1 = 0x1,
                        ///  reserved, do not use this configuration.
                        B_0x2 = 0x2,
                        ///  both edges, circuit is sensitive to both IC4 rising and falling edges.
                        B_0x3 = 0x3,
                    },
                },
                reserved24: u4,
                ///  Input capture 4 prescaler This bitfield defines the ratio of the prescaler acting on the CC4 input (IC4).
                IC4PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved28: u2,
                ///  Input capture 4 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC4F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  LPTIM compare register 2
            LPTIM2_CCR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the capture/compare 2 register. Depending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 2 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC2 output. If channel CC2 is configured as input: CCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM2_CCR2 register is read-only and cannot be programmed.
                CCR2: u16,
                padding: u16,
            }),
            ///  LPTIM compare register 3
            LPTIM2_CCR3: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 value If channel CC3 is configured as output: CCR3 is the value to be loaded in the capture/compare 3 register. Depending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 3 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC3 output. If channel CC3 is configured as input: CCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM2_CCR3 register is read-only and cannot be programmed.
                CCR3: u16,
                padding: u16,
            }),
            ///  LPTIM compare register 4
            LPTIM2_CCR4: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 4 value If channel CC4 is configured as output: CCR4 is the value to be loaded in the capture/compare 4 register. Depending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 4 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC4 output. If channel CC4 is configured as input: CCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM2_CCR4 register is read-only and cannot be programmed.
                CCR4: u16,
                padding: u16,
            }),
        };

        ///  LPTIM3 address block description
        pub const LPTIM3 = extern struct {
            ///  LPTIM3 interrupt and status register [alternate]
            LPTIM3_ISR_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Compare 1 interrupt flag If channel CC1 is configured as output: The CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR1 register's value
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
                ARRM: u1,
                ///  External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
                EXTTRIG: u1,
                ///  Compare register 1 update OK CMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register.
                CMP1OK: u1,
                ///  Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
                ARROK: u1,
                ///  Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UP: u1,
                ///  Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWN: u1,
                ///  LPTIM update event occurred UE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA.
                UE: u1,
                ///  Repetition register update OK REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.
                REPOK: u1,
                ///  Compare 2 interrupt flag If channel CC2 is configured as output: The CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR2 register's value
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare 3 interrupt flag If channel CC3 is configured as output: The CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR3 register's value.
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare 4 interrupt flag If channel CC4 is configured as output: The CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No match
                        B_0x0 = 0x0,
                        ///  The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR4 register's value
                        B_0x1 = 0x1,
                    },
                },
                reserved19: u7,
                ///  Compare register 2 update OK CMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OK: u1,
                ///  Compare register 3 update OK CMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OK: u1,
                ///  Compare register 4 update OK CMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OK: u1,
                reserved24: u2,
                ///  Interrupt enable register update OK DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.
                DIEROK: u1,
                padding: u7,
            }),
            ///  LPTIM3 interrupt clear register [alternate]
            LPTIM3_ICR_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 clear flag Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.
                CC1CF: u1,
                ///  Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
                ARRMCF: u1,
                ///  External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
                EXTTRIGCF: u1,
                ///  Compare register 1 update OK clear flag Writing 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register.
                CMP1OKCF: u1,
                ///  Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
                ARROKCF: u1,
                ///  Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UPCF: u1,
                ///  Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWNCF: u1,
                ///  Update event clear flag Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
                UECF: u1,
                ///  Repetition register update OK clear flag Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.
                REPOKCF: u1,
                ///  Capture/compare 2 clear flag Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2CF: u1,
                ///  Capture/compare 3 clear flag Writing 1 to this bit clears the CC3IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3CF: u1,
                ///  Capture/compare 4 clear flag Writing 1 to this bit clears the CC4IF flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4CF: u1,
                reserved19: u7,
                ///  Compare register 2 update OK clear flag Writing 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OKCF: u1,
                ///  Compare register 3 update OK clear flag Writing 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OKCF: u1,
                ///  Compare register 4 update OK clear flag Writing 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register. Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OKCF: u1,
                reserved24: u2,
                ///  Interrupt enable register update OK clear flag Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.
                DIEROKCF: u1,
                padding: u7,
            }),
            ///  LPTIM3 interrupt enable register [alternate]
            LPTIM3_DIER_OUTPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload match Interrupt Enable
                ARRMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ARRM interrupt disabled
                        B_0x0 = 0x0,
                        ///  ARRM interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger valid edge Interrupt Enable
                EXTTRIGIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  EXTTRIG interrupt disabled
                        B_0x0 = 0x0,
                        ///  EXTTRIG interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 1 update OK interrupt enable
                CMP1OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Autoreload register update OK Interrupt Enable
                ARROKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ARROK interrupt disabled
                        B_0x0 = 0x0,
                        ///  ARROK interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                UPIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UP interrupt disabled
                        B_0x0 = 0x0,
                        ///  UP interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                DOWNIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DOWN interrupt disabled
                        B_0x0 = 0x0,
                        ///  DOWN interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update event interrupt enable
                UEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update event interrupt disabled
                        B_0x0 = 0x0,
                        ///  Update event interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Repetition register update OK interrupt Enable
                REPOKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Repetition register update OK interrupt disabled
                        B_0x0 = 0x0,
                        ///  Repetition register update OK interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CC3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CC4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture/compare 4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  Capture/compare 4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved19: u7,
                ///  Compare register 2 update OK interrupt enable Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3.
                CMP2OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 3 update OK interrupt enable Note: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3.
                CMP3OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Compare register 4 update OK interrupt enable Note: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3.
                CMP4OKIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CMPOK register 4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CMPOK register 4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved23: u1,
                ///  Update event DMA request enable Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3.
                UEDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UE DMA request disabled. Writing '0' to the UEDE bit resets the associated ue_dma_req signal.
                        B_0x0 = 0x0,
                        ///  UE DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            ///  LPTIM configuration register
            LPTIM3_CFGR: mmio.Mmio(packed struct(u32) {
                ///  Clock selector The CKSEL bit selects which clock source the LPTIM uses:
                CKSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
                        B_0x0 = 0x0,
                        ///  LPTIM is clocked by an external clock source through the LPTIM external Input1
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock Polarity When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active. Refer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes.
                CKPOL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  the rising edge is the active edge used for counting.
                        B_0x0 = 0x0,
                        ///  the falling edge is the active edge used for counting.
                        B_0x1 = 0x1,
                        ///  both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.
                        B_0x2 = 0x2,
                        ///  not allowed
                        B_0x3 = 0x3,
                    },
                },
                ///  Configurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
                CKFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external clock signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved6: u1,
                ///  Configurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
                TRGFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any trigger active level change is considered as a valid trigger
                        B_0x0 = 0x0,
                        ///  trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
                        B_0x1 = 0x1,
                        ///  trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
                        B_0x2 = 0x2,
                        ///  trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
                        B_0x3 = 0x3,
                    },
                },
                reserved9: u1,
                ///  Clock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
                PRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  /1
                        B_0x0 = 0x0,
                        ///  /2
                        B_0x1 = 0x1,
                        ///  /4
                        B_0x2 = 0x2,
                        ///  /8
                        B_0x3 = 0x3,
                        ///  /16
                        B_0x4 = 0x4,
                        ///  /32
                        B_0x5 = 0x5,
                        ///  /64
                        B_0x6 = 0x6,
                        ///  /128
                        B_0x7 = 0x7,
                    },
                },
                reserved13: u1,
                ///  Trigger selector The TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources: See Section125.4.3: LPTIM input and trigger mapping for details.
                TRIGSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  LPTIM3_ext_trig0
                        B_0x0 = 0x0,
                        ///  LPTIM3_ext_trig1
                        B_0x1 = 0x1,
                        ///  LPTIM3_ext_trig2
                        B_0x2 = 0x2,
                        ///  LPTIM3_ext_trig3
                        B_0x3 = 0x3,
                        ///  LPTIM3_ext_trig4
                        B_0x4 = 0x4,
                        ///  LPTIM3_ext_trig5
                        B_0x5 = 0x5,
                        ///  LPTIM3_ext_trig6
                        B_0x6 = 0x6,
                        ///  LPTIM3_ext_trig7
                        B_0x7 = 0x7,
                    },
                },
                reserved17: u1,
                ///  Trigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
                TRIGEN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  software trigger (counting start is initiated by software)
                        B_0x0 = 0x0,
                        ///  rising edge is the active edge
                        B_0x1 = 0x1,
                        ///  falling edge is the active edge
                        B_0x2 = 0x2,
                        ///  both edges are active edges
                        B_0x3 = 0x3,
                    },
                },
                ///  Timeout enable The TIMOUT bit controls the Timeout feature
                TIMOUT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  A trigger event arriving when the timer is already started is ignored
                        B_0x0 = 0x0,
                        ///  A trigger event arriving when the timer is already started resets and restarts the LPTIM counter and the repetition counter
                        B_0x1 = 0x1,
                    },
                },
                ///  Waveform shape The WAVE bit controls the output shape
                WAVE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Deactivate Set-once mode
                        B_0x0 = 0x0,
                        ///  Activate the Set-once mode
                        B_0x1 = 0x1,
                    },
                },
                reserved22: u1,
                ///  Registers update mode The PRELOAD bit controls the LPTIM3_ARR, LPTIM3_RCR and the LPTIM3_CCRx registers update modality
                PRELOAD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Registers are updated after each APB bus write access
                        B_0x0 = 0x0,
                        ///  Registers are updated at the end of the current LPTIM period
                        B_0x1 = 0x1,
                    },
                },
                ///  counter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:
                COUNTMODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  the counter is incremented following each internal clock pulse
                        B_0x0 = 0x0,
                        ///  the counter is incremented following each valid clock pulse on the LPTIM external Input1
                        B_0x1 = 0x1,
                    },
                },
                ///  Encoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3.
                ENC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Encoder mode disabled
                        B_0x0 = 0x0,
                        ///  Encoder mode enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            ///  LPTIM control register
            LPTIM3_CR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM enable The ENABLE bit is set and cleared by software.
                ENABLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPTIM is disabled. Writing '0' to the ENABLE bit resets all the DMA request signals (input capture and update event DMA requests).
                        B_0x0 = 0x0,
                        ///  LPTIM is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM3_ARR and LPTIM3_CNT registers. This bit can only be set when the LPTIM is enabled. It is automatically reset by hardware.
                SNGSTRT: u1,
                ///  Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM3_ARR and LPTIM3_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.
                CNTSTRT: u1,
                ///  Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM3_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware. COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.
                COUNTRST: u1,
                ///  Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM3_CNT register asynchronously resets LPTIM3_CNT register content. This bit can be set only when the LPTIM is enabled.
                RSTARE: u1,
                padding: u27,
            }),
            ///  LPTIM compare register 1
            LPTIM3_CCR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the capture/compare 1 register. Depending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 1 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC1 output. If channel CC1 is configured as input: CCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM3_CCR1 register is read-only and cannot be programmed.
                CCR1: u16,
                padding: u16,
            }),
            ///  LPTIM autoreload register
            LPTIM3_ARR: mmio.Mmio(packed struct(u32) {
                ///  Auto reload value ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CCRx[15:0] value.
                ARR: u16,
                padding: u16,
            }),
            ///  LPTIM counter register
            LPTIM3_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value When the LPTIM is running with an asynchronous clock, reading the LPTIM3_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
                CNT: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  LPTIM configuration register 2
            LPTIM3_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  LPTIM input 1 selection The IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IN1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM3_in1_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM3_in1_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM3_in1_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM3_in1_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved4: u2,
                ///  LPTIM input 2 selection The IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IN2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM3_in2_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM3_in2_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM3_in2_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM3_in2_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u10,
                ///  LPTIM input capture 1 selection The IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture 1 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IC1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM3_ic1_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM3_ic1_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM3_ic1_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM3_ic1_mux3
                        B_0x3 = 0x3,
                    },
                },
                reserved20: u2,
                ///  LPTIM input capture 2 selection The IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture 2 to one of the available inputs. For connection details refer to Section125.4.3: LPTIM input and trigger mapping.
                IC2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LPTIM3_ic2_mux0
                        B_0x0 = 0x0,
                        ///  LPTIM3_ic2_mux1
                        B_0x1 = 0x1,
                        ///  LPTIM3_ic2_mux2
                        B_0x2 = 0x2,
                        ///  LPTIM3_ic2_mux3
                        B_0x3 = 0x3,
                    },
                },
                padding: u10,
            }),
            ///  LPTIM repetition register
            LPTIM3_RCR: mmio.Mmio(packed struct(u32) {
                ///  Repetition register value REP is the repetition value for the LPTIM.
                REP: u8,
                padding: u24,
            }),
            ///  LPTIM capture/compare mode register 1
            LPTIM3_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 1 selection This bitfield defines the direction of the channel input (capture) or output mode.
                CC1SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM3_CCR1) or not.
                CC1E: u1,
                ///  Capture/compare 1 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC1 polarity for capture operations.
                CC1P: u2,
                reserved8: u4,
                ///  Input capture 1 prescaler This bitfield defines the ratio of the prescaler acting on the CC1 input (IC1).
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  Input capture 1 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC1F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u2,
                ///  Capture/compare 2 selection This bitfield defines the direction of the channel, input (capture) or output mode.
                CC2SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 output enable. This bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM3_CCR2) or not.
                CC2E: u1,
                ///  Capture/compare 2 output polarity. Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. This field is used to select the IC2 polarity for capture operations.
                CC2P: u2,
                reserved24: u4,
                ///  Input capture 2 prescaler This bitfield defines the ratio of the prescaler acting on the CC2 input (IC2).
                IC2PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved28: u2,
                ///  Input capture 2 filter This bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC2F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  LPTIM capture/compare mode register 2
            LPTIM3_CCMR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 selection This bitfield defines the direction of the channel input (capture) or output mode.
                CC3SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC3 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 output enable. Condition: CC3 as output: Condition: CC3 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM3_CCR3) or not.
                CC3E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture disabled. Writing '0' to the CC3E bit resets the associated ic3_dma_req signal.
                        B_0x0 = 0x0,
                        ///  Capture enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 3 output polarity. Condition: CC3 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC3 as input: This field is used to select the IC3 polarity for capture operations.
                CC3P: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  rising edge, circuit is sensitive to IC3 rising edge
                        B_0x0 = 0x0,
                        ///  falling edge, circuit is sensitive to IC3 falling edge
                        B_0x1 = 0x1,
                        ///  reserved, do not use this configuration.
                        B_0x2 = 0x2,
                        ///  both edges, circuit is sensitive to both IC3 rising and falling edges.
                        B_0x3 = 0x3,
                    },
                },
                reserved8: u4,
                ///  Input capture 3 prescaler This bitfield defines the ratio of the prescaler acting on the CC3 input (IC3).
                IC3PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  Input capture 3 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC3F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                reserved16: u2,
                ///  Capture/compare 4 selection This bitfield defines the direction of the channel, input (capture) or output mode.
                CC4SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 channel is configured in output PWM mode
                        B_0x0 = 0x0,
                        ///  CC4 channel is configured in input capture mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 output enable. Condition: CC4 as output: Condition: CC4 as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM3_CCR4) or not.
                CC4E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture disabled. Writing '0' to the CC4E bit resets the associated ic4_dma_req signal.
                        B_0x0 = 0x0,
                        ///  Capture enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 4 output polarity. Condition: CC4 as output: Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care. Condition: CC4 as input: This field is used to select the IC4 polarity for capture operations.
                CC4P: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  rising edge, circuit is sensitive to IC4 rising edge
                        B_0x0 = 0x0,
                        ///  falling edge, circuit is sensitive to IC4 falling edge
                        B_0x1 = 0x1,
                        ///  reserved, do not use this configuration.
                        B_0x2 = 0x2,
                        ///  both edges, circuit is sensitive to both IC4 rising and falling edges.
                        B_0x3 = 0x3,
                    },
                },
                reserved24: u4,
                ///  Input capture 4 prescaler This bitfield defines the ratio of the prescaler acting on the CC4 input (IC4).
                IC4PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                reserved28: u2,
                ///  Input capture 4 filter This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.
                IC4F: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  any external input capture signal level change is considered as a valid transition
                        B_0x0 = 0x0,
                        ///  external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
                        B_0x1 = 0x1,
                        ///  external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
                        B_0x2 = 0x2,
                        ///  external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
                        B_0x3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  LPTIM compare register 2
            LPTIM3_CCR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the capture/compare 2 register. Depending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 2 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC2 output. If channel CC2 is configured as input: CCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM3_CCR2 register is read-only and cannot be programmed.
                CCR2: u16,
                padding: u16,
            }),
            ///  LPTIM compare register 3
            LPTIM3_CCR3: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 value If channel CC3 is configured as output: CCR3 is the value to be loaded in the capture/compare 3 register. Depending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 3 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC3 output. If channel CC3 is configured as input: CCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM3_CCR3 register is read-only and cannot be programmed.
                CCR3: u16,
                padding: u16,
            }),
            ///  LPTIM compare register 4
            LPTIM3_CCR4: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 4 value If channel CC4 is configured as output: CCR4 is the value to be loaded in the capture/compare 4 register. Depending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset. The capture/compare register 4 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC4 output. If channel CC4 is configured as input: CCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM3_CCR4 register is read-only and cannot be programmed.
                CCR4: u16,
                padding: u16,
            }),
        };

        ///  LPUART address block description
        pub const LPUART1 = extern struct {
            ///  LPUART control register 1
            LPUART_CR1: mmio.Mmio(packed struct(u32) {
                ///  LPUART enable When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
                UE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPUART prescaler and outputs disabled, low-power mode
                        B_0x0 = 0x0,
                        ///  LPUART enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  LPUART enable in low-power mode When this bit is cleared, the LPUART cannot wake up the MCU from low-power mode. When this bit is set, the LPUART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.
                UESM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  USART not able to wake up the MCU from low-power mode.
                        B_0x0 = 0x0,
                        ///  USART able to wake up the MCU from low-power mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver enable This bit enables the receiver. It is set and cleared by software.
                RE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver is disabled
                        B_0x0 = 0x0,
                        ///  Receiver is enabled and begins searching for a start bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register. Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
                TE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Transmitter is disabled
                        B_0x0 = 0x0,
                        ///  Transmitter is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  IDLE interrupt enable This bit is set and cleared by software.
                IDLEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An LPUART interrupt is generated whenever IDLE=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO not empty interrupt enable This bit is set and cleared by software.
                RXFNEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  A LPUART interrupt is generated whenever ORE=1 or RXFNE=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmission complete interrupt enable This bit is set and cleared by software.
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An LPUART interrupt is generated whenever TC=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO not full interrupt enable This bit is set and cleared by software.
                TXFNFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  A LPUART interrupt is generated whenever TXFNF =1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  PE interrupt enable This bit is set and cleared by software.
                PEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An LPUART interrupt is generated whenever PE=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the LPUART is disabled (UE=0).
                PS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Even parity
                        B_0x0 = 0x0,
                        ///  Odd parity
                        B_0x1 = 0x1,
                    },
                },
                ///  Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the LPUART is disabled (UE=0).
                PCE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Parity control disabled
                        B_0x0 = 0x0,
                        ///  Parity control enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver wake-up method This bit determines the LPUART wake-up method from Mute mode. It is set or cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
                WAKE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Idle line
                        B_0x0 = 0x0,
                        ///  Address mark
                        B_0x1 = 0x1,
                    },
                },
                ///  Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description). This bit can only be written when the LPUART is disabled (UE=0).
                M0: u1,
                ///  Mute mode enable This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.
                MME: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver in Active mode permanently
                        B_0x0 = 0x0,
                        ///  Receiver can switch between Mute mode and Active mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Character match interrupt enable This bit is set and cleared by software.
                CMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u1,
                ///  Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section132.4.14: RS232 Hardware flow control and RS485 Driver Enable. If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the LPUART is disabled (UE=0).
                DEDT: u5,
                ///  Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section131.5.21: RS232 Hardware flow control and RS485 Driver Enable. This bitfield can only be written when the LPUART is disabled (UE=0).
                DEAT: u5,
                reserved28: u2,
                ///  Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit M[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit M[1:0] = 10: 1 Start bit, 7 Data bits, n Stop bit This bit can only be written when the LPUART is disabled (UE=0). Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.
                M1: u1,
                ///  FIFO mode enable This bit is set and cleared by software.
                FIFOEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  FIFO mode is disabled.
                        B_0x0 = 0x0,
                        ///  FIFO mode is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO empty interrupt enable This bit is set and cleared by software.
                TXFEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An LPUART interrupt is generated when TXFE=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO Full interrupt enable This bit is set and cleared by software.
                RXFFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An LPUART interrupt is generated when RXFF=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  LPUART control register 2
            LPUART_CR2: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the LPUART is disabled (UE=0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
                ADDM7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  4-bit address detection
                        B_0x0 = 0x0,
                        ///  7-bit address detection (in 8-bit data mode)
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u7,
                ///  STOP bits These bits are used for programming the stop bits. This bitfield can only be written when the LPUART is disabled (UE=0).
                STOP: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  1 stop bit
                        B_0x0 = 0x0,
                        ///  Reserved.
                        B_0x1 = 0x1,
                        ///  2 stop bits
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved15: u1,
                ///  Swap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
                SWAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TX/RX pins are used as defined in standard pinout
                        B_0x0 = 0x0,
                        ///  The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.
                        B_0x1 = 0x1,
                    },
                },
                ///  RX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the LPUART is disabled (UE=0).
                RXINV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RX pin signal works using the standard logic levels (V<sub>DD</sub> =1/idle, Gnd=0/mark)
                        B_0x0 = 0x0,
                        ///  RX pin signal values are inverted. ((V<sub>DD</sub> =0/mark, Gnd=1/idle).
                        B_0x1 = 0x1,
                    },
                },
                ///  TX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the LPUART is disabled (UE=0).
                TXINV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TX pin signal works using the standard logic levels (V<sub>DD</sub> =1/idle, Gnd=0/mark)
                        B_0x0 = 0x0,
                        ///  TX pin signal values are inverted. ((V<sub>DD</sub> =0/mark, Gnd=1/idle).
                        B_0x1 = 0x1,
                    },
                },
                ///  Binary data inversion This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
                DATAINV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L)
                        B_0x0 = 0x0,
                        ///  Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted.
                        B_0x1 = 0x1,
                    },
                },
                ///  Most significant bit first This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UE=0).
                MSBFIRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  data is transmitted/received with data bit 0 first, following the start bit.
                        B_0x0 = 0x0,
                        ///  data is transmitted/received with the MSB (bit 7/8) first, following the start bit.
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u4,
                ///  Address of the LPUART node These bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode: In Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used. In low-power mode: they are used for wake up from low-power mode on character match. When WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1. In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set. These bits can only be written when the reception is disabled (RE1=10) or when the USART is disabled (UE1=10).
                ADD: u8,
            }),
            ///  LPUART control register 3
            LPUART_CR3: mmio.Mmio(packed struct(u32) {
                ///  Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register).
                EIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An interrupt is generated when FE=1 or ORE=1 or NE=1 in the LPUART_ISR register.
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u2,
                ///  Half-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the LPUART is disabled (UE=0).
                HDSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Half-duplex mode is not selected
                        B_0x0 = 0x0,
                        ///  Half-duplex mode is selected
                        B_0x1 = 0x1,
                    },
                },
                reserved6: u2,
                ///  DMA enable receiver This bit is set/reset by software
                DMAR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA mode is enabled for reception
                        B_0x1 = 0x1,
                        ///  DMA mode is disabled for reception
                        B_0x0 = 0x0,
                    },
                },
                ///  DMA enable transmitter This bit is set/reset by software
                DMAT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA mode is enabled for transmission
                        B_0x1 = 0x1,
                        ///  DMA mode is disabled for transmission
                        B_0x0 = 0x0,
                    },
                },
                ///  RTS enable This bit can only be written when the LPUART is disabled (UE=0).
                RTSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RTS hardware flow control disabled
                        B_0x0 = 0x0,
                        ///  RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received.
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS enable This bit can only be written when the LPUART is disabled (UE=0)
                CTSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CTS hardware flow control disabled
                        B_0x0 = 0x0,
                        ///  CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted.
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS interrupt enable
                CTSIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An interrupt is generated whenever CTSIF=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u1,
                ///  Overrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register. This bit can only be written when the LPUART is disabled (UE=0). Note: This control bit enables checking the communication flow w/o reading the data.
                OVRDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Overrun Error Flag, ORE is set when received data is not read before receiving new data.
                        B_0x0 = 0x0,
                        ///  Overrun functionality is disabled. If new data is received while the RXNE flag is still set
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA Disable on Reception Error This bit can only be written when the LPUART is disabled (UE=0). Note: The reception errors are: parity error, framing error or noise error.
                DDRE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred.
                        B_0x0 = 0x0,
                        ///  DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE before clearing the error flag.
                        B_0x1 = 0x1,
                    },
                },
                ///  Driver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the LPUART is disabled (UE=0).
                DEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DE function is disabled.
                        B_0x0 = 0x0,
                        ///  DE function is enabled. The DE signal is output on the RTS pin.
                        B_0x1 = 0x1,
                    },
                },
                ///  Driver enable polarity selection This bit can only be written when the LPUART is disabled (UE=0).
                DEP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DE signal is active high.
                        B_0x0 = 0x0,
                        ///  DE signal is active low.
                        B_0x1 = 0x1,
                    },
                },
                reserved20: u4,
                ///  Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wake-up from low-power mode flag). This bitfield can only be written when the LPUART is disabled (UE=0). Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
                WUS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  WUF active on address match (as defined by ADD[7:0] and ADDM7)
                        B_0x0 = 0x0,
                        ///  Reserved.
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wake-up from low-power mode flag). This bitfield can only be written when the LPUART is disabled (UE=0). Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
                WUS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  WUF active on address match (as defined by ADD[7:0] and ADDM7)
                        B_0x0 = 0x0,
                        ///  Reserved.
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
                WUFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever WUF=1 in the LPUART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO threshold interrupt enable This bit is set and cleared by software.
                TXFTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  A LPUART interrupt is generated when TXFIFO reaches the threshold programmed in TXFTCFG.
                        B_0x1 = 0x1,
                    },
                },
                reserved25: u1,
                ///  Receive FIFO threshold configuration Remaining combinations: Reserved.
                RXFTCFG: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Receive FIFO reaches 1/8 of its depth.
                        B_0x0 = 0x0,
                        ///  Receive FIFO reaches 1/4 of its depth.
                        B_0x1 = 0x1,
                        ///  Receive FIFO reaches 1/2 of its depth.
                        B_0x6 = 0x6,
                        ///  Receive FIFO reaches 3/4 of its depth.
                        B_0x3 = 0x3,
                        ///  Receive FIFO reaches 7/8 of its depth.
                        B_0x4 = 0x4,
                        ///  Receive FIFO becomes full.
                        B_0x5 = 0x5,
                        _,
                    },
                },
                ///  RXFIFO threshold interrupt enable This bit is set and cleared by software.
                RXFTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An LPUART interrupt is generated when Receive FIFO reaches the threshold programmed in RXFTCFG.
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO threshold configuration Remaining combinations: Reserved.
                TXFTCFG: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  TXFIFO reaches 1/8 of its depth.
                        B_0x0 = 0x0,
                        ///  TXFIFO reaches 1/4 of its depth.
                        B_0x1 = 0x1,
                        ///  TXFIFO reaches 1/2 of its depth.
                        B_0x6 = 0x6,
                        ///  TXFIFO reaches 3/4 of its depth.
                        B_0x3 = 0x3,
                        ///  TXFIFO reaches 7/8 of its depth.
                        B_0x4 = 0x4,
                        ///  TXFIFO becomes empty.
                        B_0x5 = 0x5,
                        _,
                    },
                },
            }),
            ///  LPUART baud rate register
            LPUART_BRR: mmio.Mmio(packed struct(u32) {
                ///  LPUART baud rate division (LPUARTDIV)
                BRR: u20,
                padding: u12,
            }),
            reserved24: [8]u8,
            ///  LPUART request register
            LPUART_RQR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software must wait for the TXE flag assertion before setting the SBKRQ bit.
                SBKRQ: u1,
                ///  Mute mode request Writing 1 to this bit puts the LPUART in Mute mode and resets the RWU flag.
                MMRQ: u1,
                ///  Receive data flush request Writing 1 to this bit clears the RXNE flag. This enables discarding the received data without reading it, and avoid an overrun condition.
                RXFRQ: u1,
                ///  Transmit data flush request This bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register). Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
                TXFRQ: u1,
                padding: u27,
            }),
            ///  LPUART interrupt and status register
            LPUART_ISR: mmio.Mmio(packed struct(u32) {
                ///  Parity error This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. An interrupt is generated if PEIE = 1 in the LPUART_CR1 register. Note: This error is associated with the character in the LPUART_RDR.
                PE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No parity error
                        B_0x0 = 0x0,
                        ///  Parity error
                        B_0x1 = 0x1,
                    },
                },
                ///  Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE1=11 in the LPUART_CR3 register. Note: This error is associated with the character in the LPUART_RDR.
                FE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Framing error is detected
                        B_0x0 = 0x0,
                        ///  Framing error or break character is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Start bit noise detection flag This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. Note: This error is associated with the character in the LPUART_RDR.
                NE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No noise is detected
                        B_0x0 = 0x0,
                        ///  Noise is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register. An interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register, or EIE = 1 in the LPUART_CR3 register. Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.
                ORE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Overrun error is detected
                        B_0x1 = 0x1,
                        _,
                    },
                },
                ///  Idle line detected This bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). Note: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.
                IDLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Idle line is detected
                        B_0x0 = 0x0,
                        ///  Idle line is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. An interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register.
                RXFNE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Data is not received
                        B_0x0 = 0x0,
                        ///  Received data is ready to be read.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmission complete This bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows: When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set. When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached. When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred. When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty. An interrupt is generated if TCIE=1 in the LPUART_CR1 register. TC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register.
                TC: u1,
                ///  TXFIFO not full TXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR. The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF must be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). An interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register. Note: This bit is used during single buffer transmission.
                TXFNF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Data register is full/Transmit FIFO is full.
                        B_0x0 = 0x0,
                        ///  Data register/Transmit FIFO is not full.
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u1,
                ///  CTS interrupt flag This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. An interrupt is generated if CTSIE=1 in the LPUART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
                CTSIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No change occurred on the CTS status line
                        B_0x0 = 0x0,
                        ///  A change occurred on the CTS status line
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
                CTS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CTS line set
                        B_0x0 = 0x0,
                        ///  CTS line reset
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u5,
                ///  Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
                BUSY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LPUART is idle (no reception)
                        B_0x0 = 0x0,
                        ///  Reception on going
                        B_0x1 = 0x1,
                    },
                },
                ///  Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. An interrupt is generated if CMIE=1in the LPUART_CR1 register.
                CMF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Character match detected
                        B_0x0 = 0x0,
                        ///  Character match detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
                SBKF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break character transmitted
                        B_0x0 = 0x0,
                        ///  Break character transmitted
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver wake-up from Mute mode This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register. When wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. Note: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value.
                RWU: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver in Active mode
                        B_0x0 = 0x0,
                        ///  Receiver in Mute mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from low-power mode flag This bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register. An interrupt is generated if WUFIE=1 in the LPUART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
                WUF: u1,
                ///  Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.
                TEACK: u1,
                ///  Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. It can be used to verify that the LPUART is ready for reception before entering low-power mode. Note: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value.
                REACK: u1,
                ///  TXFIFO Empty This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register. An interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register.
                TXFE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TXFIFO is not empty.
                        B_0x0 = 0x0,
                        ///  TXFIFO is empty.
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO Full This bit is set by hardware when the number of received data corresponds to RXFIFO1size1+11 (RXFIFO full + 1 data in the LPUART_RDR register. An interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register.
                RXFF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RXFIFO is not Full.
                        B_0x0 = 0x0,
                        ///  RXFIFO is Full.
                        B_0x1 = 0x1,
                    },
                },
                reserved26: u1,
                ///  RXFIFO threshold flag This bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register.
                RXFT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receive FIFO does not reach the programmed threshold.
                        B_0x0 = 0x0,
                        ///  Receive FIFO reached the programmed threshold.
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register.
                TXFT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TXFIFO does not reach the programmed threshold.
                        B_0x0 = 0x0,
                        ///  TXFIFO reached the programmed threshold.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            ///  LPUART interrupt flag clear register
            LPUART_ICR: mmio.Mmio(packed struct(u32) {
                ///  Parity error clear flag Writing 1 to this bit clears the PE flag in the LPUART_ISR register.
                PECF: u1,
                ///  Framing error clear flag Writing 1 to this bit clears the FE flag in the LPUART_ISR register.
                FECF: u1,
                ///  Noise detected clear flag Writing 1 to this bit clears the NE flag in the LPUART_ISR register.
                NECF: u1,
                ///  Overrun error clear flag Writing 1 to this bit clears the ORE flag in the LPUART_ISR register.
                ORECF: u1,
                ///  Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the LPUART_ISR register.
                IDLECF: u1,
                reserved6: u1,
                ///  Transmission complete clear flag Writing 1 to this bit clears the TC flag in the LPUART_ISR register.
                TCCF: u1,
                reserved9: u2,
                ///  CTS clear flag Writing 1 to this bit clears the CTSIF flag in the LPUART_ISR register.
                CTSCF: u1,
                reserved17: u7,
                ///  Character match clear flag Writing 1 to this bit clears the CMF flag in the LPUART_ISR register.
                CMCF: u1,
                reserved20: u2,
                ///  Wake-up from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914.
                WUCF: u1,
                padding: u11,
            }),
            ///  LPUART receive data register
            LPUART_RDR: mmio.Mmio(packed struct(u32) {
                ///  Receive data value Contains the received data character. The RDR register provides the parallel interface between the input shift register and the internal bus (see Figure1254). When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
                RDR: u9,
                padding: u23,
            }),
            ///  LPUART transmit data register
            LPUART_TDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data value Contains the data character to be transmitted. The TDR register provides the parallel interface between the internal bus and the output shift register (see Figure1254). When transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity. Note: This register must be written only when TXE/TXFNF=1.
                TDR: u9,
                padding: u23,
            }),
            ///  LPUART prescaler register
            LPUART_PRESC: mmio.Mmio(packed struct(u32) {
                ///  Clock prescaler The LPUART input clock can be divided by a prescaler: Remaining combinations: Reserved. Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256.
                PRESCALER: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  input clock not divided
                        B_0x0 = 0x0,
                        ///  input clock divided by 2
                        B_0x1 = 0x1,
                        ///  input clock divided by 4
                        B_0x2 = 0x2,
                        ///  input clock divided by 6
                        B_0x3 = 0x3,
                        ///  input clock divided by 8
                        B_0x4 = 0x4,
                        ///  input clock divided by 10
                        B_0x5 = 0x5,
                        ///  input clock divided by 12
                        B_0x6 = 0x6,
                        ///  input clock divided by 16
                        B_0x7 = 0x7,
                        ///  input clock divided by 32
                        B_0x8 = 0x8,
                        ///  input clock divided by 64
                        B_0x9 = 0x9,
                        ///  input clock divided by 128
                        B_0xA = 0xa,
                        ///  input clock divided by 256
                        B_0xB = 0xb,
                        _,
                    },
                },
                padding: u28,
            }),
        };

        ///  TIM15 address block description
        pub const TIM15 = extern struct {
            ///  TIM15 control register 1
            TIM15_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled.
                        B_0x0 = 0x0,
                        ///  UEV disabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generate an update interrupt if enabled.
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt if enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  One-pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the bit CEN)
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock division
                CKD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  B_0x0
                        B_0x0 = 0x0,
                        ///  B_0x1
                        B_0x1 = 0x1,
                        ///  B_0x2
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping.
                        B_0x0 = 0x0,
                        ///  Remapping enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM15 control register 2
            TIM15_CR2: mmio.Mmio(packed struct(u16) {
                ///  Capture/compare preloaded control
                CCPC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCxE, CCxNE and OCxM bits are not preloaded
                        B_0x0 = 0x0,
                        ///  CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit).
                        B_0x1 = 0x1,
                    },
                },
                reserved2: u1,
                ///  Capture/compare control update selection
                CCUS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.
                        B_0x0 = 0x0,
                        ///  When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare DMA selection
                CCDS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCx DMA request sent when CCx event occurs
                        B_0x0 = 0x0,
                        ///  CCx DMA requests sent when update event occurs
                        B_0x1 = 0x1,
                    },
                },
                ///  Master mode selection
                MMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO).
                        B_0x0 = 0x0,
                        ///  Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO).
                        B_0x1 = 0x1,
                        ///  Update - The update event is selected as trigger output (TRGO).
                        B_0x2 = 0x2,
                        ///  Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred.
                        B_0x3 = 0x3,
                        ///  Compare - OC1REFC signal is used as trigger output (TRGO).
                        B_0x4 = 0x4,
                        ///  Compare - OC2REFC signal is used as trigger output (TRGO).
                        B_0x5 = 0x5,
                        _,
                    },
                },
                ///  TI1 selection
                TI1S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The TIMx_CH1 pin is connected to TI1 input
                        B_0x0 = 0x0,
                        ///  The TIMx_CH1, CH2 pins are connected to the TI1 input (XOR combination)
                        B_0x1 = 0x1,
                    },
                },
                ///  Output Idle state 1 (OC1 output)
                OIS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
                        B_0x0 = 0x0,
                        ///  OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                ///  Output Idle state 1 (OC1N output)
                OIS1N: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1N=0 after a dead-time when MOE=0
                        B_0x0 = 0x0,
                        ///  OC1N=1 after a dead-time when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                ///  Output idle state 2 (OC2 output)
                OIS2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC2=0 when MOE=0
                        B_0x0 = 0x0,
                        ///  OC2=1 when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                padding: u5,
            }),
            reserved8: [2]u8,
            ///  TIM15 slave mode control register
            TIM15_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS[2:0]: Slave mode selection
                SMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Slave mode disabled - if CEN = 1' then the prescaler is clocked directly by the internal clock.
                        B_0x0 = 0x0,
                        ///  Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                        B_0x4 = 0x4,
                        ///  Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high.
                        B_0x5 = 0x5,
                        ///  Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset).
                        B_0x6 = 0x6,
                        ///  External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
                        B_0x7 = 0x7,
                        _,
                    },
                },
                reserved4: u1,
                ///  TS[2:0]: Trigger selection
                TS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Internal Trigger 0 (ITR0)
                        B_0x0 = 0x0,
                        ///  Internal Trigger 1 (ITR1)
                        B_0x1 = 0x1,
                        ///  Internal Trigger 2 (ITR2)
                        B_0x2 = 0x2,
                        ///  Internal Trigger 3 (ITR3)
                        B_0x3 = 0x3,
                        ///  TI1 Edge Detector (TI1F_ED)
                        B_0x4 = 0x4,
                        ///  Filtered Timer Input 1 (TI1FP1)
                        B_0x5 = 0x5,
                        ///  Filtered Timer Input 2 (TI2FP2)
                        B_0x6 = 0x6,
                        _,
                    },
                },
                ///  Master/slave mode
                MSM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO).
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u8,
                ///  SMS[3]
                SMS_1: u1,
                reserved20: u3,
                ///  TS[4:3]
                TS_1: u2,
                padding: u10,
            }),
            ///  TIM15 DMA/interrupt enable register
            TIM15_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt enable
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u2,
                ///  COM interrupt enable
                COMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COM interrupt disabled
                        B_0x0 = 0x0,
                        ///  COM interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger interrupt enable
                TIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger interrupt disabled
                        B_0x0 = 0x0,
                        ///  Trigger interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Break interrupt enable
                BIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break interrupt disabled
                        B_0x0 = 0x0,
                        ///  Break interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 DMA request enable
                CC1DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 DMA request disabled
                        B_0x0 = 0x0,
                        ///  CC1 DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved13: u3,
                ///  COM DMA request enable
                COMDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COM DMA request disabled
                        B_0x0 = 0x0,
                        ///  COM DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger DMA request enable
                TDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger DMA request disabled
                        B_0x0 = 0x0,
                        ///  Trigger DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM15 status register
            TIM15_SR: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt flag
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred.
                        B_0x0 = 0x0,
                        ///  Update interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt flag
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No compare match / No input capture occurred
                        B_0x0 = 0x0,
                        ///  A compare match or an input capture occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt flag
                CC2IF: u1,
                reserved5: u2,
                ///  COM interrupt flag
                COMIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No COM event occurred
                        B_0x0 = 0x0,
                        ///  COM interrupt pending
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger interrupt flag
                TIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No trigger event occurred
                        B_0x0 = 0x0,
                        ///  Trigger interrupt pending
                        B_0x1 = 0x1,
                    },
                },
                ///  Break interrupt flag
                BIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break event occurred
                        B_0x0 = 0x0,
                        ///  An active level has been detected on the break input
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u1,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overcapture has been detected
                        B_0x0 = 0x0,
                        ///  The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 overcapture flag
                CC2OF: u1,
                padding: u5,
            }),
            reserved20: [2]u8,
            ///  TIM15 event generation register
            TIM15_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  Reinitialize the counter and generates an update of the registers.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 generation
                CC1G: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A capture/compare event is generated on channel 1:
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 generation
                CC2G: u1,
                reserved5: u2,
                ///  Capture/Compare control update generation
                COMG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger generation
                TG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The TIF flag is set in TIMx_SR register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Break generation
                BG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A break event is generated.
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            reserved24: [2]u8,
            ///  TIM15 capture/compare mode register 1
            TIM15_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 Selection
                CC1S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC1 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI1
                        B_0x1 = 0x1,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI2
                        B_0x2 = 0x2,
                        ///  CC1 channel is configured as input, IC1 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 prescaler
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 filter
                IC1F: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at fless thansub>DTSless than/sub>
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  Capture/Compare 2 selection
                CC2S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC2 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI2
                        B_0x1 = 0x1,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI1
                        B_0x2 = 0x2,
                        ///  CC2 channel is configured as input, IC2 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 2 prescaler
                IC2PSC: u2,
                ///  Input capture 2 filter
                IC2F: u4,
                padding: u16,
            }),
            reserved32: [4]u8,
            ///  TIM15 capture/compare enable register
            TIM15_CCER: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 output enable
                CC1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture mode disabled / OC1 is not active (see below)
                        B_0x0 = 0x0,
                        ///  Capture mode enabled / OC1 signal is output on the corresponding output pin
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 output polarity
                CC1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x0 = 0x0,
                        ///  OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 complementary output enable
                CC1NE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Off - OC1N is not active.
                        B_0x0 = 0x0,
                        ///  On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 complementary output polarity
                CC1NP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1N active high
                        B_0x0 = 0x0,
                        ///  OC1N active low
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 output enable
                CC2E: u1,
                ///  Capture/Compare 2 output polarity
                CC2P: u1,
                reserved7: u1,
                ///  Capture/Compare 2 complementary output polarity
                CC2NP: u1,
                padding: u8,
            }),
            reserved36: [2]u8,
            ///  TIM15 counter
            TIM15_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy
                UIFCPY: u1,
            }),
            ///  TIM15 prescaler
            TIM15_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM15 auto-reload register
            TIM15_ARR: mmio.Mmio(packed struct(u16) {
                ///  Auto-reload value
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM15 repetition counter register
            TIM15_RCR: mmio.Mmio(packed struct(u16) {
                ///  Repetition counter value
                REP: u8,
                padding: u8,
            }),
            reserved52: [2]u8,
            ///  TIM15 capture/compare register 1
            TIM15_CCR1: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 value
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM15 capture/compare register 2
            TIM15_CCR2: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 2 value
                CCR2: u16,
            }),
            reserved68: [10]u8,
            ///  TIM15 break and dead-time register
            TIM15_BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration
                LOCK: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LOCK OFF - No bit is write protected
                        B_0x0 = 0x0,
                        ///  LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written
                        B_0x1 = 0x1,
                        ///  LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
                        B_0x2 = 0x2,
                        ///  LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
                        B_0x3 = 0x3,
                    },
                },
                ///  Off-state selection for Idle mode
                OSSI: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
                        B_0x0 = 0x0,
                        ///  When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1.
                        B_0x1 = 0x1,
                    },
                },
                ///  Off-state selection for Run mode
                OSSR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)
                        B_0x0 = 0x0,
                        ///  When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
                        B_0x1 = 0x1,
                    },
                },
                ///  Break enable
                BKE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break inputs (BRK and CCS clock failure event) disabled
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  Break polarity
                BKP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK is active low
                        B_0x0 = 0x0,
                        ///  Break input BRK is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  Automatic output enable
                AOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MOE can be set only by software
                        B_0x0 = 0x0,
                        ///  MOE can be set by software or automatically at the next update event (if the break input is not be active)
                        B_0x1 = 0x1,
                    },
                },
                ///  Main output enable
                MOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
                        B_0x0 = 0x0,
                        ///  OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)
                        B_0x1 = 0x1,
                    },
                },
                ///  Break filter
                BKF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, BRK acts asynchronously
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                reserved26: u6,
                ///  Break Disarm
                BKDSRM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK is armed
                        B_0x0 = 0x0,
                        ///  Break input BRK is disarmed
                        B_0x1 = 0x1,
                    },
                },
                reserved28: u1,
                ///  Break Bidirectional
                BKBID: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK in input mode
                        B_0x0 = 0x0,
                        ///  Break input BRK in bidirectional mode
                        B_0x1 = 0x1,
                    },
                },
                padding: u3,
            }),
            ///  TIM15 DMA control register
            TIM15_DCR: mmio.Mmio(packed struct(u16) {
                ///  DMA base address
                DBA: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  TIMx_CR1,
                        B_0x0 = 0x0,
                        ///  TIMx_CR2,
                        B_0x1 = 0x1,
                        ///  TIMx_SMCR,
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved8: u3,
                ///  DMA burst length
                DBL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  1 transfer,
                        B_0x0 = 0x0,
                        ///  2 transfers,
                        B_0x1 = 0x1,
                        ///  3 transfers,
                        B_0x2 = 0x2,
                        ///  18 transfers.
                        B_0x11 = 0x11,
                        _,
                    },
                },
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM15 DMA address for full transfer
            TIM15_DMAR: mmio.Mmio(packed struct(u16) {
                ///  DMA register for burst accesses
                DMAB: u16,
            }),
            reserved96: [18]u8,
            ///  TIM15 alternate register 1
            TIM15_AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable
                BKINE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN input disabled
                        B_0x0 = 0x0,
                        ///  BKIN input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP1 enable
                BKCMP1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input disabled
                        B_0x0 = 0x0,
                        ///  COMP1 input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP2 enable
                BKCMP2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input disabled
                        B_0x0 = 0x0,
                        ///  COMP2 input enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u6,
                ///  BRK BKIN input polarity
                BKINP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN input is active low
                        B_0x0 = 0x0,
                        ///  BKIN input is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP1 input polarity
                BKCMP1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input is active low
                        B_0x0 = 0x0,
                        ///  COMP1 input is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP2 input polarity
                BKCMP2P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input is active low
                        B_0x0 = 0x0,
                        ///  COMP2 input is active high
                        B_0x1 = 0x1,
                    },
                },
                padding: u20,
            }),
            reserved104: [4]u8,
            ///  TIM15 input selection register
            TIM15_TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input
                TI1SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM15_CH1 input
                        B_0x0 = 0x0,
                        ///  TIM2_IC1
                        B_0x1 = 0x1,
                        ///  TIM3_IC1
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved8: u4,
                ///  selects TI2[0] to TI2[15] input
                TI2SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM15_CH2 input
                        B_0x0 = 0x0,
                        ///  TIM2_IC2
                        B_0x1 = 0x1,
                        ///  TIM3_IC2
                        B_0x2 = 0x2,
                        _,
                    },
                },
                padding: u20,
            }),
        };

        ///  TIM16 address block description
        pub const TIM16 = extern struct {
            ///  TIM16 control register 1
            TIM16_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled.
                        B_0x0 = 0x0,
                        ///  UEV disabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generate an update interrupt or DMA request if enabled.
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  One pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the bit CEN)
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock division
                CKD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  B_0x0
                        B_0x0 = 0x0,
                        ///  B_0x1
                        B_0x1 = 0x1,
                        ///  B_0x2
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping.
                        B_0x0 = 0x0,
                        ///  Remapping enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM16 control register 2
            TIM16_CR2: mmio.Mmio(packed struct(u16) {
                ///  Capture/compare preloaded control
                CCPC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCxE, CCxNE and OCxM bits are not preloaded
                        B_0x0 = 0x0,
                        ///  CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set.
                        B_0x1 = 0x1,
                    },
                },
                reserved2: u1,
                ///  Capture/compare control update selection
                CCUS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.
                        B_0x0 = 0x0,
                        ///  When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare DMA selection
                CCDS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCx DMA request sent when CCx event occurs
                        B_0x0 = 0x0,
                        ///  CCx DMA requests sent when update event occurs
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u4,
                ///  Output Idle state 1 (OC1 output)
                OIS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
                        B_0x0 = 0x0,
                        ///  OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                ///  Output Idle state 1 (OC1N output)
                OIS1N: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1N=0 after a dead-time when MOE=0
                        B_0x0 = 0x0,
                        ///  OC1N=1 after a dead-time when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                padding: u6,
            }),
            reserved12: [6]u8,
            ///  TIM16 DMA/interrupt enable register
            TIM16_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u3,
                ///  COM interrupt enable
                COMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COM interrupt disabled
                        B_0x0 = 0x0,
                        ///  COM interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  Break interrupt enable
                BIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break interrupt disabled
                        B_0x0 = 0x0,
                        ///  Break interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 DMA request enable
                CC1DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 DMA request disabled
                        B_0x0 = 0x0,
                        ///  CC1 DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u6,
            }),
            reserved16: [2]u8,
            ///  TIM16 status register
            TIM16_SR: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt flag
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred.
                        B_0x0 = 0x0,
                        ///  Update interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt flag
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No compare match / No input capture occurred
                        B_0x0 = 0x0,
                        ///  A compare match or an input capture occurred
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u3,
                ///  COM interrupt flag
                COMIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No COM event occurred
                        B_0x0 = 0x0,
                        ///  COM interrupt pending
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  Break interrupt flag
                BIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break event occurred
                        B_0x0 = 0x0,
                        ///  An active level has been detected on the break input
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u1,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overcapture has been detected
                        B_0x0 = 0x0,
                        ///  The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
                        B_0x1 = 0x1,
                    },
                },
                padding: u6,
            }),
            reserved20: [2]u8,
            ///  TIM16 event generation register
            TIM16_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action.
                        B_0x0 = 0x0,
                        ///  Reinitialize the counter and generates an update of the registers.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 generation
                CC1G: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action.
                        B_0x0 = 0x0,
                        ///  A capture/compare event is generated on channel 1:
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u3,
                ///  Capture/Compare control update generation
                COMG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  Break generation
                BG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action.
                        B_0x0 = 0x0,
                        ///  A break event is generated.
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            reserved24: [2]u8,
            ///  TIM16 capture/compare mode register 1
            TIM16_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 Selection
                CC1S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC1 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI1
                        B_0x1 = 0x1,
                        _,
                    },
                },
                ///  Input capture 1 prescaler
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input.
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 filter
                IC1F: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at fless thansub>DTSless than/sub>
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                padding: u24,
            }),
            reserved32: [4]u8,
            ///  TIM16 capture/compare enable register
            TIM16_CCER: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 output enable
                CC1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture mode disabled / OC1 is not active (see below)
                        B_0x0 = 0x0,
                        ///  Capture mode enabled / OC1 signal is output on the corresponding output pin
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 output polarity
                CC1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x0 = 0x0,
                        ///  OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 complementary output enable
                CC1NE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Off - OC1N is not active.
                        B_0x0 = 0x0,
                        ///  On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 complementary output polarity
                CC1NP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1N active high
                        B_0x0 = 0x0,
                        ///  OC1N active low
                        B_0x1 = 0x1,
                    },
                },
                padding: u12,
            }),
            reserved36: [2]u8,
            ///  TIM16 counter
            TIM16_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy
                UIFCPY: u1,
            }),
            ///  TIM16 prescaler
            TIM16_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM16 auto-reload register
            TIM16_ARR: mmio.Mmio(packed struct(u16) {
                ///  Auto-reload value
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM16 repetition counter register
            TIM16_RCR: mmio.Mmio(packed struct(u16) {
                ///  Repetition counter value
                REP: u8,
                padding: u8,
            }),
            reserved52: [2]u8,
            ///  TIM16 capture/compare register 1
            TIM16_CCR1: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 value
                CCR1: u16,
            }),
            reserved68: [14]u8,
            ///  TIM16 break and dead-time register
            TIM16_BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration
                LOCK: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LOCK OFF - No bit is write protected
                        B_0x0 = 0x0,
                        ///  LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.
                        B_0x1 = 0x1,
                        ///  LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
                        B_0x2 = 0x2,
                        ///  LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
                        B_0x3 = 0x3,
                    },
                },
                ///  Off-state selection for Idle mode
                OSSI: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
                        B_0x0 = 0x0,
                        ///  When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1.
                        B_0x1 = 0x1,
                    },
                },
                ///  Off-state selection for Run mode
                OSSR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)
                        B_0x0 = 0x0,
                        ///  When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
                        B_0x1 = 0x1,
                    },
                },
                ///  Break enable
                BKE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break inputs (BRK and CCS clock failure event) disabled
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  Break polarity
                BKP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK is active low
                        B_0x0 = 0x0,
                        ///  Break input BRK is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  Automatic output enable
                AOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MOE can be set only by software
                        B_0x0 = 0x0,
                        ///  MOE can be set by software or automatically at the next update event (if the break input is not be active)
                        B_0x1 = 0x1,
                    },
                },
                ///  Main output enable
                MOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
                        B_0x0 = 0x0,
                        ///  OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)
                        B_0x1 = 0x1,
                    },
                },
                ///  Break filter
                BKF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, BRK acts asynchronously
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                reserved26: u6,
                ///  Break Disarm
                BKDSRM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK is armed
                        B_0x0 = 0x0,
                        ///  Break input BRK is disarmed
                        B_0x1 = 0x1,
                    },
                },
                reserved28: u1,
                ///  Break Bidirectional
                BKBID: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK in input mode
                        B_0x0 = 0x0,
                        ///  Break input BRK in bidirectional mode
                        B_0x1 = 0x1,
                    },
                },
                padding: u3,
            }),
            ///  TIM16 DMA control register
            TIM16_DCR: mmio.Mmio(packed struct(u16) {
                ///  DMA base address
                DBA: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  TIMx_CR1,
                        B_0x0 = 0x0,
                        ///  TIMx_CR2,
                        B_0x1 = 0x1,
                        ///  TIMx_SMCR,
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved8: u3,
                ///  DMA burst length
                DBL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  1 transfer,
                        B_0x0 = 0x0,
                        ///  2 transfers,
                        B_0x1 = 0x1,
                        ///  3 transfers,
                        B_0x2 = 0x2,
                        ///  18 transfers.
                        B_0x11 = 0x11,
                        _,
                    },
                },
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM16 DMA address for full transfer
            TIM16_DMAR: mmio.Mmio(packed struct(u16) {
                ///  DMA register for burst accesses
                DMAB: u16,
            }),
            reserved96: [18]u8,
            ///  TIM16 alternate function register 1
            TIM16_AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable
                BKINE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN input disabled
                        B_0x0 = 0x0,
                        ///  BKIN input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP1 enable
                BKCMP1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input disabled
                        B_0x0 = 0x0,
                        ///  COMP1 input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP2 enable
                BKCMP2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input disabled
                        B_0x0 = 0x0,
                        ///  COMP2 input enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u6,
                ///  BRK BKIN input polarity
                BKINP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN input is active low
                        B_0x0 = 0x0,
                        ///  BKIN input is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP1 input polarity
                BKCMP1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input is active low
                        B_0x0 = 0x0,
                        ///  COMP1 input is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP2 input polarity
                BKCMP2P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input is active low
                        B_0x0 = 0x0,
                        ///  COMP2 input is active high
                        B_0x1 = 0x1,
                    },
                },
                padding: u20,
            }),
            reserved104: [4]u8,
            ///  TIM16 input selection register
            TIM16_TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input
                TI1SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM16_CH1 input
                        B_0x0 = 0x0,
                        ///  LSI
                        B_0x1 = 0x1,
                        ///  LSE
                        B_0x2 = 0x2,
                        ///  RTC wakeup
                        B_0x3 = 0x3,
                        ///  MCO2
                        B_0x4 = 0x4,
                        _,
                    },
                },
                padding: u28,
            }),
        };

        ///  OPAMP address block description
        pub const OPAMP = extern struct {
            ///  OPAMP control/status register
            OPAMP_CSR: mmio.Mmio(packed struct(u32) {
                ///  Operational amplifier Enable
                OPAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  operational amplifier disabled
                        B_0x0 = 0x0,
                        ///  operational amplifier enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Operational amplifier Low Power Mode The operational amplifier must be disable to change this configuration.
                OPALPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  operational amplifier in normal mode
                        B_0x0 = 0x0,
                        ///  operational amplifier in low-power mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Operational amplifier PGA mode
                OPAMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  internal PGA disable
                        B_0x0 = 0x0,
                        ///  internal PGA disable
                        B_0x1 = 0x1,
                        ///  internal PGA enable, gain programmed in PGA_GAIN
                        B_0x2 = 0x2,
                        ///  internal follower
                        B_0x3 = 0x3,
                    },
                },
                ///  Operational amplifier Programmable amplifier gain value
                PGA_GAIN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  internal PGA Gain 2
                        B_0x0 = 0x0,
                        ///  internal PGA Gain 4
                        B_0x1 = 0x1,
                        ///  internal PGA Gain 8
                        B_0x2 = 0x2,
                        ///  internal PGA Gain 16
                        B_0x3 = 0x3,
                    },
                },
                reserved8: u2,
                ///  Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. 1x: Inverting input not externally connected. These configurations are valid only when OPAMODE = 10 (PGA mode)
                VM_SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  GPIO connected to VINM (valid also in PGA mode for filtering)
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  Non inverted input selection
                VP_SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  GPIO connected to VINP
                        B_0x0 = 0x0,
                        ///  DAC connected to VINP
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u1,
                ///  Calibration mode enabled
                CALON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Normal mode
                        B_0x0 = 0x0,
                        ///  Calibration mode (all switches opened by HW)
                        B_0x1 = 0x1,
                    },
                },
                ///  Calibration selection
                CALSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  NMOS calibration (200mV applied on OPAMP inputs)
                        B_0x0 = 0x0,
                        ///  PMOS calibration (VDDA-200mV applied on OPAMP inputs)
                        B_0x1 = 0x1,
                    },
                },
                ///  allows to switch from factory AOP offset trimmed values to AOP offset user trimmed values This bit is active for both mode normal and low-power.
                USERTRIM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  factory trim code used
                        B_0x0 = 0x0,
                        ///  user trim code used
                        B_0x1 = 0x1,
                    },
                },
                ///  Operational amplifier calibration output During calibration mode offset is trimmed when this signal toggle.
                CALOUT: u1,
                reserved31: u15,
                ///  Operational amplifier power supply range for stability All AOP must be in power down to allow AOP-RANGE bit write. It applies to all AOP embedded in the product.
                OPA_RANGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Low range (VDDA < 2.4V)
                        B_0x0 = 0x0,
                        ///  High range (VDDA > 2.4V)
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  OPAMP offset trimming register in normal mode
            OPAMP_OTR: mmio.Mmio(packed struct(u32) {
                ///  Trim for NMOS differential pairs
                TRIMOFFSETN: u5,
                reserved8: u3,
                ///  Trim for PMOS differential pairs
                TRIMOFFSETP: u5,
                padding: u19,
            }),
            ///  OPAMP offset trimming register in low-power mode
            OPAMP_LPOTR: mmio.Mmio(packed struct(u32) {
                ///  Low-power mode trim for NMOS differential pairs
                TRIMLPOFFSETN: u5,
                reserved8: u3,
                ///  Low-power mode trim for PMOS differential pairs
                TRIMLPOFFSETP: u5,
                padding: u19,
            }),
        };

        ///  PWR register block
        pub const PWR = extern struct {
            ///  Power control register 1
            PWR_CR1: mmio.Mmio(packed struct(u32) {
                ///  Low-power mode selection These bits select the low-power mode entered when CPU enters the deepsleep mode. 1xx: Shutdown mode Note: If LPR bit is set, Stop 2 mode cannot be selected and Stop 1 mode shall be entered instead of Stop 2. Note: In Standby mode, SRAM2 can be preserved or not, depending on RRS bit configuration in PWR_CR3.
                LPMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Stop 0 mode
                        B_0x0 = 0x0,
                        ///  Stop 1 mode
                        B_0x1 = 0x1,
                        ///  Stop 2 mode
                        B_0x2 = 0x2,
                        ///  Standby mode
                        B_0x3 = 0x3,
                        _,
                    },
                },
                ///  Flash memory powered down during Stop mode. This bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Stop mode.
                FPD_STOP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Flash memory idle
                        B_0x0 = 0x0,
                        ///  Flash memory powered down
                        B_0x1 = 0x1,
                    },
                },
                ///  Flash memory powered down during Low-power run mode. This bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Low-power sleep mode.
                FPD_LPRUN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Flash memory idle
                        B_0x0 = 0x0,
                        ///  Flash memory powered down
                        B_0x1 = 0x1,
                    },
                },
                ///  Flash memory powered down during Low-power sleep mode. This bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Low-power sleep mode.
                FPD_LPSLP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Flash memory idle
                        B_0x0 = 0x0,
                        ///  Flash memory powered down
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u2,
                ///  Disable backup domain write protection In reset state, the RTC and backup registers are protected against parasitic write access. This bit must be set to enable write access to these registers.
                DBP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Access to RTC and Backup registers disabled
                        B_0x0 = 0x0,
                        ///  Access to RTC and Backup registers enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Voltage scaling range selection
                VOS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Cannot be written (forbidden by hardware)
                        B_0x0 = 0x0,
                        ///  Range 1
                        B_0x1 = 0x1,
                        ///  Range 2
                        B_0x2 = 0x2,
                        ///  Cannot be written (forbidden by hardware)
                        B_0x3 = 0x3,
                    },
                },
                reserved14: u3,
                ///  Low-power run When this bit is set, the regulator is switched from main mode (MR) to low-power mode (LPR). Note: Stop 2 mode cannot be entered when LPR bit is set. Stop 1 is entered instead.
                LPR: u1,
                padding: u17,
            }),
            ///  Power control register 2
            PWR_CR2: mmio.Mmio(packed struct(u32) {
                ///  Programmable voltage detector enable Note: This bit is write-protected when the bit PVDL (PVD Lock) is set in the SYSCFG_CBR register. Note: This bit is reset only by a system reset.
                PVDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Programmable voltage detector disable.
                        B_0x0 = 0x0,
                        ///  Programmable voltage detector enable.
                        B_0x1 = 0x1,
                    },
                },
                ///  Programmable voltage detector level selection. These bits select the voltage threshold detected by the programmable voltage detector: Note: These bits are write-protected when the bit PVDL (PVD Lock) is set in the SYSCFG_CBR register. Note: These bits are reset only by a system reset.
                PLS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  V<sub>PVD0</sub> around 2.01V
                        B_0x0 = 0x0,
                        ///  V<sub>PVD1</sub> around 2.21V
                        B_0x1 = 0x1,
                        ///  V<sub>PVD2</sub> around 2.41V
                        B_0x2 = 0x2,
                        ///  V<sub>PVD3</sub> around 2.51V
                        B_0x3 = 0x3,
                        ///  V<sub>PVD4</sub> around 2.61V
                        B_0x4 = 0x4,
                        ///  V<sub>PVD5</sub> around 2.81V
                        B_0x5 = 0x5,
                        ///  V<sub>PVD6</sub> around 2.91V
                        B_0x6 = 0x6,
                        ///  External input analog voltage PVD_IN (compared internally to VREFINT)
                        B_0x7 = 0x7,
                    },
                },
                ///  Peripheral voltage monitoring 1 enable: V<sub>DDUSB</sub> vs. 1.21V
                PVME1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PVM1 (V<sub>DDUSB</sub> monitoring vs. 1.21V threshold) disable.
                        B_0x0 = 0x0,
                        ///  PVM1 (V<sub>DDUSB</sub> monitoring vs. 1.21V threshold) enable.
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral voltage monitoring 3 enable: V<sub>DDA</sub> vs. 1.621V
                PVME3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PVM3 (V<sub>DDA</sub> monitoring vs. 1.621V threshold) disable.
                        B_0x0 = 0x0,
                        ///  PVM3 (V<sub>DDA</sub> monitoring vs. 1.621V threshold) enable.
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral voltage monitoring 4 enable: V<sub>DDA</sub> vs. 1.861V
                PVME4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PVM4 (V<sub>DDA</sub> monitoring vs. 1.861V threshold) disable.
                        B_0x0 = 0x0,
                        ///  PVM4 (V<sub>DDA</sub> monitoring vs. 1.86 V threshold) enable.
                        B_0x1 = 0x1,
                    },
                },
                reserved10: u3,
                ///  V<sub>DDUSB</sub> USB supply valid This bit is used to validate the V<sub>DDUSB</sub> supply for electrical and logical isolation purpose. Setting this bit is mandatory to use the USB FS peripheral. If V<sub>DDUSB</sub> is not always present in the application, the PVM can be used to determine whether this supply is ready or not.
                USV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>DDUSB</sub> is not present. Logical and electrical isolation is applied to ignore this supply.
                        B_0x0 = 0x0,
                        ///  V<sub>DDUSB</sub> is valid.
                        B_0x1 = 0x1,
                    },
                },
                padding: u21,
            }),
            ///  Power control register 3
            PWR_CR3: mmio.Mmio(packed struct(u32) {
                ///  Enable Wake-up pin WKUP1 When this bit is set, the external wake-up pin WKUP1 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit in the PWR_CR4 register.
                EWUP1: u1,
                ///  Enable Wake-up pin WKUP2 When this bit is set, the external wake-up pin WKUP2 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit in the PWR_CR4 register.
                EWUP2: u1,
                ///  Enable Wake-up pin WKUP3 When this bit is set, the external wake-up pin WKUP3 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit in the PWR_CR4 register.
                EWUP3: u1,
                ///  Enable Wake-up pin WKUP4 When this bit is set, the external wake-up pin WKUP4 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register.
                EWUP4: u1,
                ///  Enable Wake-up pin WKUP5 When this bit is set, the external wake-up pin WKUP5 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP5 bit in the PWR_CR4 register.
                EWUP5: u1,
                reserved6: u1,
                ///  Enable Wake-up pin WKUP7. When this bit is set, the external wake-up pin WKUP7 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP7 bit in the PWR_CR4 register.
                EWUP7: u1,
                reserved8: u1,
                ///  SRAM2 retention in Standby mode
                RRS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SRAM2 is powered off in Standby mode (SRAM2 content is lost).
                        B_0x0 = 0x0,
                        ///  SRAM2 is powered by the low-power regulator in Standby mode (SRAM2 content is kept).
                        B_0x1 = 0x1,
                    },
                },
                ///  Enable ULP sampling When this bit is set, the BORL, BORH and PVD are periodically sampled instead continuous monitoring to reduce power consumption. Fast supply drop between two sample/compare phases is not detected in this mode. This bit has impact only on STOP2, Standby and shutdown low power modes.
                ENULP: u1,
                ///  Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied. When this bit is cleared, the PWR_PUCRx and PWR_PDCRx registers are not applied to the I/Os, instead the I/Os are in floating mode during Standby or configured according GPIO controller GPIOx_PUPDR register during RUN mode.
                APC: u1,
                reserved15: u4,
                ///  Enable internal wake-up line
                EIWUL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal wake-up line disable.
                        B_0x0 = 0x0,
                        ///  Internal wake-up line enable.
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  Power control register 4
            PWR_CR4: mmio.Mmio(packed struct(u32) {
                ///  Wake-up pin WKUP1 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP1
                WP1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Detection on high level (rising edge)
                        B_0x0 = 0x0,
                        ///  Detection on low level (falling edge)
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up pin WKUP2 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP2
                WP2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Detection on high level (rising edge)
                        B_0x0 = 0x0,
                        ///  Detection on low level (falling edge)
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up pin WKUP3 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP3
                WP3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Detection on high level (rising edge)
                        B_0x0 = 0x0,
                        ///  Detection on low level (falling edge)
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up pin WKUP4 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP4
                WP4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Detection on high level (rising edge)
                        B_0x0 = 0x0,
                        ///  Detection on low level (falling edge)
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up pin WKUP5 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP5
                WP5: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Detection on high level (rising edge)
                        B_0x0 = 0x0,
                        ///  Detection on low level (falling edge)
                        B_0x1 = 0x1,
                    },
                },
                reserved6: u1,
                ///  Wake-up pin WKUP7 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP7
                WP7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Detection on high level (rising edge)
                        B_0x0 = 0x0,
                        ///  Detection on low level (falling edge)
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u1,
                ///  V<sub>BAT</sub> battery charging enable
                VBE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>BAT</sub> battery charging disable
                        B_0x0 = 0x0,
                        ///  V<sub>BAT</sub> battery charging enable
                        B_0x1 = 0x1,
                    },
                },
                ///  V<sub>BAT</sub> battery charging resistor selection
                VBRS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Charge V<sub>BAT</sub> through a 5 kOhms resistor
                        B_0x0 = 0x0,
                        ///  Charge V<sub>BAT</sub> through a 1.5 kOhms resistor
                        B_0x1 = 0x1,
                    },
                },
                padding: u22,
            }),
            ///  Power status register 1
            PWR_SR1: mmio.Mmio(packed struct(u32) {
                ///  Wake-up flag 1 This bit is set when a wake-up event is detected on wake-up pin, WKUP1. It is cleared by writing 1 in the CWUF1 bit of the PWR_SCR register.
                WUF1: u1,
                ///  Wake-up flag 2 This bit is set when a wake-up event is detected on wake-up pin, WKUP2. It is cleared by writing 1 in the CWUF2 bit of the PWR_SCR register.
                WUF2: u1,
                ///  Wake-up flag 3 This bit is set when a wake-up event is detected on wake-up pin, WKUP3. It is cleared by writing 1 in the CWUF3 bit of the PWR_SCR register.
                WUF3: u1,
                ///  Wake-up flag 4 This bit is set when a wake-up event is detected on wake-up pin,WKUP4. It is cleared by writing 1 in the CWUF4 bit of the PWR_SCR register.
                WUF4: u1,
                ///  Wake-up flag 5 This bit is set when a wake-up event is detected on wake-up pin, WKUP5. It is cleared by writing 1 in the CWUF5 bit of the PWR_SCR register.
                WUF5: u1,
                reserved6: u1,
                ///  Wake-up flag 7 This bit is set when a wake-up event is detected on wake-up pin, WKUP7. It is cleared by writing 1 in the CWUF7 bit of the PWR_SCR register.
                WUF7: u1,
                reserved8: u1,
                ///  Standby flag This bit is set by hardware when the device enters the Standby mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
                SBF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The device did not enter the Standby mode
                        B_0x0 = 0x0,
                        ///  The device entered the Standby mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Stop Flags These bits are set by hardware when the device enters any stop mode and are cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
                STOPF: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  The device did not enter any Stop mode.
                        B_0x0 = 0x0,
                        ///  The device entered in Stop 0 mode.
                        B_0x4 = 0x4,
                        ///  The device entered in Stop 1 mode.
                        B_0x5 = 0x5,
                        ///  The device entered in Stop 2 mode.
                        B_0x6 = 0x6,
                        _,
                    },
                },
                reserved15: u3,
                ///  Wake-up flag internal This bit is set when a wake-up is detected on the internal wake-up line. It is cleared when all internal wake-up sources are cleared.
                WUFI: u1,
                padding: u16,
            }),
            ///  Power status register 2
            PWR_SR2: mmio.Mmio(packed struct(u32) {
                reserved7: u7,
                ///  Flash ready flag This bit is set by hardware to indicate when the flash memory is readey to be accessed after wake-up from power-down. To place the flash memory in power-down, set either FPD_LPRUN, FPD_LPSLP or FPD_STP bits. Note : If the system boots from SRAM, the user application must wait until the FLASH_RDY bit is set, prior to jumping to flash memory.
                FLASH_RDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Flash memory in power down
                        B_0x0 = 0x0,
                        ///  Flash memory ready to be accessed
                        B_0x1 = 0x1,
                    },
                },
                ///  Low-power regulator started This bit provides the information whether the low-power regulator is ready after a power-on reset or a Standby/Shutdown. If the Standby mode is entered while REGLPS bit is still cleared, the wake-up from Standby mode time may be increased.
                REGLPS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The low-power regulator is not ready
                        B_0x0 = 0x0,
                        ///  The low-power regulator is ready
                        B_0x1 = 0x1,
                    },
                },
                ///  Low-power regulator flag This bit is set by hardware when the MCU is in Low-power run mode. When the MCU exits from the Low-power run mode, this bit remains at 1 until the regulator is ready in main mode. A polling on this bit must be done before increasing the product frequency. This bit is cleared by hardware when the regulator is ready.
                REGLPF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The regulator is ready in main mode (MR)
                        B_0x0 = 0x0,
                        ///  The regulator is in low-power mode (LPR)
                        B_0x1 = 0x1,
                    },
                },
                ///  Voltage scaling flag A delay is required for the internal regulator to be ready after the voltage scaling has been changed. VOSF indicates that the regulator reached the voltage level defined with VOS bits of the PWR_CR1 register.
                VOSF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The regulator is ready in the selected voltage range
                        B_0x0 = 0x0,
                        ///  The regulator output voltage is changing to the required voltage level
                        B_0x1 = 0x1,
                    },
                },
                ///  Programmable voltage detector output
                PVDO: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>DD</sub> is above the selected PVD threshold
                        B_0x0 = 0x0,
                        ///  V<sub>DD</sub> is below the selected PVD threshold
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral voltage monitoring output: V<sub>DDUSB</sub> vs. 1.2 V Note: PVMO1 is cleared when PVM1 is disabled (PVME1 = 0). After enabling PVM1, the PVM1 output is valid after the PVM1 wake-up time.
                PVMO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>DDUSB</sub> voltage is above PVM1 threshold (around 1.21V).
                        B_0x0 = 0x0,
                        ///  V<sub>DDUSB</sub> voltage is below PVM1 threshold (around 1.21V).
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.621V Note: PVMO3 is cleared when PVM3 is disabled (PVME3 = 0). After enabling PVM3, the PVM3 output is valid after the PVM3 wake-up time.
                PVMO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>DDA</sub> voltage is above PVM3 threshold (around 1.621V).
                        B_0x0 = 0x0,
                        ///  V<sub>DDA</sub> voltage is below PVM3 threshold (around 1.621V).
                        B_0x1 = 0x1,
                    },
                },
                ///  Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 2.21V Note: PVMO4 is cleared when PVM4 is disabled (PVME4 = 0). After enabling PVM4, the PVM4 output is valid after the PVM4 wake-up time.
                PVMO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>DDA</sub> voltage is above PVM4 threshold (around 2.21V).
                        B_0x0 = 0x0,
                        ///  V<sub>DDA</sub> voltage is below PVM4 threshold (around 2.21V).
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  Power status clear register
            PWR_SCR: mmio.Mmio(packed struct(u32) {
                ///  Clear wake-up flag 1 Setting this bit clears the WUF1 flag in the PWR_SR1 register.
                CWUF1: u1,
                ///  Clear wake-up flag 2 Setting this bit clears the WUF2 flag in the PWR_SR1 register.
                CWUF2: u1,
                ///  Clear wake-up flag 3 Setting this bit clears the WUF3 flag in the PWR_SR1 register.
                CWUF3: u1,
                ///  Clear wake-up flag 4 Setting this bit clears the WUF4 flag in the PWR_SR1 register.
                CWUF4: u1,
                ///  Clear wake-up flag 5 Setting this bit clears the WUF5 flag in the PWR_SR1 register.
                CWUF5: u1,
                reserved6: u1,
                ///  Clear wake-up flag 7 Setting this bit clears the WUF7 flag in the PWR_SR1 register.
                CWUF7: u1,
                reserved8: u1,
                ///  Clear standby flag Setting this bit clears the SBF flag in the PWR_SR1 register.
                CSBF: u1,
                padding: u23,
            }),
            reserved32: [4]u8,
            ///  Power Port A pull-up control register
            PWR_PUCRA: mmio.Mmio(packed struct(u32) {
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU0: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU1: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU2: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU3: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU4: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU5: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU6: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU7: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU8: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU9: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU10: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU11: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU12: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU13: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU14: u1,
                ///  Port A pull-up bit y (y1=115 to 0) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU15: u1,
                padding: u16,
            }),
            ///  Power Port A pull-down control register
            PWR_PDCRA: mmio.Mmio(packed struct(u32) {
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD0: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD1: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD2: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD3: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD4: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD5: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD6: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD7: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD8: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD9: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD10: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD11: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD12: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD13: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD14: u1,
                ///  Port A pull-down bit y When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
                PD15: u1,
                padding: u16,
            }),
            ///  Power Port B pull-up control register
            PWR_PUCRB: mmio.Mmio(packed struct(u32) {
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU0: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU1: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU2: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU3: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU4: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU5: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU6: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU7: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU8: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU9: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU10: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU11: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU12: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU13: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU14: u1,
                ///  Port B pull-up bit y When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register.
                PU15: u1,
                padding: u16,
            }),
            ///  Power Port B pull-down control register
            PWR_PDCRB: mmio.Mmio(packed struct(u32) {
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD0: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD1: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD2: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD3: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD4: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD5: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD6: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD7: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD8: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD9: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD10: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD11: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD12: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD13: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD14: u1,
                ///  Port B pull-down bit y When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
                PD15: u1,
                padding: u16,
            }),
            ///  Power Port C pull-up control register
            PWR_PUCRC: mmio.Mmio(packed struct(u32) {
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU0: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU1: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU2: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU3: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU4: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU5: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU6: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU7: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU8: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU9: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU10: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU11: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU12: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU13: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU14: u1,
                ///  Port C pull-up bit y When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU15: u1,
                padding: u16,
            }),
            ///  Power Port C pull-down control register
            PWR_PDCRC: mmio.Mmio(packed struct(u32) {
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD0: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD1: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD2: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD3: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD4: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD5: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD6: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD7: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD8: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD9: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD10: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD11: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD12: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD13: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD14: u1,
                ///  Port C pull-down bit y When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.
                PD15: u1,
                padding: u16,
            }),
            ///  Power Port D pull-up control register
            PWR_PUCRD: mmio.Mmio(packed struct(u32) {
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU0: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU1: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU2: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU3: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU4: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU5: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU6: u1,
                reserved8: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU8: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU9: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU10: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU11: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU12: u1,
                ///  Port D pull-up bit y When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU13: u1,
                padding: u18,
            }),
            ///  Power Port D pull-down control register
            PWR_PDCRD: mmio.Mmio(packed struct(u32) {
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD0: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD1: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD2: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD3: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD4: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD5: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD6: u1,
                reserved8: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD8: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD9: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD10: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD11: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD12: u1,
                ///  Port D pull-down bit y When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.
                PD13: u1,
                padding: u18,
            }),
            ///  Power Port E pull-up control register
            PWR_PUCRE: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Port E pull-up bit 3 When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU3: u1,
                reserved7: u3,
                ///  Port E pull-up bit y When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU7: u1,
                ///  Port E pull-up bit y When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU8: u1,
                ///  Port E pull-up bit y When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU9: u1,
                padding: u22,
            }),
            ///  Power Port E pull-down control register
            PWR_PDCRE: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Port E pull-down bit 3 When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
                PD3: u1,
                reserved7: u3,
                ///  Port E pull-down bit y When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
                PD7: u1,
                ///  Port E pull-down bit y When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
                PD8: u1,
                ///  Port E pull-down bit y When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.
                PD9: u1,
                padding: u22,
            }),
            ///  Power Port F pull-up control register
            PWR_PUCRF: mmio.Mmio(packed struct(u32) {
                ///  Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU0: u1,
                ///  Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU1: u1,
                ///  Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU2: u1,
                ///  Port F pull-up bit y When set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority.
                PU3: u1,
                padding: u28,
            }),
            ///  Power Port F pull-down control register
            PWR_PDCRF: mmio.Mmio(packed struct(u32) {
                ///  Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
                PD0: u1,
                ///  Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
                PD1: u1,
                ///  Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
                PD2: u1,
                ///  Port F pull-down bit y When set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register.
                PD3: u1,
                padding: u28,
            }),
        };

        ///  RCC address block description
        pub const RCC = extern struct {
            ///  Clock control register
            RCC_CR: mmio.Mmio(packed struct(u32) {
                ///  MSI clock enable This bit is set and cleared by software. Cleared by hardware to stop the MSI oscillator when entering Stop, Standby or Shutdown mode. Set by hardware to force the MSI oscillator ON when exiting Standby or Shutdown mode. Set by hardware to force the MSI oscillator ON when STOPWUCK=0 when exiting from Stop modes, or in case of a failure of the HSE oscillator Set by hardware when used directly or indirectly as system clock.
                MSION: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MSI oscillator OFF
                        B_0x0 = 0x0,
                        ///  MSI oscillator ON
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI clock ready flag This bit is set by hardware to indicate that the MSI oscillator is stable. Note: Once the MSION bit is cleared, MSIRDY goes low after 6 MSI clock cycles.
                MSIRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MSI oscillator not ready
                        B_0x0 = 0x0,
                        ///  MSI oscillator ready
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI clock PLL enable Set and cleared by software to enable/ disable the PLL part of the MSI clock source. MSIPLLEN must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware).There is a hardware protection to avoid enabling MSIPLLEN if LSE is not ready. This bit is cleared by hardware when LSE is disabled (LSEON = 0) or when the Clock Security System on LSE detects a LSE failure (refer to RCC_CSR register).
                MSIPLLEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MSI PLL OFF
                        B_0x0 = 0x0,
                        ///  MSI PLL ON
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI clock range selection Set by software to select the MSI clock range with MSIRANGE[3:0]. Write 0 has no effect. After a standby or a reset MSIRGSEL is at 0 and the MSI range value is provided by MSISRANGE in CSR register.
                MSIRGSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MSI Range is provided by MSISRANGE[3:0] in RCC_CSR register
                        B_0x0 = 0x0,
                        ///  MSI Range is provided by MSIRANGE[3:0] in the RCC_CR register
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI clock ranges These bits are configured by software to choose the frequency range of MSI when MSIRGSEL is set.12 frequency ranges are available: others: not allowed (hardware write protection) Note: Warning: MSIRANGE can be modified when MSI is OFF (MSION=0) or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when MSI is ON and NOT ready (MSION=1 and MSIRDY=0)
                MSIRANGE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  range 0 around 1001kHz
                        B_0x0 = 0x0,
                        ///  range 1 around 2001kHz
                        B_0x1 = 0x1,
                        ///  range 2 around 4001kHz
                        B_0x2 = 0x2,
                        ///  range 3 around 8001kHz
                        B_0x3 = 0x3,
                        ///  range 4 around 1M1Hz
                        B_0x4 = 0x4,
                        ///  range 5 around 21MHz
                        B_0x5 = 0x5,
                        ///  range 6 around 41MHz (reset value)
                        B_0x6 = 0x6,
                        ///  range 7 around 81MHz
                        B_0x7 = 0x7,
                        ///  range 8 around 161MHz
                        B_0x8 = 0x8,
                        ///  range 9 around 241MHz
                        B_0x9 = 0x9,
                        ///  range 10 around 321MHz
                        B_0xA = 0xa,
                        ///  range 11 around 481MHz
                        B_0xB = 0xb,
                        _,
                    },
                },
                ///  HSI16 clock enable Set and cleared by software. Cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby, or Shutdown mode. Forced by hardware to keep the HSI16 oscillator ON when it is used directly or indirectly as system clock (also when leaving Stop, Standby, or Shutdown modes, or in case of failure of the HSE oscillator used for system clock).
                HSION: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSI16 oscillator OFF
                        B_0x0 = 0x0,
                        ///  HSI16 oscillator ON
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI16 always enable for peripheral kernels. Set and cleared by software to force HSI16 ON even in Stop modes. The HSI16 can only feed USART1, USART2, CEC and I2C1 peripherals configured with HSI16 as kernel clock. Keeping the HSI16 ON in Stop mode allows avoiding to slow down the communication speed because of the HSI16 startup time. This bit has no effect on HSION value.
                HSIKERON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect on HSI16 oscillator.
                        B_0x0 = 0x0,
                        ///  HSI16 oscillator is forced ON even in Stop mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI16 clock ready flag Set by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION. Note: Once the HSION bit is cleared, HSIRDY goes low after 6 HSI16 clock cycles.
                HSIRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSI16 oscillator not ready
                        B_0x0 = 0x0,
                        ///  HSI16 oscillator ready
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI16 automatic start from Stop Set and cleared by software. When the system wake-up clock is MSI, this bit is used to wake up the HSI16 is parallel of the system wake-up.
                HSIASFS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSI16 oscillator is not enabled by hardware when exiting Stop mode with MSI as wake-up clock.
                        B_0x0 = 0x0,
                        ///  HSI16 oscillator is enabled by hardware when exiting Stop mode with MSI as wake-up clock.
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u4,
                ///  HSE clock enable Set and cleared by software. Cleared by hardware to stop the HSE oscillator when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
                HSEON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSE oscillator OFF
                        B_0x0 = 0x0,
                        ///  HSE oscillator ON
                        B_0x1 = 0x1,
                    },
                },
                ///  HSE clock ready flag Set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after 6 HSE clock cycles.
                HSERDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSE oscillator not ready
                        B_0x0 = 0x0,
                        ///  HSE oscillator ready
                        B_0x1 = 0x1,
                    },
                },
                ///  HSE crystal oscillator bypass Set and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device. The HSEBYP bit can be written only if the HSE oscillator is disabled.
                HSEBYP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSE crystal oscillator not bypassed
                        B_0x0 = 0x0,
                        ///  HSE crystal oscillator bypassed with external clock
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock security system enable Set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
                CSSON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Clock security system OFF (clock detector OFF)
                        B_0x0 = 0x0,
                        ///  Clock security system ON (Clock detector ON if the HSE oscillator is stable, OFF if not).
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u4,
                ///  PLL enable Set and cleared by software to enable the PLL. Cleared by hardware when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the PLL clock is used as the system clock.
                PLLON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PLL OFF
                        B_0x0 = 0x0,
                        ///  PLL ON
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL clock ready flag Set by hardware to indicate that the PLL is locked.
                PLLRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PLL unlocked
                        B_0x0 = 0x0,
                        ///  PLL locked
                        B_0x1 = 0x1,
                    },
                },
                padding: u6,
            }),
            ///  Internal clock sources calibration register
            RCC_ICSCR: mmio.Mmio(packed struct(u32) {
                ///  MSI clock calibration These bits are initialized at startup with the factory-programmed MSI calibration trim value. When MSITRIM is written, MSICAL is updated with the sum of MSITRIM and the factory trim value.
                MSICAL: u8,
                ///  MSI clock trimming These bits provide an additional user-programmable trimming value that is added to the MSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the MSI.
                MSITRIM: u8,
                ///  HSI16 clock calibration These bits are initialized at startup with the factory-programmed HSI16 calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
                HSICAL: u8,
                ///  HSI16 clock trimming These bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI16. The default value is 64 when added to the HSICAL value, trim the HSI16 to 161MHz 1 11%.
                HSITRIM: u7,
                padding: u1,
            }),
            ///  Clock configuration register
            RCC_CFGR: mmio.Mmio(packed struct(u32) {
                ///  System clock switch This bitfield is controlled by software and hardware. The bitfield selects the clock for SYSCLK as follows: Others: Reserved The setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, Standby, or Shutdown mode, or when the setting is 001 (HSE selected) and HSE oscillator failure is detected.
                SW: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  MSI
                        B_0x0 = 0x0,
                        ///  HSI16
                        B_0x1 = 0x1,
                        ///  HSE
                        B_0x2 = 0x2,
                        ///  PLLRCLK
                        B_0x3 = 0x3,
                        ///  LSI
                        B_0x4 = 0x4,
                        ///  LSE
                        B_0x5 = 0x5,
                        _,
                    },
                },
                ///  System clock switch status This bitfield is controlled by hardware to indicate the clock source used as system clock: Others: Reserved
                SWS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  MSI
                        B_0x0 = 0x0,
                        ///  HSI16
                        B_0x1 = 0x1,
                        ///  HSE
                        B_0x2 = 0x2,
                        ///  PLLRCLK
                        B_0x3 = 0x3,
                        ///  LSI
                        B_0x4 = 0x4,
                        ///  LSE
                        B_0x5 = 0x5,
                        _,
                    },
                },
                reserved8: u2,
                ///  AHB prescaler This bitfield is controlled by software. To produce HCLK clock, it sets the division factor of SYSCLK clock as follows: 0xxx: 1 Caution: Depending on the device voltage range, the software has to set correctly these bits to ensure that the system frequency does not exceed the maximum allowed frequency (for more details, refer to Section14.1.4: Dynamic voltage scaling management). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value has been taken into account.
                HPRE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  2
                        B_0x8 = 0x8,
                        ///  4
                        B_0x9 = 0x9,
                        ///  8
                        B_0xA = 0xa,
                        ///  16
                        B_0xB = 0xb,
                        ///  64
                        B_0xC = 0xc,
                        ///  128
                        B_0xD = 0xd,
                        ///  256
                        B_0xE = 0xe,
                        ///  512
                        B_0xF = 0xf,
                        _,
                    },
                },
                ///  APB prescaler This bitfield is controlled by software. To produce PCLK clock, it sets the division factor of HCLK clock as follows: 0xx: 1
                PPRE: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  2
                        B_0x4 = 0x4,
                        ///  4
                        B_0x5 = 0x5,
                        ///  8
                        B_0x6 = 0x6,
                        ///  16
                        B_0x7 = 0x7,
                        _,
                    },
                },
                ///  Wake-up from Stop and CSS backup clock selection Set and cleared by software to select the system clock used when exiting Stop mode. The selected clock is also used as emergency clock for the Clock Security System on HSE. Warning: STOPWUCK must not be modified when the Clock Security System is enabled by HSECSSON in RCC_CR register and the system clock is HSE (SWS=10) or a switch on HSE is requested (SW=10).
                STOPWUCK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MSI oscillator selected as wake-up from stop clock and CSS backup clock.
                        B_0x0 = 0x0,
                        ///  HSI16 oscillator selected as wake-up from stop clock and CSS backup clock
                        B_0x1 = 0x1,
                    },
                },
                ///  Microcontroller clock output 2 clock selector This bitfield is controlled by software. It sets the clock selector for MCO2 output as follows: Others: Reserved Note: This clock output may have some truncated cycles at startup or during MCO2 clock source switching.
                MCO2SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  no clock, MCO2 output disabled
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  MSI
                        B_0x2 = 0x2,
                        ///  HSI16
                        B_0x3 = 0x3,
                        ///  HSE
                        B_0x4 = 0x4,
                        ///  PLLRCLK
                        B_0x5 = 0x5,
                        ///  LSI
                        B_0x6 = 0x6,
                        ///  LSE
                        B_0x7 = 0x7,
                        ///  HSI48
                        B_0x8 = 0x8,
                        ///  RTCCLK
                        B_0x9 = 0x9,
                        ///  RTC WAKEUP
                        B_0xA = 0xa,
                        _,
                    },
                },
                ///  Microcontroller clock output 2 prescaler This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO2 output as follows: ... Others: reserved It is highly recommended to set this field before the MCO2 output is enabled.
                MCO2PRE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  1
                        B_0x0 = 0x0,
                        ///  2
                        B_0x1 = 0x1,
                        ///  4
                        B_0x2 = 0x2,
                        ///  128
                        B_0x7 = 0x7,
                        ///  256
                        B_0x8 = 0x8,
                        ///  512
                        B_0x9 = 0x9,
                        ///  1024
                        B_0xA = 0xa,
                        _,
                    },
                },
                ///  Microcontroller clock output clock selector This bitfield is controlled by software. It sets the clock selector for MCO output as follows: Others: Reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
                MCOSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  no clock, MCO output disabled
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  MSI
                        B_0x2 = 0x2,
                        ///  HSI16
                        B_0x3 = 0x3,
                        ///  HSE
                        B_0x4 = 0x4,
                        ///  PLLRCLK
                        B_0x5 = 0x5,
                        ///  LSI
                        B_0x6 = 0x6,
                        ///  LSE
                        B_0x7 = 0x7,
                        ///  HSI48
                        B_0x8 = 0x8,
                        ///  RTCCLK
                        B_0x9 = 0x9,
                        ///  RTC WAKEUP
                        B_0xA = 0xa,
                        _,
                    },
                },
                ///  Microcontroller clock output prescaler This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO output as follows: ... Others: reserved It is highly recommended to set this field before the MCO output is enabled.
                MCOPRE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  1
                        B_0x0 = 0x0,
                        ///  2
                        B_0x1 = 0x1,
                        ///  4
                        B_0x2 = 0x2,
                        ///  128
                        B_0x7 = 0x7,
                        ///  256
                        B_0x8 = 0x8,
                        ///  512
                        B_0x9 = 0x9,
                        ///  1024
                        B_0xA = 0xa,
                        _,
                    },
                },
            }),
            ///  PLL configuration register
            RCC_PLLCFGR: mmio.Mmio(packed struct(u32) {
                ///  PLL input clock source This bit is controlled by software to select PLL clock source, as follows: The bitfield can be written only when the PLL is disabled. When the PLL is not used, selecting 00 allows saving power.
                PLLSRC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No clock
                        B_0x0 = 0x0,
                        ///  MSI
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  HSE
                        B_0x3 = 0x3,
                    },
                },
                reserved4: u2,
                ///  Division factor M of the PLL input clock divider This bit is controlled by software to divide the PLL input clock before the actual phase-locked loop, as follows: The bitfield can be written only when the PLL is disabled. Caution: The software must set these bits so that the PLL input frequency after the /M divider is between 2.66 and 161MHz.
                PLLM: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  1
                        B_0x0 = 0x0,
                        ///  2
                        B_0x1 = 0x1,
                        ///  3
                        B_0x2 = 0x2,
                        ///  4
                        B_0x3 = 0x3,
                        ///  5
                        B_0x4 = 0x4,
                        ///  6
                        B_0x5 = 0x5,
                        ///  7
                        B_0x6 = 0x6,
                        ///  8
                        B_0x7 = 0x7,
                    },
                },
                reserved8: u1,
                ///  PLL frequency multiplication factor N This bit is controlled by software to set the division factor of the f<sub>VCO</sub> feedback divider (that determines the PLL multiplication ratio) as follows: ... ... The bitfield can be written only when the PLL is disabled. Caution: The software must set these bits so that the VCO output frequency is between 96 and 3441MHz.
                PLLN: packed union {
                    raw: u7,
                    value: enum(u7) {
                        ///  Invalid
                        B_0x0 = 0x0,
                        ///  4
                        B_0x4 = 0x4,
                        ///  5
                        B_0x5 = 0x5,
                        ///  126
                        B_0x7E = 0x7e,
                        ///  127
                        B_0x7F = 0x7f,
                        _,
                    },
                },
                reserved16: u1,
                ///  PLLPCLK clock output enable This bit is controlled by software to enable/disable the PLLPCLK clock output of the PLL: Disabling the PLLPCLK clock output, when not used, allows saving power.
                PLLPEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL VCO division factor P for PLLPCLK clock output This bitfield is controlled by software. It sets the PLL VCO division factor P as follows: ... The bitfield can be written only when the PLL is disabled. Caution: The software must set this bitfield so as not to exceed 541MHz on this clock.
                PLLP: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  2
                        B_0x1 = 0x1,
                        ///  32
                        B_0x1F = 0x1f,
                        _,
                    },
                },
                reserved24: u2,
                ///  PLLQCLK clock output enable This bit is controlled by software to enable/disable the PLLQCLK clock output of the PLL: Disabling the PLLQCLK clock output, when not used, allows saving power.
                PLLQEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL VCO division factor Q for PLLQCLK clock output This bitfield is controlled by software. It sets the PLL VCO division factor Q as follows: The bitfield can be written only when the PLL is disabled. Caution: The software must set this bitfield so as not to exceed 541MHz on this clock.
                PLLQ: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  2
                        B_0x1 = 0x1,
                        ///  3
                        B_0x2 = 0x2,
                        ///  4
                        B_0x3 = 0x3,
                        ///  5
                        B_0x4 = 0x4,
                        ///  6
                        B_0x5 = 0x5,
                        ///  7
                        B_0x6 = 0x6,
                        ///  8
                        B_0x7 = 0x7,
                        _,
                    },
                },
                ///  PLLRCLK clock output enable This bit is controlled by software to enable/disable the PLLRCLK clock output of the PLL: This bit cannot be written when PLLRCLK output of the PLL is selected for system clock. Disabling the PLLRCLK clock output, when not used, allows saving power.
                PLLREN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL VCO division factor R for PLLRCLK clock output This bitfield is controlled by software. It sets the PLL VCO division factor R as follows: The bitfield can be written only when the PLL is disabled. The PLLRCLK clock can be selected as system clock. Caution: The software must set this bitfield so as not to exceed 122MHz on this clock.
                PLLR: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  2
                        B_0x1 = 0x1,
                        ///  3
                        B_0x2 = 0x2,
                        ///  4
                        B_0x3 = 0x3,
                        ///  5
                        B_0x4 = 0x4,
                        ///  6
                        B_0x5 = 0x5,
                        ///  7
                        B_0x6 = 0x6,
                        ///  8
                        B_0x7 = 0x7,
                        _,
                    },
                },
            }),
            reserved24: [8]u8,
            ///  Clock interrupt enable register
            RCC_CIER: mmio.Mmio(packed struct(u32) {
                ///  LSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:
                LSIRDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:
                LSERDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the MSI oscillator stabilization.
                MSIRDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MSI ready interrupt disabled
                        B_0x0 = 0x0,
                        ///  MSI ready interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI16 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization:
                HSIRDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  HSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:
                HSERDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL ready interrupt enable Set and cleared by software to enable/disable interrupt caused by PLL lock:
                PLLRDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u3,
                ///  LSE clock security system interrupt enable Set and cleared by software to enable/disable interrupt caused by the clock security system on LSE.
                LSECSSIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Clock security interrupt caused by LSE clock failure disabled
                        B_0x0 = 0x0,
                        ///  Clock security interrupt caused by LSE clock failure enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI48 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the internal HSI48 oscillator.
                HSI48RDYIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  HSI48 ready interrupt disabled
                        B_0x0 = 0x0,
                        ///  HSI48 ready interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u21,
            }),
            ///  Clock interrupt flag register
            RCC_CIFR: mmio.Mmio(packed struct(u32) {
                ///  LSI ready interrupt flag Set by hardware when the LSI clock becomes stable and LSIRDYDIE is set. Cleared by software setting the LSIRDYC bit.
                LSIRDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by the LSI oscillator
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by the LSI oscillator
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE ready interrupt flag Set by hardware when the LSE clock becomes stable and LSERDYDIE is set. Cleared by software setting the LSERDYC bit.
                LSERDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by the LSE oscillator
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by the LSE oscillator
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI ready interrupt flag Set by hardware when the MSI clock becomes stable and MSIRDYDIE is set. Cleared by software setting the MSIRDYC bit.
                MSIRDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by the MSI oscillator
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by the MSI oscillator
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI16 ready interrupt flag Set by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in a response to setting the HSION (refer to Clock control register (RCC_CR)). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. Cleared by software setting the HSIRDYC bit.
                HSIRDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by the HSI16 oscillator
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by the HSI16 oscillator
                        B_0x1 = 0x1,
                    },
                },
                ///  HSE ready interrupt flag Set by hardware when the HSE clock becomes stable and HSERDYIE is set. Cleared by software setting the HSERDYC bit.
                HSERDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by the HSE oscillator
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by the HSE oscillator
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL ready interrupt flag Set by hardware when the PLL locks and PLLRDYIE is set. Cleared by software setting the PLLRDYC bit.
                PLLRDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by PLL lock
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by PLL lock
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u2,
                ///  HSE clock security system interrupt flag Set by hardware when a failure is detected in the HSE oscillator. Cleared by software setting the CSSC bit.
                CSSF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock security interrupt caused by HSE clock failure
                        B_0x0 = 0x0,
                        ///  Clock security interrupt caused by HSE clock failure
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE clock security system interrupt flag Set by hardware when a failure is detected in the LSE oscillator. Cleared by software by setting the LSECSSC bit.
                LSECSSF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock security interrupt caused by LSE clock failure
                        B_0x0 = 0x0,
                        ///  Clock security interrupt caused by LSE clock failure
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI48 ready interrupt flag Set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set in a response to setting the HSI48ON (refer to RCC clock recovery RC register (RCC_CRRCR)). Cleared by software setting the HSI48RDYC bit.
                HSI48RDYF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No clock ready interrupt caused by the HSI48 oscillator
                        B_0x0 = 0x0,
                        ///  Clock ready interrupt caused by the HSI48 oscillator
                        B_0x1 = 0x1,
                    },
                },
                padding: u21,
            }),
            ///  Clock interrupt clear register
            RCC_CICR: mmio.Mmio(packed struct(u32) {
                ///  LSI ready interrupt clear This bit is set by software to clear the LSIRDYF flag.
                LSIRDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear LSIRDYF flag
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE ready interrupt clear This bit is set by software to clear the LSERDYF flag.
                LSERDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear LSERDYF flag
                        B_0x1 = 0x1,
                    },
                },
                ///  MSI ready interrupt clear This bit is set by software to clear the MSIRDYF flag.
                MSIRDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  MSIRDYF cleared
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI16 ready interrupt clear This bit is set software to clear the HSIRDYF flag.
                HSIRDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear HSIRDYF flag
                        B_0x1 = 0x1,
                    },
                },
                ///  HSE ready interrupt clear This bit is set by software to clear the HSERDYF flag.
                HSERDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear HSERDYF flag
                        B_0x1 = 0x1,
                    },
                },
                ///  PLL ready interrupt clear This bit is set by software to clear the PLLRDYF flag.
                PLLRDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear PLLRDYF flag
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u2,
                ///  Clock security system interrupt clear This bit is set by software to clear the HSECSSF flag.
                CSSC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear CSSF flag
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE Clock security system interrupt clear This bit is set by software to clear the LSECSSF flag.
                LSECSSC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear LSECSSF flag
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI48 oscillator ready interrupt clear This bit is set by software to clear the HSI48RDYF flag.
                HSI48RDYC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear the HSI48RDYC flag
                        B_0x1 = 0x1,
                    },
                },
                padding: u21,
            }),
            reserved40: [4]u8,
            ///  AHB peripheral reset register
            RCC_AHBRSTR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 and DMAMUX reset Set and cleared by software.
                DMA1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset DMA1 and DMAMUX
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA2 and DMAMUX reset Set and cleared by software.
                DMA2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset DMA2 and DMAMUX
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u6,
                ///  Flash memory interface reset Set and cleared by software. This bit can only be set when the flash memory is in power down mode.
                FLASHRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset flash memory interface
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u3,
                ///  CRC reset Set and cleared by software.
                CRCRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset CRC
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u3,
                ///  AES hardware accelerator reset Set and cleared by software.
                AESRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset AES
                        B_0x1 = 0x1,
                    },
                },
                reserved18: u1,
                ///  Random number generator reset Set and cleared by software.
                RNGRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset RNG
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u5,
                ///  Touch sensing controller reset Set and cleared by software.
                TSCRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TSC
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            ///  I/O port reset register
            RCC_IOPRSTR: mmio.Mmio(packed struct(u32) {
                ///  I/O port A reset This bit is set and cleared by software.
                GPIOARST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no effect
                        B_0x0 = 0x0,
                        ///  Reset I/O port A
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port B reset This bit is set and cleared by software.
                GPIOBRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no effect
                        B_0x0 = 0x0,
                        ///  Reset I/O port B
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port C reset This bit is set and cleared by software.
                GPIOCRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no effect
                        B_0x0 = 0x0,
                        ///  Reset I/O port C
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port D reset This bit is set and cleared by software.
                GPIODRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no effect
                        B_0x0 = 0x0,
                        ///  Reset I/O port D
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port E reset This bit is set and cleared by software.
                GPIOERST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no effect
                        B_0x0 = 0x0,
                        ///  Reset I/O port E
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port F reset This bit is set and cleared by software.
                GPIOFRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  no effect
                        B_0x0 = 0x0,
                        ///  Reset I/O port F
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            reserved56: [8]u8,
            ///  APB peripheral reset register 1
            RCC_APBRSTR1: mmio.Mmio(packed struct(u32) {
                ///  TIM2 timer reset Set and cleared by software.
                TIM2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM2
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM3 timer reset Set and cleared by software.
                TIM3RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM3
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u2,
                ///  TIM6 timer reset Set and cleared by software.
                TIM6RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM6
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM7 timer reset Set and cleared by software.
                TIM7RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM7
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  LPUART2 reset Set and cleared by software.
                LPUART2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LPUART2
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u1,
                ///  LCD reset<sup>(1)</sup> Set and cleared by software.
                LCDRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LCD
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u2,
                ///  LPUART3 reset<sup>(1)</sup> Set and cleared by software.
                LPUART3RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LPUART3
                        B_0x1 = 0x1,
                    },
                },
                ///  USB reset<sup>(1)</sup> Set and cleared by software.
                USBRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset USB
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI2 reset Set and cleared by software.
                SPI2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset SPI2
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI3 reset<sup>(1)</sup> Set and cleared by software.
                SPI3RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset SPI3
                        B_0x1 = 0x1,
                    },
                },
                ///  CRS reset<sup>(1)</sup> Set and cleared by software.
                CRSRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset CRS
                        B_0x1 = 0x1,
                    },
                },
                ///  USART2 reset Set and cleared by software.
                USART2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset USART2
                        B_0x1 = 0x1,
                    },
                },
                ///  USART3 reset Set and cleared by software.
                USART3RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset USART3
                        B_0x1 = 0x1,
                    },
                },
                ///  USART4 reset Set and cleared by software.
                USART4RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset USART4
                        B_0x1 = 0x1,
                    },
                },
                ///  LPUART1 reset Set and cleared by software.
                LPUART1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LPUART1
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C1 reset Set and cleared by software.
                I2C1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset I2C1
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C2 reset Set and cleared by software.
                I2C2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset I2C2
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C3 reset Set and cleared by software.
                I2C3RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset I2C3
                        B_0x1 = 0x1,
                    },
                },
                ///  OPAMP reset Set and cleared by software.
                OPAMPRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset the OPAMP
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C4 reset<sup>(1)</sup> Set and cleared by software.
                I2C4RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset I2C4
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM3 reset Set and cleared by software.
                LPTIM3RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LPTIM3
                        B_0x1 = 0x1,
                    },
                },
                reserved28: u1,
                ///  Power interface reset Set and cleared by software.
                PWRRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset PWR
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC1 interface reset Set and cleared by software.
                DAC1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset DAC1 interface
                        B_0x1 = 0x1,
                    },
                },
                ///  Low Power Timer 2 reset Set and cleared by software.
                LPTIM2RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LPTIM2
                        B_0x1 = 0x1,
                    },
                },
                ///  Low Power Timer 1 reset Set and cleared by software.
                LPTIM1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset LPTIM1
                        B_0x1 = 0x1,
                    },
                },
            }),
            reserved64: [4]u8,
            ///  APB peripheral reset register 2
            RCC_APBRSTR2: mmio.Mmio(packed struct(u32) {
                ///  SYSCFG, COMP and VREFBUF reset Set and cleared by software.
                SYSCFGRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset SYSCFG + COMP + VREFBUF
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u10,
                ///  TIM1 timer reset Set and cleared by software.
                TIM1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM1 timer
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI1 reset Set and cleared by software.
                SPI1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset SPI1
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  USART1 reset Set and cleared by software.
                USART1RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset USART1
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u1,
                ///  TIM15 timer reset Set and cleared by software.
                TIM15RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM15 timer
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM16 timer reset Set and cleared by software.
                TIM16RST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset TIM16 timer
                        B_0x1 = 0x1,
                    },
                },
                reserved20: u2,
                ///  ADC reset Set and cleared by software.
                ADCRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset ADC
                        B_0x1 = 0x1,
                    },
                },
                padding: u11,
            }),
            reserved72: [4]u8,
            ///  AHB peripheral clock enable register
            RCC_AHBENR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 and DMAMUX clock enable Set and cleared by software. DMAMUX is enabled as long as at least one DMA peripheral is enabled.
                DMA1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA2 and DMAMUX clock enable Set and cleared by software. DMAMUX is enabled as long as at least one DMA peripheral is enabled.
                DMA2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u6,
                ///  Flash memory interface clock enable Set and cleared by software. This bit can only be cleared when the flash memory is in power down mode.
                FLASHEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u3,
                ///  CRC clock enable Set and cleared by software.
                CRCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u3,
                ///  AES hardware accelerator Set and cleared by software.
                AESEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved18: u1,
                ///  Random number generator clock enable Set and cleared by software.
                RNGEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u5,
                ///  Touch sensing controller clock enable Set and cleared by software.
                TSCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TSC clock disable
                        B_0x0 = 0x0,
                        ///  TSC clock enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            ///  I/O port clock enable register
            RCC_IOPENR: mmio.Mmio(packed struct(u32) {
                ///  I/O port A clock enable This bit is set and cleared by software.
                GPIOAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port B clock enable This bit is set and cleared by software.
                GPIOBEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port C clock enable This bit is set and cleared by software.
                GPIOCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port D clock enable This bit is set and cleared by software.
                GPIODEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port E clock enable<sup>(1)</sup> This bit is set and cleared by software.
                GPIOEEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port F clock enable This bit is set and cleared by software.
                GPIOFEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            ///  Debug configuration register
            RCC_DBGCFGR: mmio.Mmio(packed struct(u32) {
                ///  Debug support clock enable Set and cleared by software.
                DBGEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Debug support reset Set and cleared by software.
                DBGRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset DBG
                        B_0x1 = 0x1,
                    },
                },
                padding: u30,
            }),
            reserved88: [4]u8,
            ///  APB peripheral clock enable register 1
            RCC_APBENR1: mmio.Mmio(packed struct(u32) {
                ///  TIM2 timer clock enable Set and cleared by software.
                TIM2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM3 timer clock enable Set and cleared by software.
                TIM3EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u2,
                ///  TIM6 timer clock enable Set and cleared by software.
                TIM6EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM7 timer clock enable Set and cleared by software.
                TIM7EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  LPUART2 clock enable Set and cleared by software.
                LPUART2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u1,
                ///  LCD clock enable<sup>(1)</sup> Set and cleared by software.
                LCDEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  RTC APB clock enable Set and cleared by software.
                RTCAPBEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  WWDG clock enable Set by software to enable the window watchdog clock. Cleared by hardware system reset This bit can also be set by hardware if the WWDG_SW option bit is 0.
                WWDGEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPUART3 clock enable Set and cleared by software.
                LPUART3EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USB clock enable<sup>(1)</sup> Set and cleared by software.
                USBEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI2 clock enable Set and cleared by software.
                SPI2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI3 clock enable<sup>(1)</sup> Set and cleared by software.
                SPI3EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  CRS clock enable<sup>(1)</sup> Set and cleared by software.
                CRSEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USART2 clock enable Set and cleared by software.
                USART2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USART3 clock enable Set and cleared by software.
                USART3EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USART4 clock enable Set and cleared by software.
                USART4EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPUART1 clock enable Set and cleared by software.
                LPUART1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C1 clock enable Set and cleared by software.
                I2C1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C2 clock enable Set and cleared by software.
                I2C2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C3 clock enable Set and cleared by software.
                I2C3EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  OPAMP clock enable Set and cleared by software.
                OPAMPEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C4EN clock enable<sup>(1)</sup> Set and cleared by software.
                I2C4EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM3 clock enable Set and cleared by software.
                LPTIM3EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved28: u1,
                ///  Power interface clock enable Set and cleared by software.
                PWREN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC1 interface clock enable Set and cleared by software.
                DAC1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM2 clock enable Set and cleared by software.
                LPTIM2EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPTIM1 clock enable Set and cleared by software.
                LPTIM1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
            }),
            reserved96: [4]u8,
            ///  APB peripheral clock enable register 2
            RCC_APBENR2: mmio.Mmio(packed struct(u32) {
                ///  SYSCFG, COMP and VREFBUF clock enable Set and cleared by software.
                SYSCFGEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u10,
                ///  TIM1 timer clock enable Set and cleared by software.
                TIM1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI1 clock enable Set and cleared by software.
                SPI1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  USART1 clock enable Set and cleared by software.
                USART1EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u1,
                ///  TIM15 timer clock enable Set and cleared by software.
                TIM15EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM16 timer clock enable Set and cleared by software.
                TIM16EN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved20: u2,
                ///  ADC clock enable Set and cleared by software.
                ADCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u11,
            }),
            reserved104: [4]u8,
            ///  AHB peripheral clock enable in Sleep/Stop mode register
            RCC_AHBSMENR: mmio.Mmio(packed struct(u32) {
                ///  DMA1 and DMAMUX clock enable during Sleep mode Set and cleared by software. Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
                DMA1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA2 and DMAMUX clock enable during Sleep mode Set and cleared by software. Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
                DMA2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u6,
                ///  Flash memory interface clock enable during Sleep mode Set and cleared by software. This bit can be activated only when the flash memory is in power down mode.
                FLASHSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SRAM clock enable during Sleep mode Set and cleared by software.
                SRAMSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved12: u2,
                ///  CRC clock enable during Sleep mode Set and cleared by software.
                CRCSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u3,
                ///  AES hardware accelerator clock enable during Sleep mode Set and cleared by software.
                AESSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved18: u1,
                ///  RNG clock enable during Sleep and Stop mode Set and cleared by software.
                RNGSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u5,
                ///  TSC clock enable during Sleep and Stop mode Set and cleared by software.
                TSCSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            ///  I/O port in Sleep mode clock enable register
            RCC_IOPSMENR: mmio.Mmio(packed struct(u32) {
                ///  I/O port A clock enable during Sleep mode Set and cleared by software.
                GPIOASMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port B clock enable during Sleep mode Set and cleared by software.
                GPIOBSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port C clock enable during Sleep mode Set and cleared by software.
                GPIOCSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port D clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
                GPIODSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port E clock enable during Sleep mode Set and cleared by software.
                GPIOESMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O port F clock enable during Sleep mode Set and cleared by software.
                GPIOFSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            reserved120: [8]u8,
            ///  APB peripheral clock enable in Sleep/Stop mode register 1
            RCC_APBSMENR1: mmio.Mmio(packed struct(u32) {
                ///  TIM2 timer clock enable during Sleep mode Set and cleared by software.
                TIM2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM3 timer clock enable during Sleep mode Set and cleared by software.
                TIM3SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u2,
                ///  TIM6 timer clock enable during Sleep mode Set and cleared by software.
                TIM6SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM7 timer clock enable during Sleep mode Set and cleared by software.
                TIM7SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  LPUART2 clock enable during Sleep and Stop modes Set and cleared by software.
                LPUART2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u1,
                ///  LCD clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
                LCDSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  RTC APB clock enable during Sleep mode Set and cleared by software.
                RTCAPBSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  WWDG clock enable during Sleep and Stop modes Set and cleared by software.
                WWDGSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPUART3 clock enable during Sleep and Stop modes Set and cleared by software.
                LPUART3SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USB clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
                USBSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI2 clock enable during Sleep mode Set and cleared by software.
                SPI2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI3 clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
                SPI3SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  CRS clock enable during Sleep and Stop modes<sup>(1)</sup> Set and cleared by software.
                CRSSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USART2 clock enable during Sleep and Stop modes Set and cleared by software.
                USART2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USART3 clock enable during Sleep mode Set and cleared by software.
                USART3SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  USART4 clock enable during Sleep mode Set and cleared by software.
                USART4SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LPUART1 clock enable during Sleep and Stop modes Set and cleared by software.
                LPUART1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C1 clock enable during Sleep and Stop modes Set and cleared by software.
                I2C1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C2 clock enable during Sleep mode Set and cleared by software.
                I2C2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C3 clock enable during Sleep mode Set and cleared by software.
                I2C3SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  OPAMP clock enable during Sleep and Stop modes Set and cleared by software.
                OPAMPSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  I2C4 clock enable during Sleep mode<sup>(1)</sup> Set and cleared by software.
                I2C4SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Low power timer 3 clock enable during Sleep mode Set and cleared by software.
                LPTIM3SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved28: u1,
                ///  Power interface clock enable during Sleep mode Set and cleared by software.
                PWRSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  DAC1 interface clock enable during Sleep and Stop modes Set and cleared by software.
                DAC1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Low Power Timer 2 clock enable during Sleep and Stop modes Set and cleared by software.
                LPTIM2SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Low Power Timer 1 clock enable during Sleep and Stop modes Set and cleared by software.
                LPTIM1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
            }),
            reserved128: [4]u8,
            ///  APB peripheral clock enable in Sleep/Stop mode register 2
            RCC_APBSMENR2: mmio.Mmio(packed struct(u32) {
                ///  SYSCFG, COMP and VREFBUF clock enable during Sleep and Stop modes Set and cleared by software.
                SYSCFGSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u10,
                ///  TIM1 timer clock enable during Sleep mode Set and cleared by software.
                TIM1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI1 clock enable during Sleep mode Set and cleared by software.
                SPI1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  USART1 clock enable during Sleep and Stop modes Set and cleared by software.
                USART1SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u1,
                ///  TIM15 timer clock enable during Sleep mode Set and cleared by software.
                TIM15SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM16 timer clock enable during Sleep mode Set and cleared by software.
                TIM16SMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved20: u2,
                ///  ADC clock enable during Sleep mode Set and cleared by software.
                ADCSMEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u11,
            }),
            reserved136: [4]u8,
            ///  Peripherals independent clock configuration register
            RCC_CCIPR: mmio.Mmio(packed struct(u32) {
                ///  USART1 clock source selection This bitfield is controlled by software to select USART1 clock source as follows:
                USART1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  USART2 clock source selection This bitfield is controlled by software to select USART2 clock source as follows:
                USART2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                reserved6: u2,
                ///  LPUART3 clock source selection<sup>(1)</sup> This bitfield is controlled by software to select LPUART3 clock source as follows:
                LPUART3SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  LPUART2 clock source selection This bitfield is controlled by software to select LPUART2 clock source as follows:
                LPUART2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  LPUART1 clock source selection This bitfield is controlled by software to select LPUART1 clock source as follows:
                LPUART1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  I2C1 clock source selection This bitfield is controlled by software to select I2C1 clock source as follows:
                I2C1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved16: u2,
                ///  I2C3 clock source selection This bitfield is controlled by software to select I2C3 clock source as follows:
                I2C3SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  SYSCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  LPTIM1 clock source selection This bitfield is controlled by software to select LPTIM1 clock source as follows:
                LPTIM1SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  LSI
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  LPTIM2 clock source selection This bitfield is controlled by software to select LPTIM2 clock source as follows:
                LPTIM2SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  LSI
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  LPTIM3 clock source selection This bitfield is controlled by software to select LPTIM3 clock source as follows:
                LPTIM3SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PCLK
                        B_0x0 = 0x0,
                        ///  LSI
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                    },
                },
                ///  TIM1 clock source selection This bit is set and cleared by software. It selects TIM1 clock source as follows:
                TIM1SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMPCLK
                        B_0x0 = 0x0,
                        ///  PLLQCLK
                        B_0x1 = 0x1,
                    },
                },
                ///  TIM15 clock source selection This bit is set and cleared by software. It selects TIM15 clock source as follows:
                TIM15SEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMPCLK
                        B_0x0 = 0x0,
                        ///  PLLQCLK
                        B_0x1 = 0x1,
                    },
                },
                ///  481MHz clock source selection This bitfield is controlled by software to select the 481MHz clock source used by the USB FS and the RNG:
                CLK48SEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No clock
                        B_0x0 = 0x0,
                        ///  MSI
                        B_0x1 = 0x1,
                        ///  PLLQCLK
                        B_0x2 = 0x2,
                        ///  HSI48<sup>(1)</sup>
                        B_0x3 = 0x3,
                    },
                },
                ///  ADCs clock source selection This bitfield is controlled by software to select the clock source for ADC:
                ADCSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  System clock
                        B_0x0 = 0x0,
                        ///  PLLPCLK
                        B_0x1 = 0x1,
                        ///  HSI16
                        B_0x2 = 0x2,
                        _,
                    },
                },
                padding: u2,
            }),
            reserved144: [4]u8,
            ///  RTC domain control register
            RCC_BDCR: mmio.Mmio(packed struct(u32) {
                ///  LSE oscillator enable Set and cleared by software to enable LSE oscillator:
                LSEON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE oscillator ready Set and cleared by hardware to indicate when the external 321kHz oscillator is ready (stable): After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
                LSERDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not ready
                        B_0x0 = 0x0,
                        ///  Ready
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE oscillator bypass Set and cleared by software to bypass the LSE oscillator (in debug mode). This bit can be written only when the external 321kHz oscillator is disabled (LSEON=0 and LSERDY=0).
                LSEBYP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not bypassed
                        B_0x0 = 0x0,
                        ///  Bypassed
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE oscillator drive capability Set by software to select the LSE oscillator drive capability as follows: Applicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode.
                LSEDRV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  low driving capability
                        B_0x0 = 0x0,
                        ///  medium-low driving capability
                        B_0x1 = 0x1,
                        ///  medium-high driving capability
                        B_0x2 = 0x2,
                        ///  high driving capability
                        B_0x3 = 0x3,
                    },
                },
                ///  CSS on LSE enable Set by software to enable the clock security system on LSE (321kHz) oscillator as follows: LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD =1). In that case the software must disable the LSECSSON bit.
                LSECSSON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  CSS on LSE failure Detection Set by hardware to indicate when a failure is detected by the clock security system on the external 321kHz oscillator (LSE):
                LSECSSD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No failure detected
                        B_0x0 = 0x0,
                        ///  Failure detected
                        B_0x1 = 0x1,
                    },
                },
                ///  LSE clock enable for system usage This bit must be set by software to enable the LSE clock for a system usage.
                LSESYSEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enabled, LSE distributed to peripherals including LSCO/MCO/SYSCLK.
                        B_0x1 = 0x1,
                    },
                },
                ///  RTC clock source selection Set by software to select the clock source for the RTC as follows: Once the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The BDRST bit can be used to reset this bitfield to 00.
                RTCSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No clock
                        B_0x0 = 0x0,
                        ///  LSE
                        B_0x1 = 0x1,
                        ///  LSI
                        B_0x2 = 0x2,
                        ///  HSE divided by 32
                        B_0x3 = 0x3,
                    },
                },
                reserved11: u1,
                ///  LSE clock ready for system usage This flag is set by hardware to indicate that the LSE clock is ready for being used by the system (see LSESYSEN bit). This flag is set when LSE clock is ready (LSEON1=11 and LSERDY1=11) and two LSE clock cycles after that LSESYSEN is set. Cleared by hardware to indicate that the LSE clock is not ready to be used by the system.
                LSESYSRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LSE clock not ready for system
                        B_0x0 = 0x0,
                        ///  LSE clock ready for system
                        B_0x1 = 0x1,
                    },
                },
                reserved15: u3,
                ///  RTC clock enable Set and cleared by software. The bit enables clock to RTC and TAMP.
                RTCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  RTC domain software reset Set and cleared by software to reset the RTC domain:
                BDRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Reset
                        B_0x1 = 0x1,
                    },
                },
                reserved24: u7,
                ///  Low-speed clock output (LSCO) enable Set and cleared by software.
                LSCOEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Low-speed clock output selection Set and cleared by software to select the low-speed output clock:
                LSCOSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LSI
                        B_0x0 = 0x0,
                        ///  LSE
                        B_0x1 = 0x1,
                    },
                },
                padding: u6,
            }),
            ///  Control/status register
            RCC_CSR: mmio.Mmio(packed struct(u32) {
                ///  LSI oscillator enable Set and cleared by software to enable/disable the LSI oscillator:
                LSION: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  LSI oscillator ready Set and cleared by hardware to indicate when the LSI oscillator is ready (stable): After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
                LSIRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Not ready
                        B_0x0 = 0x0,
                        ///  Ready
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal low-speed oscillator pre-divided by 128 Set and reset by hardware to indicate when the low-speed internal RC oscillator has to be divided by 128. The software has to switch off the LSI before changing this bit.
                LSIPREDIV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LSI RC oscillator is not divided
                        B_0x0 = 0x0,
                        ///  LSI RC oscillator is divided by 128
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u5,
                ///  MSI range after Standby mode Set by software to chose the MSI frequency at startup. This range is used after exiting Standby mode until MSIRGSEL is set. After a pad or a power-on reset, the range is always 41MHz. MSISRANGE[3:0] can be written only when MSIRGSEL1=11. Others: Reserved Note: Changing the MSISRANGE[3:0] does not change the current MSI frequency.
                MSISRANGE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Range 7 around 81MHz
                        B_0x4 = 0x4,
                        _,
                    },
                },
                reserved23: u11,
                ///  Remove reset flags Set by software to clear the reset flags.
                RMVF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clear reset flags
                        B_0x1 = 0x1,
                    },
                },
                reserved25: u1,
                ///  Option byte loader reset flag Set by hardware when a reset from the Option byte loading occurs. Cleared by setting the RMVF bit.
                OBLRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No reset from Option byte loading occurred
                        B_0x0 = 0x0,
                        ///  Reset from Option byte loading occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Pin reset flag Set by hardware when a reset from the NRST pin occurs. Cleared by setting the RMVF bit.
                PINRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No reset from NRST pin occurred
                        B_0x0 = 0x0,
                        ///  Reset from NRST pin occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  BOR or POR/PDR flag Set by hardware when a BOR or POR/PDR occurs. Cleared by setting the RMVF bit.
                PWRRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No BOR or POR occurred
                        B_0x0 = 0x0,
                        ///  BOR or POR occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Software reset flag Set by hardware when a software reset occurs. Cleared by setting the RMVF bit.
                SFTRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No software reset occurred
                        B_0x0 = 0x0,
                        ///  Software reset occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Independent window watchdog reset flag Set by hardware when an independent watchdog reset domain occurs. Cleared by setting the RMVF bit.
                IWDGRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No independent watchdog reset occurred
                        B_0x0 = 0x0,
                        ///  Independent watchdog reset occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Window watchdog reset flag Set by hardware when a window watchdog reset occurs. Cleared by setting the RMVF bit.
                WWDGRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No window watchdog reset occurred
                        B_0x0 = 0x0,
                        ///  Window watchdog reset occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Low-power reset flag Set by hardware when a reset occurs due to illegal Stop, Standby, or Shutdown mode entry. Cleared by setting the RMVF bit. This operates only if nRST_STOP, nRST_STDBY or nRST_SHDW option bits are cleared.
                LPWRRSTF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No illegal mode reset occurred
                        B_0x0 = 0x0,
                        ///  Illegal mode reset occurred
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RCC clock recovery RC register
            RCC_CRRCR: mmio.Mmio(packed struct(u32) {
                ///  HSI48 RC oscillator enable<sup>(1)</sup>
                HSI48ON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  HSI48 clock ready flag<sup>(1)</sup> The flag is set when the HSI48 clock is ready for use.
                HSI48RDY: u1,
                reserved7: u5,
                ///  HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value.
                HSI48CAL: u9,
                padding: u16,
            }),
        };

        ///  RNG address block description
        pub const RNG = extern struct {
            ///  RNG control register
            RNG_CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  True random number generator enable
                RNGEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  True random number generator is disabled. Analog noise sources are powered off and logic clocked by the RNG clock is gated.
                        B_0x0 = 0x0,
                        ///  True random number generator is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Interrupt enable
                IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RNG interrupt is disabled
                        B_0x0 = 0x0,
                        ///  RNG interrupt is enabled. An interrupt is pending as soon as DRDY1=11, SEIS1=11 or CEIS1=11 in the RNG_SR register.
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u1,
                ///  Clock error detection The clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, that is to enable or disable CED, the RNG must be disabled. Writing this bit is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
                CED: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Clock error detection enabled
                        B_0x0 = 0x0,
                        ///  Clock error detection is disabled
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u1,
                ///  Auto reset disable When auto-reset is enabled the application still need to clear the SEIS bit after a noise source error. Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
                ARDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When a noise source error occurs RNG performs an automatic reset to clear the SECS bit.
                        B_0x0 = 0x0,
                        ///  When a noise source error occurs the application must reset RNG by writing CONDRST to 1 then to 0, in order to restart random number generation.
                        B_0x1 = 0x1,
                    },
                },
                ///  RNG configuration 3 Reserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details. If the NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG.
                RNG_CONFIG3: u4,
                ///  NIST custom two conditioning loops are performed and 256 bits of noise source are used. Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
                NISTC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Hardware default values for NIST compliant RNG. In this configuration per 128-bit output
                        B_0x0 = 0x0,
                        ///  Custom values for NIST compliant RNG. See Section120.6: RNG entropy source validation for proposed configuration.
                        B_0x1 = 0x1,
                    },
                },
                ///  RNG configuration 2 Reserved to the RNG configuration (bitfield 2). Bit 13 can be set when RNG power consumption is critical. See Section120.3.8: RNG low-power use. Refer to the RNG_CONFIG1 bitfield for details.
                RNG_CONFIG2: u3,
                ///  Clock divider factor This value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN1=10). ... Writing these bits is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
                CLKDIV: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  internal RNG clock after divider is similar to incoming RNG clock.
                        B_0x0 = 0x0,
                        ///  two RNG clock cycles per internal RNG clock.
                        B_0x1 = 0x1,
                        ///  2<sup>2</sup> (= 4) RNG clock cycles per internal RNG clock.
                        B_0x2 = 0x2,
                        ///  2<sup>15</sup> RNG clock cycles per internal clock (for example. an incoming 481MHz RNG clock becomes a 1.51kHz internal RNG clock)
                        B_0xF = 0xf,
                        _,
                    },
                },
                ///  RNG configuration 1 Reserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section120.6: RNG entropy source validation. Writing any bit of RNG_CONFIG1 is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11.
                RNG_CONFIG1: u6,
                reserved30: u4,
                ///  Conditioning soft reset Write 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_HTCR are not changed by CONDRST. This bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written. When CONDRST is set to 0 by the software, its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles.
                CONDRST: u1,
                ///  RNG Config lock This bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset.
                CONFIGLOCK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Writes to the RNG_HTCR and RNG_CR configuration bits [29:4] are allowed.
                        B_0x0 = 0x0,
                        ///  Writes to the RNG_HTCR and RNG_CR configuration bits [29:4] are ignored until the next RNG reset.
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RNG status register
            RNG_SR: mmio.Mmio(packed struct(u32) {
                ///  Data ready Once the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated. Note: The DRDY bit can rise when the peripheral is disabled (RNGEN1=10 in the RNG_CR register). If IE=1 in the RNG_CR register, an interrupt is generated when DRDY1=11.
                DRDY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The RNG_DR register is not yet valid, no random data is available.
                        B_0x0 = 0x0,
                        ///  The RNG_DR register contains valid random data.
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock error current status Note: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0.
                CECS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The RNG clock is correct (f<sub>RNGCLK</sub>> f<sub>HCLK</sub>/32). If the CEIS bit is set, this means that a slow clock was detected and the situation has been recovered.
                        B_0x0 = 0x0,
                        ///  The RNG clock is too slow (f<sub>RNGCLK</sub>< f<sub>HCLK</sub>/32).
                        B_0x1 = 0x1,
                    },
                },
                ///  Seed error current status Runtime repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10) Startup or continuous adaptive proportion test on noise source failed. Startup post-processing/conditioning sanity check failed.
                SECS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No faulty sequence has currently been detected. If the SEIS bit is set, this means that a faulty sequence was detected and the situation has been recovered.
                        B_0x0 = 0x0,
                        ///  At least one of the following faulty sequences has been detected:
                        B_0x1 = 0x1,
                    },
                },
                reserved5: u2,
                ///  Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect. An interrupt is pending if IE = 1 in the RNG_CR register.
                CEIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The RNG clock is correct (f<sub>RNGCLK</sub>> f<sub>HCLK</sub>/32)
                        B_0x0 = 0x0,
                        ///  The RNG clock before the internal divider is detected too slow (f<sub>RNGCLK</sub>< f<sub>HCLK</sub>/32)
                        B_0x1 = 0x1,
                    },
                },
                ///  Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect. An interrupt is pending if IE = 1 in the RNG_CR register.
                SEIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No faulty sequence detected
                        B_0x0 = 0x0,
                        ///  At least one faulty sequence is detected. See SECS bit description for details.
                        B_0x1 = 0x1,
                    },
                },
                padding: u25,
            }),
            ///  RNG data register
            RNG_DR: mmio.Mmio(packed struct(u32) {
                ///  Random data 32-bit random data, which are valid when DRDY1=11. When DRDY1=10, the RNDATA value is1zero. When DRDY is set, it is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event).
                RNDATA: u32,
            }),
            reserved16: [4]u8,
            ///  RNG health test control register
            RNG_HTCR: mmio.Mmio(packed struct(u32) {
                ///  health test configuration This configuration is used by RNG to configure the health tests. See Section120.6: RNG entropy source validation for the recommended value. Note: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written.
                HTCFG: u32,
            }),
        };

        ///  RTC register block
        pub const RTC = extern struct {
            ///  RTC time register
            RTC_TR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format
                SU: u4,
                ///  Second tens in BCD format
                ST: u3,
                reserved8: u1,
                ///  Minute units in BCD format
                MNU: u4,
                ///  Minute tens in BCD format
                MNT: u3,
                reserved16: u1,
                ///  Hour units in BCD format
                HU: u4,
                ///  Hour tens in BCD format
                HT: u2,
                ///  AM/PM notation
                PM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AM or 24-hour format
                        B_0x0 = 0x0,
                        ///  PM
                        B_0x1 = 0x1,
                    },
                },
                padding: u9,
            }),
            ///  RTC date register
            RTC_DR: mmio.Mmio(packed struct(u32) {
                ///  Date units in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                reserved8: u2,
                ///  Month units in BCD format
                MU: u4,
                ///  Month tens in BCD format
                MT: u1,
                ///  Week day units ...
                WDU: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  forbidden
                        B_0x0 = 0x0,
                        ///  Monday
                        B_0x1 = 0x1,
                        ///  Sunday
                        B_0x7 = 0x7,
                        _,
                    },
                },
                ///  Year units in BCD format
                YU: u4,
                ///  Year tens in BCD format
                YT: u4,
                padding: u8,
            }),
            ///  RTC subsecond register
            RTC_SSR: mmio.Mmio(packed struct(u32) {
                ///  Synchronous binary counter SS[31:16]: Synchronous binary counter MSB values When Binary or Mixed mode is selected (BIN = 01 or 10 or 11): SS[31:16] are the 16 MSB of the SS[31:0] free-running down-counter. When BCD mode is selected (BIN=00): SS[31:16] are forced by hardware to 0x0000. SS[15:0]: Subsecond value/synchronous binary counter LSB values When Binary mode is selected (BIN = 01 or 10 or 11): SS[15:0] are the 16 LSB of the SS[31:0] free-running down-counter. When BCD mode is selected (BIN=00): SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
                SS: u32,
            }),
            ///  RTC initialization control and status register
            RTC_ICSR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Wake-up timer write flag This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
                WUTWF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Wake-up timer configuration update not allowed except in initialization mode
                        B_0x0 = 0x0,
                        ///  Wake-up timer configuration update allowed
                        B_0x1 = 0x1,
                    },
                },
                ///  Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
                SHPF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No shift operation is pending
                        B_0x0 = 0x0,
                        ///  A shift operation is pending
                        B_0x1 = 0x1,
                    },
                },
                ///  Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
                INITS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calendar has not been initialized
                        B_0x0 = 0x0,
                        ///  Calendar has been initialized
                        B_0x1 = 0x1,
                    },
                },
                ///  Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
                RSF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calendar shadow registers not yet synchronized
                        B_0x0 = 0x0,
                        ///  Calendar shadow registers synchronized
                        B_0x1 = 0x1,
                    },
                },
                ///  Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
                INITF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calendar registers update is not allowed
                        B_0x0 = 0x0,
                        ///  Calendar registers update is allowed
                        B_0x1 = 0x1,
                    },
                },
                ///  Initialization mode
                INIT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Free running mode
                        B_0x0 = 0x0,
                        ///  Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER), plus BIN and BCDU fields. Counters are stopped and start counting from the new value when INIT is reset.
                        B_0x1 = 0x1,
                    },
                },
                ///  Binary mode
                BIN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Free running BCD calendar mode (Binary mode disabled).
                        B_0x0 = 0x0,
                        ///  Free running Binary mode (BCD mode disabled)
                        B_0x1 = 0x1,
                        ///  Free running BCD calendar and Binary modes
                        B_0x2 = 0x2,
                        ///  Free running BCD calendar and Binary modes
                        B_0x3 = 0x3,
                    },
                },
                ///  BCD update (BIN = 10 or 11) In mixed mode when both BCD calendar and binary extended counter are used (BIN = 10 or 11), the calendar second is incremented using the SSR Least Significant Bits.
                BCDU: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  1s calendar increment is generated each time SS[7:0] = 0
                        B_0x0 = 0x0,
                        ///  1s calendar increment is generated each time SS[8:0] = 0
                        B_0x1 = 0x1,
                        ///  1s calendar increment is generated each time SS[9:0] = 0
                        B_0x2 = 0x2,
                        ///  1s calendar increment is generated each time SS[10:0] = 0
                        B_0x3 = 0x3,
                        ///  1s calendar increment is generated each time SS[11:0] = 0
                        B_0x4 = 0x4,
                        ///  1s calendar increment is generated each time SS[12:0] = 0
                        B_0x5 = 0x5,
                        ///  1s calendar increment is generated each time SS[13:0] = 0
                        B_0x6 = 0x6,
                        ///  1s calendar increment is generated each time SS[14:0] = 0
                        B_0x7 = 0x7,
                    },
                },
                reserved16: u3,
                ///  Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
                RECALPF: u1,
                padding: u15,
            }),
            ///  RTC prescaler register
            RTC_PRER: mmio.Mmio(packed struct(u32) {
                ///  Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
                PREDIV_S: u15,
                reserved16: u1,
                ///  Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
                PREDIV_A: u7,
                padding: u9,
            }),
            ///  RTC wake-up timer register
            RTC_WUTR: mmio.Mmio(packed struct(u32) {
                ///  Wake-up auto-reload value bits When the wake-up timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]1+11) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register. When WUCKSEL[2] = 1, the wake-up timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs between WUT and (WUT + 2) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.
                WUT: u16,
                ///  Wake-up auto-reload output clear value When WUTOCLR[15:0] is different from 0x0000, WUTF is set by hardware when the auto-reload down-counter reaches 0 and is cleared by hardware when the auto-reload downcounter reaches WUTOCLR[15:0]. When WUTOCLR[15:0] = 0x0000, WUTF is set by hardware when the WUT down-counter reaches 0 and is cleared by software.
                WUTOCLR: u16,
            }),
            ///  RTC control register
            RTC_CR: mmio.Mmio(packed struct(u32) {
                ///  ck_wut wake-up clock selection 10x: ck_spre (usually 11Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. 11x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. Furthermore, 2<sup>16</sup> is added to the WUT counter value.
                WUCKSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  RTC/16 clock is selected
                        B_0x0 = 0x0,
                        ///  RTC/8 clock is selected
                        B_0x1 = 0x1,
                        ///  RTC/4 clock is selected
                        B_0x2 = 0x2,
                        ///  RTC/2 clock is selected
                        B_0x3 = 0x3,
                        _,
                    },
                },
                ///  Timestamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
                TSEDGE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RTC_TS input rising edge generates a timestamp event
                        B_0x0 = 0x0,
                        ///  RTC_TS input falling edge generates a timestamp event
                        B_0x1 = 0x1,
                    },
                },
                ///  RTC_REFIN reference clock detection enable (50 or 601Hz) Note: BIN must be 0x00 and PREDIV_S must be 0x00FF.
                REFCKON: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RTC_REFIN detection disabled
                        B_0x0 = 0x0,
                        ///  RTC_REFIN detection enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
                BYPSHAD: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles.
                        B_0x0 = 0x0,
                        ///  Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters.
                        B_0x1 = 0x1,
                    },
                },
                ///  Hour format
                FMT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  24 hour/day format
                        B_0x0 = 0x0,
                        ///  AM/PM hour format
                        B_0x1 = 0x1,
                    },
                },
                ///  SSR underflow interrupt enable
                SSRUIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SSR underflow interrupt disabled
                        B_0x0 = 0x0,
                        ///  SSR underflow interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm A enable
                ALRAE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A disabled
                        B_0x0 = 0x0,
                        ///  Alarm A enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm B enable
                ALRBE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B disabled
                        B_0x0 = 0x0,
                        ///  Alarm B enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up timer enable Note: When the wake-up timer is disabled, wait for WUTWF = 1 before enabling it again.
                WUTE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Wake-up timer disabled
                        B_0x0 = 0x0,
                        ///  Wake-up timer enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  timestamp enable
                TSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  timestamp disable
                        B_0x0 = 0x0,
                        ///  timestamp enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm A interrupt enable
                ALRAIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A interrupt disabled
                        B_0x0 = 0x0,
                        ///  Alarm A interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm B interrupt enable
                ALRBIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B interrupt disable
                        B_0x0 = 0x0,
                        ///  Alarm B interrupt enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up timer interrupt enable
                WUTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Wake-up timer interrupt disabled
                        B_0x0 = 0x0,
                        ///  Wake-up timer interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Timestamp interrupt enable
                TSIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Timestamp interrupt disable
                        B_0x0 = 0x0,
                        ///  Timestamp interrupt enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
                ADD1H: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Adds 1 hour to the current time. This can be used for summer time change
                        B_0x1 = 0x1,
                    },
                },
                ///  Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
                SUB1H: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Subtracts 1 hour to the current time. This can be used for winter time change.
                        B_0x1 = 0x1,
                    },
                },
                ///  Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
                BKP: u1,
                ///  Calibration output selection When COE = 1, this bit selects which signal is output on CALIB. These frequencies are valid for RTCCLK at 32.7681kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section128.3.16: Calibration clock output.
                COSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calibration output is 5121Hz
                        B_0x0 = 0x0,
                        ///  Calibration output is 11Hz
                        B_0x1 = 0x1,
                    },
                },
                ///  Output polarity This bit is used to configure the polarity of TAMPALRM output.
                POL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0]), or when a TAMPxF/ITAMPxF is asserted (if TAMPOE = 1).
                        B_0x0 = 0x0,
                        ///  The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0]), or when a TAMPxF/ITAMPxF is asserted (if TAMPOE = 1).
                        B_0x1 = 0x1,
                    },
                },
                ///  Output selection These bits are used to select the flag to be routed to TAMPALRM output.
                OSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Output disabled
                        B_0x0 = 0x0,
                        ///  Alarm A output enabled
                        B_0x1 = 0x1,
                        ///  Alarm B output enabled
                        B_0x2 = 0x2,
                        ///  Wake-up output enabled
                        B_0x3 = 0x3,
                    },
                },
                ///  Calibration output enable This bit enables the CALIB output
                COE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calibration output disabled
                        B_0x0 = 0x0,
                        ///  Calibration output enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  timestamp on internal event enable
                ITSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  internal event timestamp disabled
                        B_0x0 = 0x0,
                        ///  internal event timestamp enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Activate timestamp on tamper detection event TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set up to 3 ck_apre cycles after the tamper flags. Note: TAMPTS must be cleared before entering RTC initialization mode.
                TAMPTS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper detection event does not cause a RTC timestamp to be saved
                        B_0x0 = 0x0,
                        ///  Save RTC timestamp on tamper detection event
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper detection output enable on TAMPALRM
                TAMPOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The tamper flag is not routed on TAMPALRM
                        B_0x0 = 0x0,
                        ///  The tamper flag is routed on TAMPALRM, combined with the signal provided by OSEL and with the polarity provided by POL.
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm A flag automatic clear
                ALRAFCLR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A event generates a trigger event and ALRAF must be cleared by software to allow next alarm event.
                        B_0x0 = 0x0,
                        ///  Alarm A event generates a trigger event. ALRAF is automatically cleared by hardware after 1 ck_apre cycle.
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm B flag automatic clear
                ALRBFCLR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B event generates a trigger event and ALRBF must be cleared by software to allow next alarm event.
                        B_0x0 = 0x0,
                        ///  Alarm B event generates a trigger event. ALRBF is automatically cleared by hardware after 1 ck_apre cycle.
                        B_0x1 = 0x1,
                    },
                },
                ///  TAMPALRM pull-up enable
                TAMPALRM_PU: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No pull-up is applied on TAMPALRM output
                        B_0x0 = 0x0,
                        ///  A pull-up is applied on TAMPALRM output
                        B_0x1 = 0x1,
                    },
                },
                ///  TAMPALRM output type
                TAMPALRM_TYPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TAMPALRM is push-pull output
                        B_0x0 = 0x0,
                        ///  TAMPALRM is open-drain output
                        B_0x1 = 0x1,
                    },
                },
                ///  RTC_OUT2 output enable
                OUT2EN: u1,
            }),
            reserved36: [8]u8,
            ///  RTC write protection register
            RTC_WPR: mmio.Mmio(packed struct(u32) {
                ///  Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection.
                KEY: u8,
                padding: u24,
            }),
            ///  RTC calibration register
            RTC_CALR: mmio.Mmio(packed struct(u32) {
                ///  Calibration minus The frequency of the calendar is reduced by masking CALM out of 2<sup>20</sup> RTCCLK pulses (321seconds if the input frequency is 327681Hz). This decreases the frequency of the calendar with a resolution of 0.95371ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section128.3.14: RTC smooth digital calibration on page1733.
                CALM: u9,
                reserved12: u3,
                ///  RTC low-power mode
                LPCAL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Calibration window is 2<sup>20</sup> RTCCLK, which is a high-consumption mode. This mode must be set only when less than 32s calibration window is required.
                        B_0x0 = 0x0,
                        ///  Calibration window is 2<sup>20</sup> ck_apre, which is the required configuration for ultra-low consumption mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1. Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section128.3.14: RTC smooth digital calibration.
                CALW16: u1,
                ///  Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section128.3.14: RTC smooth digital calibration.
                CALW8: u1,
                ///  Increase frequency of RTC by 488.51ppm.
                CALP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No RTCCLK pulses are added.
                        B_0x0 = 0x0,
                        ///  One RTCCLK pulse is effectively inserted every 2<sup>11</sup> pulses (frequency increased by 488.51ppm).
                        B_0x1 = 0x1,
                    },
                },
                padding: u16,
            }),
            ///  RTC shift control register
            RTC_SHIFTR: mmio.Mmio(packed struct(u32) {
                ///  Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). In mixed BCD-binary mode (BIN=10 or 11), the SUBFS[14:BCDU+8] must be written with 0. Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
                SUBFS: u15,
                reserved31: u16,
                ///  Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
                ADD1S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Add one second to the clock/calendar
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RTC timestamp time register
            RTC_TSTR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format.
                SU: u4,
                ///  Second tens in BCD format.
                ST: u3,
                reserved8: u1,
                ///  Minute units in BCD format.
                MNU: u4,
                ///  Minute tens in BCD format.
                MNT: u3,
                reserved16: u1,
                ///  Hour units in BCD format.
                HU: u4,
                ///  Hour tens in BCD format.
                HT: u2,
                ///  AM/PM notation
                PM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AM or 24-hour format
                        B_0x0 = 0x0,
                        ///  PM
                        B_0x1 = 0x1,
                    },
                },
                padding: u9,
            }),
            ///  RTC timestamp date register
            RTC_TSDR: mmio.Mmio(packed struct(u32) {
                ///  Date units in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                reserved8: u2,
                ///  Month units in BCD format
                MU: u4,
                ///  Month tens in BCD format
                MT: u1,
                ///  Week day units
                WDU: u3,
                padding: u16,
            }),
            ///  RTC timestamp subsecond register
            RTC_TSSSR: mmio.Mmio(packed struct(u32) {
                ///  Subsecond value/synchronous binary counter values SS[31:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
                SS: u32,
            }),
            reserved64: [4]u8,
            ///  RTC alarm A register
            RTC_ALRMAR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format.
                SU: u4,
                ///  Second tens in BCD format.
                ST: u3,
                ///  Alarm A seconds mask
                MSK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A set if the seconds match
                        B_0x0 = 0x0,
                        ///  Seconds dont care in alarm A comparison
                        B_0x1 = 0x1,
                    },
                },
                ///  Minute units in BCD format
                MNU: u4,
                ///  Minute tens in BCD format
                MNT: u3,
                ///  Alarm A minutes mask
                MSK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A set if the minutes match
                        B_0x0 = 0x0,
                        ///  Minutes dont care in alarm A comparison
                        B_0x1 = 0x1,
                    },
                },
                ///  Hour units in BCD format
                HU: u4,
                ///  Hour tens in BCD format
                HT: u2,
                ///  AM/PM notation
                PM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AM or 24-hour format
                        B_0x0 = 0x0,
                        ///  PM
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm A hours mask
                MSK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A set if the hours match
                        B_0x0 = 0x0,
                        ///  Hours dont care in alarm A comparison
                        B_0x1 = 0x1,
                    },
                },
                ///  Date units or day in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                ///  Week day selection
                WDSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DU[3:0] represents the date units
                        B_0x0 = 0x0,
                        ///  DU[3:0] represents the week day. DT[1:0] is dont care.
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm A date mask
                MSK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm A set if the date/day match
                        B_0x0 = 0x0,
                        ///  Date/day dont care in alarm A comparison
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RTC alarm A subsecond register
            RTC_ALRMASSR: mmio.Mmio(packed struct(u32) {
                ///  Subseconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. This field is the mirror of SS[14:0] in the RTC_ALRABINR, and so can also be read or written through RTC_ALRABINR.
                SS: u15,
                reserved24: u9,
                ///  Mask the most-significant bits starting at this bit ... From 32 to 63: All 32 SS bits are compared and must match to activate alarm. Note: In BCD mode (BIN=00) the overflow bits of the synchronous counter (bits 31:15) are never compared. These bits can be different from 0 only after a shift operation.
                MASKSS: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No comparison on subseconds for Alarm A. The alarm is set when the seconds unit is incremented (assuming that the rest of the fields match).
                        B_0x0 = 0x0,
                        ///  SS[31:1] are dont care in Alarm A comparison. Only SS[0] is compared.
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved31: u1,
                ///  Clear synchronous counter on alarm (Binary mode only) Note: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11).
                SSCLR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The synchronous binary counter (SS[31:0] in RTC_SSR) is free-running.
                        B_0x0 = 0x0,
                        ///  The synchronous binary counter (SS[31:0] in RTC_SSR) is running from 0xFFFF1FFFF to RTC_ALRABINR.SS[31:0] value and is automatically reloaded with 0xFFFF1FFFF one ck_apre cycle after reaching RTC_ALRABINR.SS[31:0].
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RTC alarm B register
            RTC_ALRMBR: mmio.Mmio(packed struct(u32) {
                ///  Second units in BCD format
                SU: u4,
                ///  Second tens in BCD format
                ST: u3,
                ///  Alarm B seconds mask
                MSK1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B set if the seconds match
                        B_0x0 = 0x0,
                        ///  Seconds dont care in alarm B comparison
                        B_0x1 = 0x1,
                    },
                },
                ///  Minute units in BCD format
                MNU: u4,
                ///  Minute tens in BCD format
                MNT: u3,
                ///  Alarm B minutes mask
                MSK2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B set if the minutes match
                        B_0x0 = 0x0,
                        ///  Minutes dont care in alarm B comparison
                        B_0x1 = 0x1,
                    },
                },
                ///  Hour units in BCD format
                HU: u4,
                ///  Hour tens in BCD format
                HT: u2,
                ///  AM/PM notation
                PM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  AM or 24-hour format
                        B_0x0 = 0x0,
                        ///  PM
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm B hours mask
                MSK3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B set if the hours match
                        B_0x0 = 0x0,
                        ///  Hours dont care in alarm B comparison
                        B_0x1 = 0x1,
                    },
                },
                ///  Date units or day in BCD format
                DU: u4,
                ///  Date tens in BCD format
                DT: u2,
                ///  Week day selection
                WDSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DU[3:0] represents the date units
                        B_0x0 = 0x0,
                        ///  DU[3:0] represents the week day. DT[1:0] is dont care.
                        B_0x1 = 0x1,
                    },
                },
                ///  Alarm B date mask
                MSK4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Alarm B set if the date and day match
                        B_0x0 = 0x0,
                        ///  Date and day dont care in alarm B comparison
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RTC alarm B subsecond register
            RTC_ALRMBSSR: mmio.Mmio(packed struct(u32) {
                ///  Subseconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. This field is the mirror of SS[14:0] in the RTC_ALRBBINR, and so can also be read or written through RTC_ALRBBINR.
                SS: u15,
                reserved24: u9,
                ///  Mask the most-significant bits starting at this bit ... From 32 to 63: All 32 SS bits are compared and must match to activate alarm. Note: In BCD mode (BIN=00)The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
                MASKSS: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No comparison on subseconds for Alarm B. The alarm is set when the seconds unit is incremented (assuming that the rest of the fields match).
                        B_0x0 = 0x0,
                        ///  SS[31:1] are dont care in Alarm B comparison. Only SS[0] is compared.
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved31: u1,
                ///  Clear synchronous counter on alarm (Binary mode only) Note: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11).
                SSCLR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The synchronous binary counter (SS[31:0] in RTC_SSR) is free-running.
                        B_0x0 = 0x0,
                        ///  The synchronous binary counter (SS[31:0] in RTC_SSR) is running from 0xFFFF1FFFF to RTC_ALRBBINR.SS[31:0] value and is automatically reloaded with 0xFFFF1FFFF one ck_apre cycle after reaching RTC_ALRBBINR.SS[31:0].
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  RTC status register
            RTC_SR: mmio.Mmio(packed struct(u32) {
                ///  Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
                ALRAF: u1,
                ///  Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
                ALRBF: u1,
                ///  Wake-up timer flag This flag is set by hardware when the wake-up auto-reload counter reaches 0. If WUTOCLR[15:0] is different from 0x0000, WUTF is cleared by hardware when the wake-up auto-reload counter reaches WUTOCLR value. If WUTOCLR[15:0] is 0x0000, WUTF must be cleared by software. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
                WUTF: u1,
                ///  Timestamp flag This flag is set by hardware when a timestamp event occurs. If ITSF flag is set, TSF must be cleared together with ITSF. Note: TSF is not set if TAMPTS1=11 and the tamper flag is read during the 3 ck_apre cycles following tamper event. Refer to Timestamp on tamper event for more details.
                TSF: u1,
                ///  Timestamp overflow flag This flag is set by hardware when a timestamp event occurs while TSF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
                TSOVF: u1,
                ///  Internal timestamp flag This flag is set by hardware when a timestamp on the internal event occurs.
                ITSF: u1,
                ///  SSR underflow flag This flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1.
                SSRUF: u1,
                padding: u25,
            }),
            ///  RTC masked interrupt status register
            RTC_MISR: mmio.Mmio(packed struct(u32) {
                ///  Alarm A masked flag This flag is set by hardware when the alarm A interrupt occurs.
                ALRAMF: u1,
                ///  Alarm B masked flag This flag is set by hardware when the alarm B interrupt occurs.
                ALRBMF: u1,
                ///  Wake-up timer masked flag This flag is set by hardware when the wake-up timer interrupt occurs. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
                WUTMF: u1,
                ///  Timestamp masked flag This flag is set by hardware when a timestamp interrupt occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
                TSMF: u1,
                ///  Timestamp overflow masked flag This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
                TSOVMF: u1,
                ///  Internal timestamp masked flag This flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
                ITSMF: u1,
                ///  SSR underflow masked flag This flag is set by hardware when the SSR underflow interrupt occurs.
                SSRUMF: u1,
                padding: u25,
            }),
            reserved92: [4]u8,
            ///  RTC status clear register
            RTC_SCR: mmio.Mmio(packed struct(u32) {
                ///  Clear alarm A flag Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.
                CALRAF: u1,
                ///  Clear alarm B flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
                CALRBF: u1,
                ///  Clear wake-up timer flag Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
                CWUTF: u1,
                ///  Clear timestamp flag Writing 1 in this bit clears the TSF bit in the RTC_SR register. If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
                CTSF: u1,
                ///  Clear timestamp overflow flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
                CTSOVF: u1,
                ///  Clear internal timestamp flag Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
                CITSF: u1,
                ///  Clear SSR underflow flag Writing 1 in this bit clears the SSRUF in the RTC_SR register.
                CSSRUF: u1,
                padding: u25,
            }),
            reserved112: [16]u8,
            ///  RTC alarm A binary mode register
            RTC_ALRABINR: mmio.Mmio(packed struct(u32) {
                ///  Synchronous counter alarm value in Binary mode This value is compared with the contents of the synchronous counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. SS[14:0] is the mirror of SS[14:0] in the RTC_ALRMASSRR, and so can also be read or written through RTC_ALRMASSR.
                SS: u32,
            }),
            ///  RTC alarm B binary mode register
            RTC_ALRBBINR: mmio.Mmio(packed struct(u32) {
                ///  Synchronous counter alarm value in Binary mode This value is compared with the contents of the synchronous counter to determine if Alarm Bis to be activated. Only bits 0 up MASKSS-1 are compared. SS[14:0] is the mirror of SS[14:0] in the RTC_ALRMBSSRR, and so can also be read or written through RTC_ALRMBSSR.
                SS: u32,
            }),
        };

        ///  SPI address block description
        pub const SPI1 = extern struct {
            ///  SPI control register 1
            SPI_CR1: mmio.Mmio(packed struct(u16) {
                ///  Clock phase Note: This bit should not be changed when communication is ongoing. Note: This bit is not used in SPI TI mode except the case when CRC is applied at TI mode.
                CPHA: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The first clock transition is the first data capture edge
                        B_0x0 = 0x0,
                        ///  The second clock transition is the first data capture edge
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock polarity Note: This bit should not be changed when communication is ongoing. Note: This bit is not used in SPI TI mode except the case when CRC is applied at TI mode.
                CPOL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CK to 0 when idle
                        B_0x0 = 0x0,
                        ///  CK to 1 when idle
                        B_0x1 = 0x1,
                    },
                },
                ///  Master selection Note: This bit should not be changed when communication is ongoing.
                MSTR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Slave configuration
                        B_0x0 = 0x0,
                        ///  Master configuration
                        B_0x1 = 0x1,
                    },
                },
                ///  Baud rate control Note: These bits should not be changed when communication is ongoing.
                BR: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  f<sub>PCLK</sub>/2
                        B_0x0 = 0x0,
                        ///  f<sub>PCLK</sub>/4
                        B_0x1 = 0x1,
                        ///  f<sub>PCLK</sub>/8
                        B_0x2 = 0x2,
                        ///  f<sub>PCLK</sub>/16
                        B_0x3 = 0x3,
                        ///  f<sub>PCLK</sub>/32
                        B_0x4 = 0x4,
                        ///  f<sub>PCLK</sub>/64
                        B_0x5 = 0x5,
                        ///  f<sub>PCLK</sub>/128
                        B_0x6 = 0x6,
                        ///  f<sub>PCLK</sub>/256
                        B_0x7 = 0x7,
                    },
                },
                ///  SPI enable Note: When disabling the SPI, follow the procedure described in Procedure for disabling the SPI on page1954.
                SPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Peripheral disabled
                        B_0x0 = 0x0,
                        ///  Peripheral enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Frame format Note: 1. This bit should not be changed when communication is ongoing. Note: 2. This bit is not used in SPI TI mode.
                LSBFIRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  data is transmitted / received with the MSB first
                        B_0x0 = 0x0,
                        ///  data is transmitted / received with the LSB first
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal slave select This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored. Note: This bit is not used in SPI TI mode.
                SSI: u1,
                ///  Software slave management When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit. Note: This bit is not used in SPI TI mode.
                SSM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Software slave management disabled
                        B_0x0 = 0x0,
                        ///  Software slave management enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Receive only mode enabled. This bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted.
                RXONLY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Full-duplex (Transmit and receive)
                        B_0x0 = 0x0,
                        ///  Output disabled (Receive-only mode)
                        B_0x1 = 0x1,
                    },
                },
                ///  CRC length This bit is set and cleared by software to select the CRC length. Note: This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
                CRCL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  8-bit CRC length
                        B_0x0 = 0x0,
                        ///  16-bit CRC length
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmit CRC next Note: This bit has to be written as soon as the last data is written in the SPI_DR register.
                CRCNEXT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Next transmit value is from Tx buffer.
                        B_0x0 = 0x0,
                        ///  Next transmit value is from Tx CRC register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Hardware CRC calculation enable Note: This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
                CRCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CRC calculation disabled
                        B_0x0 = 0x0,
                        ///  CRC calculation enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Output enable in bidirectional mode This bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode. Note: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.
                BIDIOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output disabled (receive-only mode)
                        B_0x0 = 0x0,
                        ///  Output enabled (transmit-only mode)
                        B_0x1 = 0x1,
                    },
                },
                ///  Bidirectional data mode enable. This bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.
                BIDIMODE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  2-line unidirectional data mode selected
                        B_0x0 = 0x0,
                        ///  1-line bidirectional data mode selected
                        B_0x1 = 0x1,
                    },
                },
            }),
            reserved4: [2]u8,
            ///  SPI control register 2
            SPI_CR2: mmio.Mmio(packed struct(u16) {
                ///  Rx buffer DMA enable When this bit is set, a DMA request is generated whenever the RXNE flag is set.
                RXDMAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Rx buffer DMA disabled
                        B_0x0 = 0x0,
                        ///  Rx buffer DMA enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Tx buffer DMA enable When this bit is set, a DMA request is generated whenever the TXE flag is set.
                TXDMAEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tx buffer DMA disabled
                        B_0x0 = 0x0,
                        ///  Tx buffer DMA enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  SS output enable Note: This bit is not used in SPI TI mode.
                SSOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SS output is disabled in master mode and the SPI interface can work in multimaster configuration
                        B_0x0 = 0x0,
                        ///  SS output is enabled in master mode and when the SPI interface is enabled. The SPI interface cannot work in a multimaster environment.
                        B_0x1 = 0x1,
                    },
                },
                ///  NSS pulse management This bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer. It has no meaning if CPHA = 1, or FRF = 1. Note: 1. This bit must be written only when the SPI is disabled (SPE=0). Note: 2. This bit is not used in SPI TI mode.
                NSSP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No NSS pulse
                        B_0x0 = 0x0,
                        ///  NSS pulse generated
                        B_0x1 = 0x1,
                    },
                },
                ///  Frame format 1 SPI TI mode Note: This bit must be written only when the SPI is disabled (SPE=0).
                FRF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SPI Motorola mode
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  Error interrupt enable This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode).
                ERRIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Error interrupt is masked
                        B_0x0 = 0x0,
                        ///  Error interrupt is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  RX buffer not empty interrupt enable
                RXNEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RXNE interrupt masked
                        B_0x0 = 0x0,
                        ///  RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tx buffer empty interrupt enable
                TXEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TXE interrupt masked
                        B_0x0 = 0x0,
                        ///  TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.
                        B_0x1 = 0x1,
                    },
                },
                ///  Data size These bits configure the data length for SPI transfers. If software attempts to write one of the Not used values, they are forced to the value 0111 (8-bit)
                DS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Not used
                        B_0x0 = 0x0,
                        ///  Not used
                        B_0x1 = 0x1,
                        ///  Not used
                        B_0x2 = 0x2,
                        ///  4-bit
                        B_0x3 = 0x3,
                        ///  5-bit
                        B_0x4 = 0x4,
                        ///  6-bit
                        B_0x5 = 0x5,
                        ///  7-bit
                        B_0x6 = 0x6,
                        ///  8-bit
                        B_0x7 = 0x7,
                        ///  9-bit
                        B_0x8 = 0x8,
                        ///  10-bit
                        B_0x9 = 0x9,
                        ///  11-bit
                        B_0xA = 0xa,
                        ///  12-bit
                        B_0xB = 0xb,
                        ///  13-bit
                        B_0xC = 0xc,
                        ///  14-bit
                        B_0xD = 0xd,
                        ///  15-bit
                        B_0xE = 0xe,
                        ///  16-bit
                        B_0xF = 0xf,
                    },
                },
                ///  FIFO reception threshold This bit is used to set the threshold of the RXFIFO that triggers an RXNE event
                FRXTH: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RXNE event is generated if the FIFO level is greater than or equal to 1/2 (16-bit)
                        B_0x0 = 0x0,
                        ///  RXNE event is generated if the FIFO level is greater than or equal to 1/4 (8-bit)
                        B_0x1 = 0x1,
                    },
                },
                ///  Last DMA transfer for reception This bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register). Note: Refer to Procedure for disabling the SPI on page1954 if the CRCEN bit is set.
                LDMA_RX: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Number of data to transfer is even
                        B_0x0 = 0x0,
                        ///  Number of data to transfer is odd
                        B_0x1 = 0x1,
                    },
                },
                ///  Last DMA transfer for transmission This bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register). Note: Refer to Procedure for disabling the SPI on page1954 if the CRCEN bit is set.
                LDMA_TX: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Number of data to transfer is even
                        B_0x0 = 0x0,
                        ///  Number of data to transfer is odd
                        B_0x1 = 0x1,
                    },
                },
                padding: u1,
            }),
            reserved8: [2]u8,
            ///  SPI status register
            SPI_SR: mmio.Mmio(packed struct(u16) {
                ///  Receive buffer not empty
                RXNE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Rx buffer empty
                        B_0x0 = 0x0,
                        ///  Rx buffer not empty
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmit buffer empty
                TXE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tx buffer not empty
                        B_0x0 = 0x0,
                        ///  Tx buffer empty
                        B_0x1 = 0x1,
                    },
                },
                reserved4: u2,
                ///  CRC error flag Note: This flag is set by hardware and cleared by software writing 0.
                CRCERR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CRC value received matches the SPI_RXCRCR value
                        B_0x0 = 0x0,
                        ///  CRC value received does not match the SPI_RXCRCR value
                        B_0x1 = 0x1,
                    },
                },
                ///  Mode fault This flag is set by hardware and reset by a software sequence. Refer to Section1: Mode fault (MODF) on page1964 for the software sequence.
                MODF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No mode fault occurred
                        B_0x0 = 0x0,
                        ///  Mode fault occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Overrun flag This flag is set by hardware and reset by a software sequence.
                OVR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overrun occurred
                        B_0x0 = 0x0,
                        ///  Overrun occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Busy flag This flag is set and cleared by hardware. Note: The BSY flag must be used with caution: refer to Section133.4.10: SPI status flags and Procedure for disabling the SPI on page1954.
                BSY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SPI not busy
                        B_0x0 = 0x0,
                        ///  SPI is busy in communication or Tx buffer is not empty
                        B_0x1 = 0x1,
                    },
                },
                ///  Frame format error This flag is used for SPI in TI slave mode. Refer to Section133.4.11: SPI error flags. This flag is set by hardware and reset when SPI_SR is read by software.
                FRE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No frame format error
                        B_0x0 = 0x0,
                        ///  A frame format error occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  FIFO reception level These bits are set and cleared by hardware. Note: These bits are not used in SPI receive-only mode while CRC calculation is enabled.
                FRLVL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  FIFO empty
                        B_0x0 = 0x0,
                        ///  1/4 FIFO
                        B_0x1 = 0x1,
                        ///  1/2 FIFO
                        B_0x2 = 0x2,
                        ///  FIFO full
                        B_0x3 = 0x3,
                    },
                },
                ///  FIFO transmission level These bits are set and cleared by hardware.
                FTLVL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  FIFO empty
                        B_0x0 = 0x0,
                        ///  1/4 FIFO
                        B_0x1 = 0x1,
                        ///  1/2 FIFO
                        B_0x2 = 0x2,
                        ///  FIFO full (considered as FULL when the FIFO threshold is greater than 1/2)
                        B_0x3 = 0x3,
                    },
                },
                padding: u3,
            }),
            reserved12: [2]u8,
            ///  SPI data register
            SPI_DR: mmio.Mmio(packed struct(u16) {
                ///  Data register Data received or to be transmitted The data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See Section133.4.9: Data transmission and reception procedures). Note: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used.
                DR: u16,
            }),
            reserved16: [2]u8,
            ///  SPI CRC polynomial register
            SPI_CRCPR: mmio.Mmio(packed struct(u16) {
                ///  CRC polynomial register This register contains the polynomial for the CRC calculation. The CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.
                CRCPOLY: u16,
            }),
            reserved20: [2]u8,
            ///  SPI Rx CRC register
            SPI_RXCRCR: mmio.Mmio(packed struct(u16) {
                ///  Rx CRC register When CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY Flag is set could return an incorrect value.
                RXCRC: u16,
            }),
            reserved24: [2]u8,
            ///  SPI Tx CRC register
            SPI_TXCRCR: mmio.Mmio(packed struct(u16) {
                ///  Tx CRC register When CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY flag is set could return an incorrect value.
                TXCRC: u16,
            }),
        };

        ///  TSC address block description
        pub const TSC = extern struct {
            ///  TSC control register
            TSC_CR: mmio.Mmio(packed struct(u32) {
                ///  Touch sensing controller enable This bit is set and cleared by software to enable/disable the touch sensing controller. Note: When the touch sensing controller is disabled, TSC registers settings have no effect.
                TSCE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Touch sensing controller disabled
                        B_0x0 = 0x0,
                        ///  Touch sensing controller enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Start a new acquisition This bit is set by software to start a new acquisition. It is cleared by hardware as soon as the acquisition is complete or by software to cancel the ongoing acquisition.
                START: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition not started
                        B_0x0 = 0x0,
                        ///  Start a new acquisition
                        B_0x1 = 0x1,
                    },
                },
                ///  Acquisition mode This bit is set and cleared by software to select the acquisition mode. Note: This bit must not be modified when an acquisition is ongoing.
                AM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Normal acquisition mode (acquisition starts as soon as START bit is set)
                        B_0x0 = 0x0,
                        ///  Synchronized acquisition mode (acquisition starts if START bit is set and when the selected signal is detected on the SYNC input pin)
                        B_0x1 = 0x1,
                    },
                },
                ///  Synchronization pin polarity This bit is set and cleared by software to select the polarity of the synchronization input pin.
                SYNCPOL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Falling edge only
                        B_0x0 = 0x0,
                        ///  Rising edge and high level
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O Default mode This bit is set and cleared by software. It defines the configuration of all the TSC I/Os when there is no ongoing acquisition. When there is an ongoing acquisition, it defines the configuration of all unused I/Os (not defined as sampling capacitor I/O or as channel I/O). Note: This bit must not be modified when an acquisition is ongoing.
                IODEF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  I/Os are forced to output push-pull low
                        B_0x0 = 0x0,
                        ///  I/Os are in input floating
                        B_0x1 = 0x1,
                    },
                },
                ///  Max count value These bits are set and cleared by software. They define the maximum number of charge transfer pulses that can be generated before a max count error is generated. Note: These bits must not be modified when an acquisition is ongoing.
                MCV: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  255
                        B_0x0 = 0x0,
                        ///  511
                        B_0x1 = 0x1,
                        ///  1023
                        B_0x2 = 0x2,
                        ///  2047
                        B_0x3 = 0x3,
                        ///  4095
                        B_0x4 = 0x4,
                        ///  8191
                        B_0x5 = 0x5,
                        ///  16383
                        B_0x6 = 0x6,
                        _,
                    },
                },
                reserved12: u4,
                ///  Pulse generator prescaler These bits are set and cleared by software.They select the AHB clock divider used to generate the pulse generator clock (PGCLK). Note: These bits must not be modified when an acquisition is ongoing. Note: Some configurations are forbidden. Refer to the Section119.4.4: Charge transfer acquisition sequence for details.
                PGPSC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  f<sub>HCLK</sub>
                        B_0x0 = 0x0,
                        ///  f<sub>HCLK</sub> /2
                        B_0x1 = 0x1,
                        ///  f<sub>HCLK</sub> /4
                        B_0x2 = 0x2,
                        ///  f<sub>HCLK</sub> /8
                        B_0x3 = 0x3,
                        ///  f<sub>HCLK</sub> /16
                        B_0x4 = 0x4,
                        ///  f<sub>HCLK</sub> /32
                        B_0x5 = 0x5,
                        ///  f<sub>HCLK</sub> /64
                        B_0x6 = 0x6,
                        ///  f<sub>HCLK</sub> /128
                        B_0x7 = 0x7,
                    },
                },
                ///  Spread spectrum prescaler This bit is set and cleared by software. It selects the AHB clock divider used to generate the spread spectrum clock (SSCLK). Note: This bit must not be modified when an acquisition is ongoing.
                SSPSC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  f<sub>HCLK</sub>
                        B_0x0 = 0x0,
                        ///  f<sub>HCLK</sub> /2
                        B_0x1 = 0x1,
                    },
                },
                ///  Spread spectrum enable This bit is set and cleared by software to enable/disable the spread spectrum feature. Note: This bit must not be modified when an acquisition is ongoing.
                SSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Spread spectrum disabled
                        B_0x0 = 0x0,
                        ///  Spread spectrum enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Spread spectrum deviation These bits are set and cleared by software. They define the spread spectrum deviation which consists in adding a variable number of periods of the SSCLK clock to the charge transfer pulse high state. ... Note: These bits must not be modified when an acquisition is ongoing.
                SSD: packed union {
                    raw: u7,
                    value: enum(u7) {
                        ///  1x t<sub>SSCLK</sub>
                        B_0x0 = 0x0,
                        ///  2x t<sub>SSCLK</sub>
                        B_0x1 = 0x1,
                        ///  128x t<sub>SSCLK</sub>
                        B_0x7F = 0x7f,
                        _,
                    },
                },
                ///  Charge transfer pulse low These bits are set and cleared by software. They define the duration of the low state of the charge transfer pulse (transfer of charge from C<sub>X</sub> to C<sub>S</sub>). ... Note: These bits must not be modified when an acquisition is ongoing. Note: Some configurations are forbidden. Refer to the Section119.4.4: Charge transfer acquisition sequence for details.
                CTPL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  1x t<sub>PGCLK</sub>
                        B_0x0 = 0x0,
                        ///  2x t<sub>PGCLK</sub>
                        B_0x1 = 0x1,
                        ///  16x t<sub>PGCLK</sub>
                        B_0xF = 0xf,
                        _,
                    },
                },
                ///  Charge transfer pulse high These bits are set and cleared by software. They define the duration of the high state of the charge transfer pulse (charge of C<sub>X</sub>). ... Note: These bits must not be modified when an acquisition is ongoing.
                CTPH: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  1x t<sub>PGCLK</sub>
                        B_0x0 = 0x0,
                        ///  2x t<sub>PGCLK</sub>
                        B_0x1 = 0x1,
                        ///  16x t<sub>PGCLK</sub>
                        B_0xF = 0xf,
                        _,
                    },
                },
            }),
            ///  TSC interrupt enable register
            TSC_IER: mmio.Mmio(packed struct(u32) {
                ///  End of acquisition interrupt enable This bit is set and cleared by software to enable/disable the end of acquisition interrupt.
                EOAIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  End of acquisition interrupt disabled
                        B_0x0 = 0x0,
                        ///  End of acquisition interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Max count error interrupt enable This bit is set and cleared by software to enable/disable the max count error interrupt.
                MCEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Max count error interrupt disabled
                        B_0x0 = 0x0,
                        ///  Max count error interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u30,
            }),
            ///  TSC interrupt clear register
            TSC_ICR: mmio.Mmio(packed struct(u32) {
                ///  End of acquisition interrupt clear This bit is set by software to clear the end of acquisition flag and it is cleared by hardware when the flag is reset. Writing a 0 has no effect.
                EOAIC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clears the corresponding EOAF of the TSC_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Max count error interrupt clear This bit is set by software to clear the max count error flag and it is cleared by hardware when the flag is reset. Writing a 0 has no effect.
                MCEIC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect
                        B_0x0 = 0x0,
                        ///  Clears the corresponding MCEF of the TSC_ISR register
                        B_0x1 = 0x1,
                    },
                },
                padding: u30,
            }),
            ///  TSC interrupt status register
            TSC_ISR: mmio.Mmio(packed struct(u32) {
                ///  End of acquisition flag This bit is set by hardware when the acquisition of all enabled group is complete (all GxS bits of all enabled analog I/O groups are set or when a max count error is detected). It is cleared by software writing 1 to the bit EOAIC of the TSC_ICR register.
                EOAF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Max count error flag This bit is set by hardware as soon as an analog I/O group counter reaches the max count value specified. It is cleared by software writing 1 to the bit MCEIC of the TSC_ICR register.
                MCEF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No max count error (MCE) detected
                        B_0x0 = 0x0,
                        ///  Max count error (MCE) detected
                        B_0x1 = 0x1,
                    },
                },
                padding: u30,
            }),
            ///  TSC I/O hysteresis control register
            TSC_IOHCR: mmio.Mmio(packed struct(u32) {
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy Schmitt trigger hysteresis mode These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis. Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy Schmitt trigger hysteresis disabled
                        B_0x0 = 0x0,
                        ///  Gx_IOy Schmitt trigger hysteresis enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved24: [4]u8,
            ///  TSC I/O analog switch control register
            TSC_IOASCR: mmio.Mmio(packed struct(u32) {
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G1_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G2_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G3_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G4_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G5_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G6_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy analog switch enable These bits are set and cleared by software to enable/disable the Gx_IOy analog switch. Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).
                G7_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy analog switch disabled (opened)
                        B_0x0 = 0x0,
                        ///  Gx_IOy analog switch enabled (closed)
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved32: [4]u8,
            ///  TSC I/O sampling control register
            TSC_IOSCR: mmio.Mmio(packed struct(u32) {
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy sampling mode These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as sampling capacitor
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved40: [4]u8,
            ///  TSC I/O channel control register
            TSC_IOCCR: mmio.Mmio(packed struct(u32) {
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G1_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G2_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G3_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G4_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G5_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G6_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                ///  Gx_IOy channel mode These bits are set and cleared by software to configure the Gx_IOy as a channel I/O. Note: These bits must not be modified when an acquisition is ongoing. Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.
                G7_IO4: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Gx_IOy unused
                        B_0x0 = 0x0,
                        ///  Gx_IOy used as channel
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved48: [4]u8,
            ///  TSC I/O group control status register
            TSC_IOGCSR: mmio.Mmio(packed struct(u32) {
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G3E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G4E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G5E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G6E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x enable These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.
                G7E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x disabled
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u9,
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G1S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G2S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G3S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G4S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G5S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G6S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                ///  Analog I/O group x status These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started. Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.
                G7S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Acquisition on analog I/O group x is ongoing or not started
                        B_0x0 = 0x0,
                        ///  Acquisition on analog I/O group x is complete
                        B_0x1 = 0x1,
                    },
                },
                padding: u9,
            }),
            ///  TSC I/O group 1 counter register
            TSC_IOG1CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
            ///  TSC I/O group 2 counter register
            TSC_IOG2CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
            ///  TSC I/O group 3 counter register
            TSC_IOG3CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
            ///  TSC I/O group 4 counter register
            TSC_IOG4CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
            ///  TSC I/O group 5 counter register
            TSC_IOG5CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
            ///  TSC I/O group 6 counter register
            TSC_IOG6CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
            ///  TSC I/O group 7 counter register
            TSC_IOG7CR: mmio.Mmio(packed struct(u32) {
                ///  Counter value These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold).
                CNT: u14,
                padding: u18,
            }),
        };

        ///  USART address block description
        pub const USART1 = extern struct {
            ///  USART control register 1
            USART_CR1: mmio.Mmio(packed struct(u32) {
                ///  USART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. Note: In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value.
                UE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  USART prescaler and outputs disabled, low-power mode
                        B_0x0 = 0x0,
                        ///  USART enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  USART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.
                UESM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  USART not able to wake up the MCU from low-power mode.
                        B_0x0 = 0x0,
                        ///  USART able to wake up the MCU from low-power mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver enable This bit enables the receiver. It is set and cleared by software.
                RE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver is disabled
                        B_0x0 = 0x0,
                        ///  Receiver is enabled and begins searching for a start bit
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
                TE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Transmitter is disabled
                        B_0x0 = 0x0,
                        ///  Transmitter is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  IDLE interrupt enable This bit is set and cleared by software.
                IDLEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever IDLE=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO not empty interrupt enable This bit is set and cleared by software.
                RXFNEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever ORE=1 or RXFNE=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmission complete interrupt enable This bit is set and cleared by software.
                TCIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever TC=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO not full interrupt enable This bit is set and cleared by software.
                TXFNFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever TXFNF =1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  PE interrupt enable This bit is set and cleared by software.
                PEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever PE=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UE=0).
                PS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Even parity
                        B_0x0 = 0x0,
                        ///  Odd parity
                        B_0x1 = 0x1,
                    },
                },
                ///  Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UE=0).
                PCE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Parity control disabled
                        B_0x0 = 0x0,
                        ///  Parity control enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver wake-up method This bit determines the USART wake-up method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UE=0).
                WAKE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Idle line
                        B_0x0 = 0x0,
                        ///  Address mark
                        B_0x1 = 0x1,
                    },
                },
                ///  Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE=0).
                M0: u1,
                ///  Mute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
                MME: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver in Active mode permanently
                        B_0x0 = 0x0,
                        ///  Receiver can switch between Mute mode and Active mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Character match interrupt enable This bit is set and cleared by software.
                CMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated when the CMF bit is set in the USART_ISR register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Oversampling mode This bit can only be written when the USART is disabled (UE=0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
                OVER8: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Oversampling by 16
                        B_0x0 = 0x0,
                        ///  Oversampling by 8
                        B_0x1 = 0x1,
                    },
                },
                ///  Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                DEDT: u5,
                ///  Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                DEAT: u5,
                ///  Receiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section131.4: USART implementation on page1826.
                RTOIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated when the RTOF bit is set in the USART_ISR register.
                        B_0x1 = 0x1,
                    },
                },
                ///  End of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                EOBIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated when the EOBF flag is set in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = 00: 1 start bit, 8 Data bits, n Stop bit M[1:0] = 01: 1 start bit, 9 Data bits, n Stop bit M[1:0] = 10: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UE=0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.
                M1: u1,
                ///  FIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0). Note: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
                FIFOEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  FIFO mode is disabled.
                        B_0x0 = 0x0,
                        ///  FIFO mode is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO empty interrupt enable This bit is set and cleared by software.
                TXFEIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated when TXFE=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  None
                RXFFIE: u1,
            }),
            ///  USART control register 2
            USART_CR2: mmio.Mmio(packed struct(u32) {
                ///  Synchronous Slave mode enable When the SLVEN bit is set, the Synchronous slave mode is enabled. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                SLVEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Slave mode disabled.
                        B_0x0 = 0x0,
                        ///  Slave mode enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u2,
                ///  When the DIS_NSS bit is set, the NSS pin input is ignored. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                DIS_NSS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SPI slave selection depends on NSS input pin.
                        B_0x0 = 0x0,
                        ///  SPI slave is always selected and NSS input pin is ignored.
                        B_0x1 = 0x1,
                    },
                },
                ///  7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the USART is disabled (UE=0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
                ADDM7: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  4-bit address detection
                        B_0x0 = 0x0,
                        ///  7-bit address detection (in 8-bit data mode)
                        B_0x1 = 0x1,
                    },
                },
                ///  LIN break detection length This bit is for selection between 11 bit or 10 bit break detection. This bit can only be written when the USART is disabled (UE=0). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                LBDL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  10-bit break detection
                        B_0x0 = 0x0,
                        ///  11-bit break detection
                        B_0x1 = 0x1,
                    },
                },
                ///  LIN break detection interrupt enable Break interrupt mask (break detection using break delimiter). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                LBDIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An interrupt is generated whenever LBDF=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u1,
                ///  Last bit clock pulse This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in Synchronous mode. The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register. This bit can only be written when the USART is disabled (UE=0). Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                LBCL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The clock pulse of the last data bit is not output to the CK pin
                        B_0x0 = 0x0,
                        ///  The clock pulse of the last data bit is output to the CK pin
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock phase This bit is used to select the phase of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure1233 and Figure1234) This bit can only be written when the USART is disabled (UE=0). Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                CPHA: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The first clock transition is the first data capture edge
                        B_0x0 = 0x0,
                        ///  The second clock transition is the first data capture edge
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock polarity This bit enables the user to select the polarity of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship This bit can only be written when the USART is disabled (UE=0). Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                CPOL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Steady low value on CK pin outside transmission window
                        B_0x0 = 0x0,
                        ///  Steady high value on CK pin outside transmission window
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock enable This bit enables the user to enable the CK pin. This bit can only be written when the USART is disabled (UE=0). Note: If neither Synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826. In Smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below must be respected: UE = 0 SCEN = 1 GTPR configuration CLKEN= 1 Note: UE = 1
                CLKEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CK pin disabled
                        B_0x0 = 0x0,
                        ///  CK pin enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  stop bits These bits are used for programming the stop bits. This bitfield can only be written when the USART is disabled (UE=0).
                STOP: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  1 stop bit
                        B_0x0 = 0x0,
                        ///  0.5 stop bit.
                        B_0x1 = 0x1,
                        ///  2 stop bits
                        B_0x2 = 0x2,
                        ///  1.5 stop bits
                        B_0x3 = 0x3,
                    },
                },
                ///  LIN mode enable This bit is set and cleared by software. The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks. This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                LINEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LIN mode disabled
                        B_0x0 = 0x0,
                        ///  LIN mode enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Swap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).
                SWAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TX/RX pins are used as defined in standard pinout
                        B_0x0 = 0x0,
                        ///  The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.
                        B_0x1 = 0x1,
                    },
                },
                ///  RX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the USART is disabled (UE=0).
                RXINV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RX pin signal works using the standard logic levels (V<sub>DD</sub> =1/idle, Gnd=0/mark)
                        B_0x0 = 0x0,
                        ///  RX pin signal values are inverted. ((V<sub>DD</sub> =0/mark, Gnd=1/idle).
                        B_0x1 = 0x1,
                    },
                },
                ///  TX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the USART is disabled (UE=0).
                TXINV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TX pin signal works using the standard logic levels (V<sub>DD</sub> =1/idle, Gnd=0/mark)
                        B_0x0 = 0x0,
                        ///  TX pin signal values are inverted. ((V<sub>DD</sub> =0/mark, Gnd=1/idle).
                        B_0x1 = 0x1,
                    },
                },
                ///  Binary data inversion This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).
                DATAINV: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L)
                        B_0x0 = 0x0,
                        ///  Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted.
                        B_0x1 = 0x1,
                    },
                },
                ///  Most significant bit first This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).
                MSBFIRST: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  data is transmitted/received with data bit 0 first, following the start bit.
                        B_0x0 = 0x0,
                        ///  data is transmitted/received with the MSB (bit 7/8) first, following the start bit.
                        B_0x1 = 0x1,
                    },
                },
                ///  Auto baud rate enable This bit is set and cleared by software. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                ABREN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Auto baud rate detection is disabled.
                        B_0x0 = 0x0,
                        ///  Auto baud rate detection is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Auto baud rate mode These bits are set and cleared by software. This bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0). Note: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST) Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                ABRMOD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Measurement of the start bit is used to detect the baud rate.
                        B_0x0 = 0x0,
                        ///  Falling edge to falling edge measurement (the received frame must start with a single bit = 1 -> Frame = Start10xxxxxx)
                        B_0x1 = 0x1,
                        ///  0x7F frame detection.
                        B_0x2 = 0x2,
                        ///  0x55 frame detection
                        B_0x3 = 0x3,
                    },
                },
                ///  Receiver timeout enable This bit is set and cleared by software. When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register). Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                RTOEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver timeout feature disabled.
                        B_0x0 = 0x0,
                        ///  Receiver timeout feature enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Address of the USART node These bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode: In Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used. In low-power mode: they are used for wake up from low-power mode on character match. When WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1. In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set. These bits can only be written when the reception is disabled (RE1=10) or when the USART is disabled (UE1=10).
                ADD: u8,
            }),
            ///  USART control register 3
            USART_CR3: mmio.Mmio(packed struct(u32) {
                ///  Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1or UDR = 1 in the USART_ISR register).
                EIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  interrupt generated when FE=1 or ORE=1 or NE=1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.
                        B_0x1 = 0x1,
                    },
                },
                ///  IrDA mode enable This bit is set and cleared by software. This bit can only be written when the USART is disabled (UE=0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                IREN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  IrDA disabled
                        B_0x0 = 0x0,
                        ///  IrDA enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  IrDA low-power This bit is used for selecting between normal and low-power IrDA modes This bit can only be written when the USART is disabled (UE=0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                IRLP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Normal mode
                        B_0x0 = 0x0,
                        ///  Low-power mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Half-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the USART is disabled (UE=0).
                HDSEL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Half-duplex mode is not selected
                        B_0x0 = 0x0,
                        ///  Half-duplex mode is selected
                        B_0x1 = 0x1,
                    },
                },
                ///  Smartcard NACK enable This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                NACK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  NACK transmission in case of parity error is disabled
                        B_0x0 = 0x0,
                        ///  NACK transmission during parity error is enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Smartcard mode enable This bit is used for enabling Smartcard mode. This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                SCEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Smartcard mode disabled
                        B_0x0 = 0x0,
                        ///  Smartcard mode enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA enable receiver This bit is set/reset by software
                DMAR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA mode is enabled for reception
                        B_0x1 = 0x1,
                        ///  DMA mode is disabled for reception
                        B_0x0 = 0x0,
                    },
                },
                ///  DMA enable transmitter This bit is set/reset by software
                DMAT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA mode is enabled for transmission
                        B_0x1 = 0x1,
                        ///  DMA mode is disabled for transmission
                        B_0x0 = 0x0,
                    },
                },
                ///  RTS enable This bit can only be written when the USART is disabled (UE=0). Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                RTSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RTS hardware flow control disabled
                        B_0x0 = 0x0,
                        ///  RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received.
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS enable This bit can only be written when the USART is disabled (UE=0) Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                CTSE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CTS hardware flow control disabled
                        B_0x0 = 0x0,
                        ///  CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping.If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted.
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS interrupt enable Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                CTSIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt is inhibited
                        B_0x0 = 0x0,
                        ///  An interrupt is generated whenever CTSIF=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  One sample bit method enable This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled. This bit can only be written when the USART is disabled (UE=0).
                ONEBIT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Three sample bit method
                        B_0x0 = 0x0,
                        ///  One sample bit method
                        B_0x1 = 0x1,
                    },
                },
                ///  Overrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data are written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used. This bit can only be written when the USART is disabled (UE=0). Note: This control bit enables checking the communication flow w/o reading the data
                OVRDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Overrun Error Flag, ORE, is set when received data is not read before receiving new data.
                        B_0x0 = 0x0,
                        ///  Overrun functionality is disabled. If new data is received while the RXNE flag is still set
                        B_0x1 = 0x1,
                    },
                },
                ///  DMA Disable on Reception Error This bit can only be written when the USART is disabled (UE=0). Note: The reception errors are: parity error, framing error or noise error.
                DDRE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred. (used for Smartcard mode)
                        B_0x0 = 0x0,
                        ///  DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE(RXFNE is case FIFO mode is enabled) before clearing the error flag.
                        B_0x1 = 0x1,
                    },
                },
                ///  Driver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Section131.4: USART implementation on page1826.
                DEM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DE function is disabled.
                        B_0x0 = 0x0,
                        ///  DE function is enabled. The DE signal is output on the RTS pin.
                        B_0x1 = 0x1,
                    },
                },
                ///  Driver enable polarity selection This bit can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                DEP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  DE signal is active high.
                        B_0x0 = 0x0,
                        ///  DE signal is active low.
                        B_0x1 = 0x1,
                    },
                },
                reserved17: u1,
                ///  Smartcard auto-retry count This bitfield specifies the number of retries for transmission and reception in Smartcard mode. In Transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set). In Reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set). This bitfield must be programmed only when the USART is disabled (UE=0). When the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission. 0x1 to 0x7: number of automatic retransmission attempts (before signaling error) Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                SCARCNT: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  retransmission disabled - No automatic retransmission in Transmission mode.
                        B_0x0 = 0x0,
                        _,
                    },
                },
                ///  Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (wake-up from low-power mode flag). This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                WUS0: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  WUF active on address match (as defined by ADD[7:0] and ADDM7)
                        B_0x0 = 0x0,
                        ///  Reserved.
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (wake-up from low-power mode flag). This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                WUS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  WUF active on address match (as defined by ADD[7:0] and ADDM7)
                        B_0x0 = 0x0,
                        ///  Reserved.
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                WUFIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever WUF=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO threshold interrupt enable This bit is set and cleared by software.
                TXFTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmission Complete before guard time, interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                TCBGTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated whenever TCBGT=1 in the USART_ISR register
                        B_0x1 = 0x1,
                    },
                },
                ///  Receive FIFO threshold configuration Remaining combinations: Reserved
                RXFTCFG: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Receive FIFO reaches 1/8 of its depth
                        B_0x0 = 0x0,
                        ///  Receive FIFO reaches 1/4 of its depth
                        B_0x1 = 0x1,
                        ///  Receive FIFO reaches 1/2 of its depth
                        B_0x2 = 0x2,
                        ///  Receive FIFO reaches 3/4 of its depth
                        B_0x3 = 0x3,
                        ///  Receive FIFO reaches 7/8 of its depth
                        B_0x4 = 0x4,
                        ///  Receive FIFO becomes full
                        B_0x5 = 0x5,
                        _,
                    },
                },
                ///  RXFIFO threshold interrupt enable This bit is set and cleared by software.
                RXFTIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Interrupt inhibited
                        B_0x0 = 0x0,
                        ///  USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO threshold configuration Remaining combinations: Reserved
                TXFTCFG: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  TXFIFO reaches 1/8 of its depth
                        B_0x0 = 0x0,
                        ///  TXFIFO reaches 1/4 of its depth
                        B_0x1 = 0x1,
                        ///  TXFIFO reaches 1/2 of its depth
                        B_0x2 = 0x2,
                        ///  TXFIFO reaches 3/4 of its depth
                        B_0x3 = 0x3,
                        ///  TXFIFO reaches 7/8 of its depth
                        B_0x4 = 0x4,
                        ///  TXFIFO becomes empty
                        B_0x5 = 0x5,
                        _,
                    },
                },
            }),
            ///  USART baud rate register
            USART_BRR: mmio.Mmio(packed struct(u32) {
                ///  USART baud rate BRR[15:4] BRR[15:4] correspond to USARTDIV[15:4] BRR[3:0] When OVER8 = 0, BRR[3:0] = USARTDIV[3:0]. When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared.
                BRR: u16,
                padding: u16,
            }),
            ///  USART guard time and prescaler register
            USART_GTPR: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value PSC[7:0] = IrDA Normal and Low-power baud rate This bitfield is used for programming the prescaler for dividing the USART source clock to achieve the low-power frequency: The source clock is divided by the value given in the register (8 significant bits): ... PSC[4:0]: Prescaler value This bitfield is used for programming the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency: ... This bitfield can only be written when the USART is disabled (UE=0). Note: Bits [7:5] must be kept cleared if Smartcard mode is used. Note: This bitfield is reserved and forced by hardware to 0 when the Smartcard and IrDA modes are not supported. Refer to Section131.4: USART implementation on page1826.
                PSC: packed union {
                    raw: u8,
                    value: enum(u8) {
                        ///  Reserved - do not program this value
                        B_0x0_SMARTCARD_MODE = 0x0,
                        ///  divides the source clock by 2
                        B_0x1_SMARTCARD_MODE = 0x1,
                        ///  divides the source clock by 4
                        B_0x2_SMARTCARD_MODE = 0x2,
                        ///  divides the source clock by 6
                        B_0x3_SMARTCARD_MODE = 0x3,
                        _,
                    },
                },
                ///  Guard time value This bitfield is used to program the Guard time value in terms of number of baud clock periods. This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value. This bitfield can only be written when the USART is disabled (UE=0). Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                GT: u8,
                padding: u16,
            }),
            ///  USART receiver timeout register
            USART_RTOR: mmio.Mmio(packed struct(u32) {
                ///  Receiver timeout value This bitfield gives the Receiver timeout value in terms of number of bit duration. In Standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value. In Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character. Note: This value must only be programmed once per received character.
                RTO: u24,
                ///  Block Length This bitfield gives the Block length in Smartcard T=1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1. Examples: BLEN = 0 -> 0 information characters + LEC BLEN = 1 -> 0 information characters + CRC BLEN = 255 -> 254 information characters + CRC (total 256 characters)) In Smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO mode is enabled). This bitfield can be used also in other modes. In this case, the Block length counter is reset when RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1. Note: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block.
                BLEN: u8,
            }),
            ///  USART request register
            USART_RQR: mmio.Mmio(packed struct(u32) {
                ///  Auto baud rate request Writing 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                ABRRQ: u1,
                ///  Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software must wait for the TXE flag assertion before setting the SBKRQ bit.
                SBKRQ: u1,
                ///  Mute mode request Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.
                MMRQ: u1,
                ///  Receive data flush request Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE. This enables to discard the received data without reading them, and avoid an overrun condition.
                RXFRQ: u1,
                ///  Transmit data flush request When FIFO mode is disabled, writing 1 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes. Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
                TXFRQ: u1,
                padding: u27,
            }),
            ///  USART interrupt and status register
            USART_ISR: mmio.Mmio(packed struct(u32) {
                ///  Parity error This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.
                PE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No parity error
                        B_0x0 = 0x0,
                        ///  Parity error
                        B_0x1 = 0x1,
                    },
                },
                ///  Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE1=11 in the USART_CR3 register. Note: This error is associated with the character in the USART_RDR.
                FE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Framing error is detected
                        B_0x0 = 0x0,
                        ///  Framing error or break character is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Noise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. Note: When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section131.5.9: Tolerance of the USART receiver to clock deviation on page1845). Note: This error is associated with the character in the USART_RDR.
                NE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No noise is detected
                        B_0x0 = 0x0,
                        ///  Noise is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXFNEIE=1 in the USART_CR1 register, or EIE = 1 in the USART_CR3 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
                ORE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overrun error
                        B_0x0 = 0x0,
                        ///  Overrun error is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). Note: If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.
                IDLE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Idle line is detected
                        B_0x0 = 0x0,
                        ///  Idle line is detected
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXFNEIE=1 in the USART_CR1 register.
                RXFNE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Data is not received
                        B_0x0 = 0x0,
                        ///  Received data is ready to be read.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag behaves as follows: When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXE/TXFE is set. When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached. When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred. When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty. An interrupt is generated if TCIE=1 in the USART_CR1 register. TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.
                TC: u1,
                ///  TXFIFO not full TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register. Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF must be checked prior to writing in TXFIFO (TXFNF and TXFE is set at the same time). Note: This bit is used during single buffer transmission.
                TXFNF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Transmit FIFO is full
                        B_0x0 = 0x0,
                        ///  Transmit FIFO is not full
                        B_0x1 = 0x1,
                    },
                },
                ///  LIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826.
                LBDF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  LIN Break not detected
                        B_0x0 = 0x0,
                        ///  LIN break detected
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS interrupt flag This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE=1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
                CTSIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No change occurred on the CTS status line
                        B_0x0 = 0x0,
                        ///  A change occurred on the CTS status line
                        B_0x1 = 0x1,
                    },
                },
                ///  CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
                CTS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CTS line set
                        B_0x0 = 0x0,
                        ///  CTS line reset
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE=1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. Note: The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
                RTOF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Timeout value not reached
                        B_0x0 = 0x0,
                        ///  Timeout value reached without any data reception
                        B_0x1 = 0x1,
                    },
                },
                ///  End of block flag This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if EOBIE1=11 in the USART_CR1 register. It is cleared by software, writing 1 to EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826.
                EOBF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  End of Block not reached
                        B_0x0 = 0x0,
                        ///  End of Block (number of characters) reached
                        B_0x1 = 0x1,
                    },
                },
                ///  SPI slave underrun error flag In Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826.
                UDR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No underrun error
                        B_0x0 = 0x0,
                        ///  underrun error
                        B_0x1 = 0x1,
                    },
                },
                ///  Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
                ABRE: u1,
                ///  Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
                ABRF: u1,
                ///  Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
                BUSY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  USART is idle (no reception)
                        B_0x0 = 0x0,
                        ///  Reception on going
                        B_0x1 = 0x1,
                    },
                },
                ///  Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIE=1in the USART_CR1 register.
                CMF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No Character match detected
                        B_0x0 = 0x0,
                        ///  Character match detected
                        B_0x1 = 0x1,
                    },
                },
                ///  Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
                SBKF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break character transmitted
                        B_0x0 = 0x0,
                        ///  Break character transmitted
                        B_0x1 = 0x1,
                    },
                },
                ///  Receiver wake-up from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826.
                RWU: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receiver in Active mode
                        B_0x0 = 0x0,
                        ///  Receiver in Mute mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Wake-up from low-power mode flag This bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE=1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826.
                WUF: u1,
                ///  Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.
                TEACK: u1,
                ///  Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826.
                REACK: u1,
                ///  TXFIFO Empty This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register. An interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.
                TXFE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TXFIFO not empty.
                        B_0x0 = 0x0,
                        ///  TXFIFO empty.
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO Full This bit is set by hardware when the number of received data corresponds to RXFIFO1size1+11 (RXFIFO full + 1 data in the USART_RDR register. An interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.
                RXFF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  RXFIFO not full.
                        B_0x0 = 0x0,
                        ///  RXFIFO Full.
                        B_0x1 = 0x1,
                    },
                },
                ///  Transmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is 1. Refer to Section131.4: USART implementation on page1826.
                TCBGT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)
                        B_0x0 = 0x0,
                        ///  Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).
                        B_0x1 = 0x1,
                    },
                },
                ///  RXFIFO threshold flag This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register. Note: When the RXFTCFG threshold is configured to 101, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.
                RXFT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Receive FIFO does not reach the programmed threshold.
                        B_0x0 = 0x0,
                        ///  Receive FIFO reached the programmed threshold.
                        B_0x1 = 0x1,
                    },
                },
                ///  TXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.
                TXFT: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TXFIFO does not reach the programmed threshold.
                        B_0x0 = 0x0,
                        ///  TXFIFO reached the programmed threshold.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            ///  USART interrupt flag clear register
            USART_ICR: mmio.Mmio(packed struct(u32) {
                ///  Parity error clear flag Writing 1 to this bit clears the PE flag in the USART_ISR register.
                PECF: u1,
                ///  Framing error clear flag Writing 1 to this bit clears the FE flag in the USART_ISR register.
                FECF: u1,
                ///  Noise detected clear flag Writing 1 to this bit clears the NE flag in the USART_ISR register.
                NECF: u1,
                ///  Overrun error clear flag Writing 1 to this bit clears the ORE flag in the USART_ISR register.
                ORECF: u1,
                ///  Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the USART_ISR register.
                IDLECF: u1,
                ///  TXFIFO empty clear flag Writing 1 to this bit clears the TXFE flag in the USART_ISR register.
                TXFECF: u1,
                ///  Transmission complete clear flag Writing 1 to this bit clears the TC flag in the USART_ISR register.
                TCCF: u1,
                ///  Transmission complete before Guard time clear flag Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.
                TCBGTCF: u1,
                ///  LIN break detection clear flag Writing 1 to this bit clears the LBDF flag in the USART_ISR register. Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                LBDCF: u1,
                ///  CTS clear flag Writing 1 to this bit clears the CTSIF flag in the USART_ISR register. Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                CTSCF: u1,
                reserved11: u1,
                ///  Receiver timeout clear flag Writing 1 to this bit clears the RTOF flag in the USART_ISR register. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                RTOCF: u1,
                ///  End of block clear flag Writing 1 to this bit clears the EOBF flag in the USART_ISR register. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                EOBCF: u1,
                ///  SPI slave underrun clear flag Writing 1 to this bit clears the UDRF flag in the USART_ISR register. Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826
                UDRCF: u1,
                reserved17: u3,
                ///  Character match clear flag Writing 1 to this bit clears the CMF flag in the USART_ISR register.
                CMCF: u1,
                reserved20: u2,
                ///  Wake-up from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. Note: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.
                WUCF: u1,
                padding: u11,
            }),
            ///  USART receive data register
            USART_RDR: mmio.Mmio(packed struct(u32) {
                ///  Receive data value Contains the received data character. The RDR register provides the parallel interface between the input shift register and the internal bus (see Figure1227). When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
                RDR: u9,
                padding: u23,
            }),
            ///  USART transmit data register
            USART_TDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data value Contains the data character to be transmitted. The USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure1227). When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity. Note: This register must be written only when TXE/TXFNF=1.
                TDR: u9,
                padding: u23,
            }),
            ///  USART prescaler register
            USART_PRESC: mmio.Mmio(packed struct(u32) {
                ///  Clock prescaler The USART input clock can be divided by a prescaler factor: Remaining combinations: Reserved Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256.
                PRESCALER: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  input clock not divided
                        B_0x0 = 0x0,
                        ///  input clock divided by 2
                        B_0x1 = 0x1,
                        ///  input clock divided by 4
                        B_0x2 = 0x2,
                        ///  input clock divided by 6
                        B_0x3 = 0x3,
                        ///  input clock divided by 8
                        B_0x4 = 0x4,
                        ///  input clock divided by 10
                        B_0x5 = 0x5,
                        ///  input clock divided by 12
                        B_0x6 = 0x6,
                        ///  input clock divided by 16
                        B_0x7 = 0x7,
                        ///  input clock divided by 32
                        B_0x8 = 0x8,
                        ///  input clock divided by 64
                        B_0x9 = 0x9,
                        ///  input clock divided by 128
                        B_0xA = 0xa,
                        ///  input clock divided by 256
                        B_0xB = 0xb,
                        _,
                    },
                },
                padding: u28,
            }),
        };

        ///  SYSCFG register block
        pub const SYSCFG = extern struct {
            ///  SYSCFG configuration register 1
            SYSCFG_CFGR1: mmio.Mmio(packed struct(u32) {
                ///  Memory mapping selection bits These bits are set and cleared by software. They control the memory internal mapping at address 0x000010000. After reset these bits take on the value selected by the actual boot mode configuration. Refer to Section12.5: Boot configuration for more details. X0: Main flash memory mapped at 0x000010000
                MEM_MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  System flash memory mapped at 0x000010000
                        B_0x1 = 0x1,
                        ///  Embedded SRAM mapped at 0x000010000
                        B_0x3 = 0x3,
                        _,
                    },
                },
                reserved3: u1,
                ///  PA11 pin remapping This bit is set and cleared by software. When set, it remaps the PA11 pin to operate as PA9 GPIO port, instead as PA11 GPIO port.
                PA11_RMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remap (PA11)
                        B_0x0 = 0x0,
                        ///  Remap (PA9)
                        B_0x1 = 0x1,
                    },
                },
                ///  PA12 pin remapping This bit is set and cleared by software. When set, it remaps the PA12 pin to operate as PA10 GPIO port, instead as PA12 GPIO port.
                PA12_RMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remap (PA12)
                        B_0x0 = 0x0,
                        ///  Remap (PA10)
                        B_0x1 = 0x1,
                    },
                },
                ///  IR output polarity selection
                IR_POL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Output of IRTIM (IR_OUT) is not inverted
                        B_0x0 = 0x0,
                        ///  Output of IRTIM (IR_OUT) is inverted
                        B_0x1 = 0x1,
                    },
                },
                ///  IR Modulation Envelope signal selection This bitfield selects the signal for IR modulation envelope:
                IR_MOD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  TIM16
                        B_0x0 = 0x0,
                        ///  USART1
                        B_0x1 = 0x1,
                        ///  USART2
                        B_0x2 = 0x2,
                        _,
                    },
                },
                ///  I/O analog switch voltage booster enable This bit selects the way of supplying I/O analog switches: When using the analog inputs , setting to 0 is recommended for high V<sub>DD</sub>, setting to 1 for low V<sub>DD</sub> (less than 2.4 V).
                BOOSTEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  V<sub>DD</sub>
                        B_0x0 = 0x0,
                        ///  Dedicated voltage booster (supplied by V<sub>DD</sub>)
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u7,
                ///  Fast Mode Plus (FM+) enable for PB6 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB6 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C_PB6_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Fast Mode Plus (FM+) enable for PB7 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB7 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C_PB7_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Fast Mode Plus (FM+) enable for PB8 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB8 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C_PB8_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Fast Mode Plus (FM+) enable for PB9 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB9 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C_PB9_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                reserved22: u2,
                ///  Fast Mode Plus (FM+) enable for PA9 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA9 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C_PA9_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Fast Mode Plus (FM+) enable for PA10 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA10 I/O port. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C_PA10_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                ///  Fast Mode Plus (FM+) enable for I2C3 This bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C3 through GPIOx_AFR registers. With this bit in disable state, the I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C3 can be enabled through their corresponding I2Cx_FMP bit. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored. Note: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead.
                I2C3_FMP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disable
                        B_0x0 = 0x0,
                        ///  Enable
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            reserved24: [20]u8,
            ///  SYSCFG configuration register 2
            SYSCFG_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP bit enable bit This bit is set by software and cleared by a system reset. It can be use to enable and lock the connection of Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP (Hardfault) output to TIM1/15/16 Break input.
                CCL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP output disconnected from TIM1/15/16 Break input
                        B_0x0 = 0x0,
                        ///  Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP output connected to TIM1/15/16 Break input
                        B_0x1 = 0x1,
                    },
                },
                ///  SRAM1 parity lock bit This bit is set by software and cleared by a system reset. It can be used to enable and lock the SRAM1 parity error signal connection to TIM1/15/16 Break input.
                SPL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SRAM1 parity error disconnected from TIM1/15/16 Break input
                        B_0x0 = 0x0,
                        ///  SRAM1 parity error connected to TIM1/15/16 Break input
                        B_0x1 = 0x1,
                    },
                },
                ///  PVD lock enable bit This bit is set by software and cleared by a system reset. It can be used to enable and lock the PVD connection to TIM1/15/16 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR register.
                PVDL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  PVD interrupt disconnected from TIM1/15/16 Break input. PVDE and PLS[2:0] bits can be programmed by the application.
                        B_0x0 = 0x0,
                        ///  PVD interrupt connected to TIM1/15/16 Break input, PVDE and PLS[2:0] bits are read only.
                        B_0x1 = 0x1,
                    },
                },
                ///  ECC error lock bit This bit is set by software and cleared by a system reset. It can be used to enable and lock the flash ECC 2-bit error detection signal connection to TIM1/15/16 Break input.
                ECCL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ECC error disconnected from TIM1/15/16 Break input
                        B_0x0 = 0x0,
                        ///  ECC error connected to TIM1/15/16 Break input
                        B_0x1 = 0x1,
                    },
                },
                ///  Backup SRAM2 parity lock This bit is set by software and cleared by a system reset. It can be used to enable and lock the SRAM2 parity error signal connection to TIM1/15/16 Break input.
                BKPL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  SRAM2 parity error disconnected from TIM1/15/16 Break input
                        B_0x0 = 0x0,
                        ///  SRAM2 parity error connected to TIM1/15/16 Break input
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u2,
                ///  Backup SRAM2 parity error flag This bit is set by hardware when an SRAM2 parity error is detected. It is cleared by software by writing 1.
                BKPF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SRAM2 parity error detected
                        B_0x0 = 0x0,
                        ///  SRAM2 parity error detected
                        B_0x1 = 0x1,
                    },
                },
                ///  SRAM1 parity error flag This bit is set by hardware when an SRAM1 parity error is detected. It is cleared by software by writing 1.
                SPF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SRAM1 parity error detected
                        B_0x0 = 0x0,
                        ///  SRAM1 parity error detected
                        B_0x1 = 0x1,
                    },
                },
                padding: u23,
            }),
            ///  SYSCFG SRAM2 control and status register
            SYSCFG_SCSR: mmio.Mmio(packed struct(u32) {
                ///  SRAM2 erase Setting this bit starts a hardware SRAM2 erase operation. This bit is automatically cleared at the end of the SRAM2 erase operation. Note: This bit is write-protected: setting this bit is possible only after the correct key sequence is written in the SYSCFG_SKR register.
                SRAM2ER: u1,
                ///  SRAM2 busy by erase operation
                SRAM2BSY: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No SRAM2 erase operation is ongoing
                        B_0x0 = 0x0,
                        ///  SRAM2 erase operation is ongoing
                        B_0x1 = 0x1,
                    },
                },
                padding: u30,
            }),
            ///  SYSCFG SRAM2 key register
            SYSCFG_SKR: mmio.Mmio(packed struct(u32) {
                ///  SRAM2 write protection key for software erase The following steps are required to unlock the write protection of the SRAM2ER bit in the SYSCFG_CFGR2 register: Write 0xCA into KEY[7:0] Write 0x53 into KEY[7:0] Writing a wrong key reactivates the write protection.
                KEY: u8,
                padding: u24,
            }),
            ///  SYSCFG TSC comparator register
            SYSCFG_TSCCR: mmio.Mmio(packed struct(u32) {
                ///  Comparator mode for group 2 on I/O 1
                G2_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enable connection of PB4 to COMP2
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator mode for group 2 on I/O 3
                G2_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enable connection of PB6 to COMP2
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator mode for group 4 on I/O 3
                G4_IO3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enable connection of PC6 to COMP2
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator mode for group 6 on I/O 1
                G6_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enable connection of PD10 to COMP1
                        B_0x1 = 0x1,
                    },
                },
                ///  Comparator mode for group 7 on I/O 1
                G7_IO1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Disabled
                        B_0x0 = 0x0,
                        ///  Enable connection of PA9 to COMP1
                        B_0x1 = 0x1,
                    },
                },
                ///  I/O control in comparator mode The I/O control in comparator mode can be overwritten by hardware.
                TSC_IOCTRL: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  I/O configured through the corresponding control register
                        B_0x0 = 0x0,
                        ///  I/O configured as analog when TSC AF is activated
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            reserved128: [88]u8,
            ///  SYSCFG interrupt line 0 status register
            SYSCFG_ITLINE0: mmio.Mmio(packed struct(u32) {
                ///  Window watchdog interrupt pending flag
                WWDG: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 1 status register
            SYSCFG_ITLINE1: mmio.Mmio(packed struct(u32) {
                ///  PVD supply monitoring interrupt request pending (EXTI line 16).
                PVDOUT: u1,
                ///  V<sub>DDUSB</sub> supply monitoring interrupt request pending (EXTI line 19)
                PVMOUT1: u1,
                ///  ADC supply monitoring interrupt request pending (EXTI line 20)
                PVMOUT3: u1,
                ///  DAC supply monitoring interrupt request pending (EXTI line 21)
                PVMOUT4: u1,
                padding: u28,
            }),
            ///  SYSCFG interrupt line 2 status register
            SYSCFG_ITLINE2: mmio.Mmio(packed struct(u32) {
                ///  Tamper interrupt request pending (EXTI line 21)
                TAMP: u1,
                ///  RTC interrupt request pending (EXTI line 19)
                RTC: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 3 status register
            SYSCFG_ITLINE3: mmio.Mmio(packed struct(u32) {
                ///  Flash interface interrupt request pending
                FLASH_ITF: u1,
                ///  Flash interface ECC interrupt request pending
                FLASH_ECC: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 4 status register
            SYSCFG_ITLINE4: mmio.Mmio(packed struct(u32) {
                ///  Reset and clock control interrupt request pending
                RCC: u1,
                ///  CRS interrupt request pending
                CRS: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 5 status register
            SYSCFG_ITLINE5: mmio.Mmio(packed struct(u32) {
                ///  EXTI line 0 interrupt request pending
                EXTI0: u1,
                ///  EXTI line 1 interrupt request pending
                EXTI1: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 6 status register
            SYSCFG_ITLINE6: mmio.Mmio(packed struct(u32) {
                ///  EXTI line 2 interrupt request pending
                EXTI2: u1,
                ///  EXTI line 3 interrupt request pending
                EXTI3: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 7 status register
            SYSCFG_ITLINE7: mmio.Mmio(packed struct(u32) {
                ///  EXTI line 4 interrupt request pending
                EXTI4: u1,
                ///  EXTI line 5 interrupt request pending
                EXTI5: u1,
                ///  EXTI line 6 interrupt request pending
                EXTI6: u1,
                ///  EXTI line 7 interrupt request pending
                EXTI7: u1,
                ///  EXTI line 8 interrupt request pending
                EXTI8: u1,
                ///  EXTI line 9 interrupt request pending
                EXTI9: u1,
                ///  EXTI line 10 interrupt request pending
                EXTI10: u1,
                ///  EXTI line 11 interrupt request pending
                EXTI11: u1,
                ///  EXTI line 12 interrupt request pending
                EXTI12: u1,
                ///  EXTI line 13 interrupt request pending
                EXTI13: u1,
                ///  EXTI line 14 interrupt request pending
                EXTI14: u1,
                ///  EXTI line 15 interrupt request pending
                EXTI15: u1,
                padding: u20,
            }),
            ///  SYSCFG interrupt line 8 status register
            SYSCFG_ITLINE8: mmio.Mmio(packed struct(u32) {
                ///  USB interrupt request pending
                USB: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 9 status register
            SYSCFG_ITLINE9: mmio.Mmio(packed struct(u32) {
                ///  DMA1 channel 1 interrupt request pending
                DMA1_CH1: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 10 status register
            SYSCFG_ITLINE10: mmio.Mmio(packed struct(u32) {
                ///  DMA1 channel 2 interrupt request pending
                DMA1_CH2: u1,
                ///  DMA1 channel 3 interrupt request pending
                DMA1_CH3: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 11 status register
            SYSCFG_ITLINE11: mmio.Mmio(packed struct(u32) {
                ///  DMAMUX interrupt request pending
                DMAMUX: u1,
                ///  DMA1 channel 4 interrupt request pending
                DMA1_CH4: u1,
                ///  DMA1 channel 5 interrupt request pending
                DMA1_CH5: u1,
                ///  DMA1 channel 6 interrupt request pending
                DMA1_CH6: u1,
                ///  DMA1 channel 7 interrupt request pending
                DMA1_CH7: u1,
                ///  DMA2 channel 1 interrupt request pending
                DMA2_CH1: u1,
                ///  DMA2 channel 2 interrupt request pending
                DMA2_CH2: u1,
                ///  DMA2 channel 3 interrupt request pending
                DMA2_CH3: u1,
                ///  DMA2 channel 4 interrupt request pending
                DMA2_CH4: u1,
                ///  DMA2 channel 5 interrupt request pending
                DMA2_CH5: u1,
                padding: u22,
            }),
            ///  SYSCFG interrupt line 12 status register
            SYSCFG_ITLINE12: mmio.Mmio(packed struct(u32) {
                ///  ADC interrupt request pending
                ADC: u1,
                ///  Comparator 1 interrupt request pending (EXTI line 17)
                COMP1: u1,
                ///  Comparator 2 interrupt request pending (EXTI line 18)
                COMP2: u1,
                padding: u29,
            }),
            ///  SYSCFG interrupt line 13 status register
            SYSCFG_ITLINE13: mmio.Mmio(packed struct(u32) {
                ///  Timer 1 commutation interrupt request pending
                TIM1_CCU: u1,
                ///  Timer 1 trigger interrupt request pending
                TIM1_TRG: u1,
                ///  Timer 1 update interrupt request pending
                TIM1_UPD: u1,
                ///  Timer 1 break interrupt request pending
                TIM1_BRK: u1,
                padding: u28,
            }),
            ///  SYSCFG interrupt line 14 status register
            SYSCFG_ITLINE14: mmio.Mmio(packed struct(u32) {
                ///  Timer 1 capture compare 1 interrupt request pending
                TIM1_CC1: u1,
                ///  Timer 1 capture compare 2 interrupt request pending
                TIM1_CC2: u1,
                ///  Timer 1 capture compare 3 interrupt request pending
                TIM1_CC3: u1,
                ///  Timer 1 capture compare 4 interrupt request pending
                TIM1_CC4: u1,
                padding: u28,
            }),
            ///  SYSCFG interrupt line 15 status register
            SYSCFG_ITLINE15: mmio.Mmio(packed struct(u32) {
                ///  Timer 2 interrupt request pending
                TIM2: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 16 status register
            SYSCFG_ITLINE16: mmio.Mmio(packed struct(u32) {
                ///  Timer 3 interrupt request pending
                TIM3: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 17 status register
            SYSCFG_ITLINE17: mmio.Mmio(packed struct(u32) {
                ///  Timer 6 interrupt request pending
                TIM6: u1,
                ///  DAC underrun interrupt request pending
                DAC: u1,
                ///  Low-power timer 1 interrupt request pending (EXTI line 29)
                LPTIM1: u1,
                padding: u29,
            }),
            ///  SYSCFG interrupt line 18 status register
            SYSCFG_ITLINE18: mmio.Mmio(packed struct(u32) {
                ///  Timer 7 interrupt request pending
                TIM7: u1,
                ///  Low-power timer 2 interrupt request pending (EXTI line 30)
                LPTIM2: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 19 status register
            SYSCFG_ITLINE19: mmio.Mmio(packed struct(u32) {
                ///  Timer 15 interrupt request pending
                TIM15: u1,
                ///  Low-power timer 3 interrupt request pending
                LPTIM3: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 20 status register
            SYSCFG_ITLINE20: mmio.Mmio(packed struct(u32) {
                ///  Timer 16 interrupt request pending
                TIM16: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 21 status register
            SYSCFG_ITLINE21: mmio.Mmio(packed struct(u32) {
                ///  TSC max count error interrupt request pending
                TSC_MCE: u1,
                ///  TSC end of acquisition interrupt request pending
                TSC_EOA: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 22 status register
            SYSCFG_ITLINE22: mmio.Mmio(packed struct(u32) {
                ///  LCD interrupt request pending
                LCD: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 23 status register
            SYSCFG_ITLINE23: mmio.Mmio(packed struct(u32) {
                ///  I2C1 interrupt request pending (EXTI line 33)
                I2C1: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 24 status register
            SYSCFG_ITLINE24: mmio.Mmio(packed struct(u32) {
                ///  I2C2 interrupt request pending
                I2C2: u1,
                ///  I2C4 interrupt request pending
                I2C4: u1,
                ///  I2C3 interrupt request pending (EXTI line 23)
                I2C3: u1,
                padding: u29,
            }),
            ///  SYSCFG interrupt line 25 status register
            SYSCFG_ITLINE25: mmio.Mmio(packed struct(u32) {
                ///  SPI1 interrupt request pending
                SPI1: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 26 status register
            SYSCFG_ITLINE26: mmio.Mmio(packed struct(u32) {
                ///  SPI2 interrupt request pending
                SPI2: u1,
                ///  SPI3 interrupt request pending
                SPI3: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 27 status register
            SYSCFG_ITLINE27: mmio.Mmio(packed struct(u32) {
                ///  USART1 interrupt request pending, combined with EXTI line 25
                USART1: u1,
                padding: u31,
            }),
            ///  SYSCFG interrupt line 28 status register
            SYSCFG_ITLINE28: mmio.Mmio(packed struct(u32) {
                ///  USART2 interrupt request pending (EXTI line 35)
                USART2: u1,
                ///  LPUART2 interrupt request pending (EXTI line 31)
                LPUART2: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 29 status register
            SYSCFG_ITLINE29: mmio.Mmio(packed struct(u32) {
                ///  USART3 interrupt request pending
                USART3: u1,
                ///  LPUART1 interrupt request pending (EXTI line 30)
                LPUART1: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 30 status register
            SYSCFG_ITLINE30: mmio.Mmio(packed struct(u32) {
                ///  USART4 interrupt request pending
                USART4: u1,
                ///  LPUART3 interrupt request pending (EXTI line 32)
                LPUART3: u1,
                padding: u30,
            }),
            ///  SYSCFG interrupt line 31 status register
            SYSCFG_ITLINE31: mmio.Mmio(packed struct(u32) {
                ///  RNG interrupt request pending
                RNG: u1,
                ///  AES interrupt request pending
                AES: u1,
                padding: u30,
            }),
        };

        ///  TAMP register block
        pub const TAMP = extern struct {
            ///  TAMP control register 1
            TAMP_CR1: mmio.Mmio(packed struct(u32) {
                ///  Tamper detection on TAMP_IN1 enable
                TAMP1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper detection on TAMP_IN1 is disabled.
                        B_0x0 = 0x0,
                        ///  Tamper detection on TAMP_IN1 is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper detection on TAMP_IN2 enable<sup>(1)</sup>
                TAMP2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper detection on TAMP_IN2 is disabled.
                        B_0x0 = 0x0,
                        ///  Tamper detection on TAMP_IN2 is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper detection on TAMP_IN3 enable<sup>(1)</sup>
                TAMP3E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper detection on TAMP_IN3 is disabled.
                        B_0x0 = 0x0,
                        ///  Tamper detection on TAMP_IN3 is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper detection on TAMP_IN4 enable<sup>(1)</sup>
                TAMP4E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper detection on TAMP_IN4 is disabled.
                        B_0x0 = 0x0,
                        ///  Tamper detection on TAMP_IN4 is enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper detection on TAMP_IN5 enable<sup>(1)</sup>
                TAMP5E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper detection on TAMP_IN5 is disabled.
                        B_0x0 = 0x0,
                        ///  Tamper detection on TAMP_IN5 is enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved18: u13,
                ///  Internal tamper 3 enable
                ITAMP3E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 3 disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 3 enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 4 enable
                ITAMP4E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 4 disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 4 enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 5 enable
                ITAMP5E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 5 disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 5 enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 6 enable
                ITAMP6E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 6 disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 6 enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            ///  TAMP control register 2
            TAMP_CR2: mmio.Mmio(packed struct(u32) {
                ///  Tamper 1 potential mode
                TAMP1POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 1 event detection is in confirmed mode.
                        B_0x0 = 0x0,
                        ///  Tamper 1 event detection is in potential mode.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 2 potential mode
                TAMP2POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 2 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Tamper 2 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 3 potential mode
                TAMP3POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 3 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Tamper 3 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 4 potential mode
                TAMP4POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 4 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Tamper 4 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 5 potential mode
                TAMP5POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 5 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Tamper 5 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u11,
                ///  Tamper 1 mask The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
                TAMP1MSK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 1 event generates a trigger event and TAMP1F must be cleared by software to allow next tamper event detection.
                        B_0x0 = 0x0,
                        ///  Tamper 1 event generates a trigger event. TAMP1F is masked and internally cleared by hardware. The backup registers and device secrets<sup>(1)</sup> are not erased.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 2 mask The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
                TAMP2MSK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 2 event generates a trigger event and TAMP2F must be cleared by software to allow next tamper event detection.
                        B_0x0 = 0x0,
                        ///  Tamper 2 event generates a trigger event. TAMP2F is masked and internally cleared by hardware. The backup registers and device secrets<sup>(1)</sup> are not erased.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 3 mask The tamper 3 interrupt must not be enabled when TAMP3MSK is set.
                TAMP3MSK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 3 event generates a trigger event and TAMP3F must be cleared by software to allow next tamper event detection.
                        B_0x0 = 0x0,
                        ///  Tamper 3 event generates a trigger event. TAMP3F is masked and internally cleared by hardware. The backup registers and device secrets<sup>(1)</sup> are not erased.
                        B_0x1 = 0x1,
                    },
                },
                reserved22: u3,
                ///  Backup registers and device secrets<sup>(1)</sup> access blocked
                BKBLOCK: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  backup registers and device secrets<sup>(1)</sup> can be accessed if no tamper flag is set
                        B_0x0 = 0x0,
                        ///  backup registers and device secrets<sup>(1)</sup> cannot be accessed
                        B_0x1 = 0x1,
                    },
                },
                ///  Backup registers and device secrets<sup>(1)</sup> erase Writing 1 to this bit reset the backup registers and device secrets<sup>(1)</sup>. Writing 0 has no effect. This bit is always read as 0.
                BKERASE: u1,
                ///  Active level for tamper 1 input If TAMPFLT1=100 tamper 1 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 1 input falling edge triggers a tamper detection event.
                TAMP1TRG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  If TAMPFLT different from 00 tamper 1 input staying low triggers a tamper detection event
                        B_0x0 = 0x0,
                        ///  If TAMPFLT different from 00 tamper 1 input staying low triggers a tamper detection event
                        B_0x1 = 0x1,
                    },
                },
                ///  Active level for tamper 2 input If TAMPFLT = 00 tamper 2 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 2 input falling edge triggers a tamper detection event.
                TAMP2TRG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  If TAMPFLT different from 00 tamper 2 input staying low triggers a tamper detection event
                        B_0x0 = 0x0,
                        ///  If TAMPFLT different from 00 tamper 2 input staying low triggers a tamper detection event
                        B_0x1 = 0x1,
                    },
                },
                ///  Active level for tamper 3 input If TAMPFLT1=100 tamper 3 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 3 input falling edge triggers a tamper detection event.
                TAMP3TRG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  If TAMPFLT different from 00 tamper 3 input staying low triggers a tamper detection event
                        B_0x0 = 0x0,
                        ///  If TAMPFLT different from 00 tamper 3 input staying low triggers a tamper detection event
                        B_0x1 = 0x1,
                    },
                },
                ///  Active level for tamper 4 input (active mode disabled) If TAMPFLT1=100 tamper 4 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 4 input falling edge triggers a tamper detection event.
                TAMP4TRG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  If TAMPFLT different from 00 tamper 4 input staying low triggers a tamper detection event
                        B_0x0 = 0x0,
                        ///  If TAMPFLT different from 00 tamper 4 input staying low triggers a tamper detection event
                        B_0x1 = 0x1,
                    },
                },
                ///  Active level for tamper 5 input (active mode disabled) If TAMPFLT1=100 tamper 5 input rising edge triggers a tamper detection event. If TAMPFLT1=100 tamper 5 input falling edge triggers a tamper detection event.
                TAMP5TRG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  If TAMPFLT different from 00 tamper 5 input staying low triggers a tamper detection event
                        B_0x0 = 0x0,
                        ///  If TAMPFLT different from 00 tamper 5 input staying low triggers a tamper detection event
                        B_0x1 = 0x1,
                    },
                },
                padding: u3,
            }),
            ///  TAMP control register 3
            TAMP_CR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Internal tamper 3 potential mode
                ITAMP3POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 3 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Internal tamper 3 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 4 potential mode
                ITAMP4POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 4 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Internal tamper 4 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 5 potential mode
                ITAMP5POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 5 event detection is in confirmed mode<sup>(1)</sup>.
                        B_0x0 = 0x0,
                        ///  Internal tamper 5 event detection is in potential mode<sup>(2)</sup>.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 6 potential mode
                ITAMP6POM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 6 event detection is in confirmed mode.
                        B_0x0 = 0x0,
                        ///  Internal tamper 6 event detection is in potential mode.
                        B_0x1 = 0x1,
                    },
                },
                padding: u26,
            }),
            ///  TAMP filter control register
            TAMP_FLTCR: mmio.Mmio(packed struct(u32) {
                ///  Tamper sampling frequency Determines the frequency at which each of the TAMP_INx inputs are sampled.
                TAMPFREQ: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  RTCCLK / 32768 (11Hz when RTCCLK = 327681Hz)
                        B_0x0 = 0x0,
                        ///  RTCCLK / 16384 (21Hz when RTCCLK = 327681Hz)
                        B_0x1 = 0x1,
                        ///  RTCCLK / 8192 (41Hz when RTCCLK = 327681Hz)
                        B_0x2 = 0x2,
                        ///  RTCCLK / 4096 (81Hz when RTCCLK = 327681Hz)
                        B_0x3 = 0x3,
                        ///  RTCCLK / 2048 (161Hz when RTCCLK = 327681Hz)
                        B_0x4 = 0x4,
                        ///  RTCCLK / 1024 (321Hz when RTCCLK = 327681Hz)
                        B_0x5 = 0x5,
                        ///  RTCCLK / 512 (641Hz when RTCCLK = 327681Hz)
                        B_0x6 = 0x6,
                        ///  RTCCLK / 256 (1281Hz when RTCCLK = 327681Hz)
                        B_0x7 = 0x7,
                    },
                },
                ///  TAMP_INx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
                TAMPFLT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Tamper event is activated on edge of TAMP_INx input transitions to the active level (no internal pull-up on TAMP_INx input).
                        B_0x0 = 0x0,
                        ///  Tamper event is activated after 2 consecutive samples at the active level.
                        B_0x1 = 0x1,
                        ///  Tamper event is activated after 4 consecutive samples at the active level.
                        B_0x2 = 0x2,
                        ///  Tamper event is activated after 8 consecutive samples at the active level.
                        B_0x3 = 0x3,
                    },
                },
                ///  TAMP_INx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
                TAMPPRCH: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  1 RTCCLK cycle
                        B_0x0 = 0x0,
                        ///  2 RTCCLK cycles
                        B_0x1 = 0x1,
                        ///  4 RTCCLK cycles
                        B_0x2 = 0x2,
                        ///  8 RTCCLK cycles
                        B_0x3 = 0x3,
                    },
                },
                ///  TAMP_INx pull-up disable This bit determines if each of the TAMPx pins are precharged before each sample.
                TAMPPUDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Precharge TAMP_INx pins before sampling (enable internal pull-up)
                        B_0x0 = 0x0,
                        ///  Disable precharge of TAMP_INx pins.
                        B_0x1 = 0x1,
                    },
                },
                padding: u24,
            }),
            reserved44: [28]u8,
            ///  TAMP interrupt enable register
            TAMP_IER: mmio.Mmio(packed struct(u32) {
                ///  Tamper 1 interrupt enable
                TAMP1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 1 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Tamper 1 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 2 interrupt enable
                TAMP2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 2 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Tamper 2 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 3 interrupt enable
                TAMP3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 3 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Tamper 3 interrupt enabled..
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 4 interrupt enable
                TAMP4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 4 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Tamper 4 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Tamper 5 interrupt enable
                TAMP5IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Tamper 5 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Tamper 5 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved18: u13,
                ///  Internal tamper 3 interrupt enable
                ITAMP3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 3 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 3 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 4 interrupt enable
                ITAMP4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 4 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 4 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 5 interrupt enable
                ITAMP5IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 5 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 5 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Internal tamper 6 interrupt enable
                ITAMP6IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Internal tamper 6 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Internal tamper 6 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u10,
            }),
            ///  TAMP status register
            TAMP_SR: mmio.Mmio(packed struct(u32) {
                ///  TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
                TAMP1F: u1,
                ///  TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
                TAMP2F: u1,
                ///  TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP3 input.
                TAMP3F: u1,
                ///  TAMP4 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP4 input.
                TAMP4F: u1,
                ///  TAMP5 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP5 input.
                TAMP5F: u1,
                reserved18: u13,
                ///  Internal tamper 3 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
                ITAMP3F: u1,
                ///  Internal tamper 4 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 4.
                ITAMP4F: u1,
                ///  Internal tamper 5 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
                ITAMP5F: u1,
                ///  Internal tamper 6 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
                ITAMP6F: u1,
                padding: u10,
            }),
            ///  TAMP masked interrupt status register
            TAMP_MISR: mmio.Mmio(packed struct(u32) {
                ///  TAMP1 interrupt masked flag This flag is set by hardware when the tamper 1 interrupt is raised.
                TAMP1MF: u1,
                ///  TAMP2 interrupt masked flag This flag is set by hardware when the tamper 2 interrupt is raised.
                TAMP2MF: u1,
                ///  TAMP3 interrupt masked flag This flag is set by hardware when the tamper 3 interrupt is raised.
                TAMP3MF: u1,
                ///  TAMP4 interrupt masked flag This flag is set by hardware when the tamper 4 interrupt is raised.
                TAMP4MF: u1,
                ///  TAMP5 interrupt masked flag This flag is set by hardware when the tamper 5 interrupt is raised.
                TAMP5MF: u1,
                reserved18: u13,
                ///  Internal tamper 3 interrupt masked flag This flag is set by hardware when the internal tamper 3 interrupt is raised.
                ITAMP3MF: u1,
                ///  Internal tamper 4 interrupt masked flag This flag is set by hardware when the internal tamper 4 interrupt is raised.
                ITAMP4MF: u1,
                ///  Internal tamper 5 interrupt masked flag This flag is set by hardware when the internal tamper 5 interrupt is raised.
                ITAMP5MF: u1,
                ///  Internal tamper 6 interrupt masked flag This flag is set by hardware when the internal tamper 6 interrupt is raised.
                ITAMP6MF: u1,
                padding: u10,
            }),
            reserved60: [4]u8,
            ///  TAMP status clear register
            TAMP_SCR: mmio.Mmio(packed struct(u32) {
                ///  Clear TAMP1 detection flag Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
                CTAMP1F: u1,
                ///  Clear TAMP2 detection flag Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
                CTAMP2F: u1,
                ///  Clear TAMP3 detection flag Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
                CTAMP3F: u1,
                ///  Clear TAMP4 detection flag Writing 1 in this bit clears the TAMP4F bit in the TAMP_SR register.
                CTAMP4F: u1,
                ///  Clear TAMP5 detection flag Writing 1 in this bit clears the TAMP5F bit in the TAMP_SR register.
                CTAMP5F: u1,
                reserved18: u13,
                ///  Clear ITAMP3 detection flag Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
                CITAMP3F: u1,
                ///  Clear ITAMP4 detection flag Writing 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
                CITAMP4F: u1,
                ///  Clear ITAMP5 detection flag Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
                CITAMP5F: u1,
                ///  Clear ITAMP6 detection flag Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
                CITAMP6F: u1,
                padding: u10,
            }),
            reserved256: [192]u8,
            ///  TAMP backup 0 register
            TAMP_BKP0R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 1 register
            TAMP_BKP1R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 2 register
            TAMP_BKP2R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 3 register
            TAMP_BKP3R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 4 register
            TAMP_BKP4R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 5 register
            TAMP_BKP5R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 6 register
            TAMP_BKP6R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 7 register
            TAMP_BKP7R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
            ///  TAMP backup 8 register
            TAMP_BKP8R: mmio.Mmio(packed struct(u32) {
                ///  The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
                BKP: u32,
            }),
        };

        ///  TIM1 address block description
        pub const TIM1 = extern struct {
            ///  TIM1 control register 1
            TIM1_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled. The Update (UEV) event is generated by one of the following events:
                        B_0x0 = 0x0,
                        ///  UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generate an update interrupt or DMA request if enabled. These events can be:
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  One pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the bit CEN)
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter used as upcounter
                        B_0x0 = 0x0,
                        ///  Counter used as downcounter
                        B_0x1 = 0x1,
                    },
                },
                ///  Center-aligned mode selection Note: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed
                CMS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
                        B_0x0 = 0x0,
                        ///  Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.
                        B_0x1 = 0x1,
                        ///  Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.
                        B_0x2 = 0x2,
                        ///  Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.
                        B_0x3 = 0x3,
                    },
                },
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (t<sub>DTS</sub>)used by the dead-time generators and the digital filters (ETR, TIx): Note: t<sub>DTS</sub> = 1/f<sub>DTS</sub>, t<sub>CK_INT</sub> = 1/f<sub>CK_INT</sub>.
                CKD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  t<sub>DTS</sub>=t<sub>CK_INT</sub>
                        B_0x0 = 0x0,
                        ///  t<sub>DTS</sub>=2*t<sub>CK_INT</sub>
                        B_0x1 = 0x1,
                        ///  t<sub>DTS</sub>=4*t<sub>CK_INT</sub>
                        B_0x2 = 0x2,
                        ///  Reserved, do not program this value
                        B_0x3 = 0x3,
                    },
                },
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
                        B_0x0 = 0x0,
                        ///  Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM1 control register 2
            TIM1_CR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare preloaded control Note: This bit acts only on channels that have a complementary output.
                CCPC: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCxE, CCxNE and OCxM bits are not preloaded
                        B_0x0 = 0x0,
                        ///  CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit).
                        B_0x1 = 0x1,
                    },
                },
                reserved2: u1,
                ///  Capture/compare control update selection Note: This bit acts only on channels that have a complementary output.
                CCUS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only
                        B_0x0 = 0x0,
                        ///  When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare DMA selection
                CCDS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCx DMA request sent when CCx event occurs
                        B_0x0 = 0x0,
                        ///  CCx DMA requests sent when update event occurs
                        B_0x1 = 0x1,
                    },
                },
                ///  Master mode selection These bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
                MMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
                        B_0x0 = 0x0,
                        ///  Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
                        B_0x1 = 0x1,
                        ///  Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
                        B_0x2 = 0x2,
                        ///  Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).
                        B_0x3 = 0x3,
                        ///  Compare - OC1REFC signal is used as trigger output (TRGO)
                        B_0x4 = 0x4,
                        ///  Compare - OC2REFC signal is used as trigger output (TRGO)
                        B_0x5 = 0x5,
                        ///  Compare - OC3REFC signal is used as trigger output (TRGO)
                        B_0x6 = 0x6,
                        ///  Compare - OC4REFC signal is used as trigger output (TRGO)
                        B_0x7 = 0x7,
                    },
                },
                ///  TI1 selection
                TI1S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The TIMx_CH1 pin is connected to TI1 input
                        B_0x0 = 0x0,
                        ///  The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)
                        B_0x1 = 0x1,
                    },
                },
                ///  Output Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
                OIS1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
                        B_0x0 = 0x0,
                        ///  OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                ///  Output Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
                OIS1N: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1N=0 after a dead-time when MOE=0
                        B_0x0 = 0x0,
                        ///  OC1N=1 after a dead-time when MOE=0
                        B_0x1 = 0x1,
                    },
                },
                ///  Output Idle state 2 (OC2 output) Refer to OIS1 bit
                OIS2: u1,
                ///  Output Idle state 2 (OC2N output) Refer to OIS1N bit
                OIS2N: u1,
                ///  Output Idle state 3 (OC3 output) Refer to OIS1 bit
                OIS3: u1,
                ///  Output Idle state 3 (OC3N output) Refer to OIS1N bit
                OIS3N: u1,
                ///  Output Idle state 4 (OC4 output) Refer to OIS1 bit
                OIS4: u1,
                reserved16: u1,
                ///  Output Idle state 5 (OC5 output) Refer to OIS1 bit
                OIS5: u1,
                reserved18: u1,
                ///  Output Idle state 6 (OC6 output) Refer to OIS1 bit
                OIS6: u1,
                reserved20: u1,
                ///  Master mode selection 2 These bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows: Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
                MMS2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset.
                        B_0x0 = 0x0,
                        ///  Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register).
                        B_0x1 = 0x1,
                        ///  Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer.
                        B_0x2 = 0x2,
                        ///  Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2).
                        B_0x3 = 0x3,
                        ///  Compare - OC1REFC signal is used as trigger output (TRGO2)
                        B_0x4 = 0x4,
                        ///  Compare - OC2REFC signal is used as trigger output (TRGO2)
                        B_0x5 = 0x5,
                        ///  Compare - OC3REFC signal is used as trigger output (TRGO2)
                        B_0x6 = 0x6,
                        ///  Compare - OC4REFC signal is used as trigger output (TRGO2)
                        B_0x7 = 0x7,
                        ///  Compare - OC5REFC signal is used as trigger output (TRGO2)
                        B_0x8 = 0x8,
                        ///  Compare - OC6REFC signal is used as trigger output (TRGO2)
                        B_0x9 = 0x9,
                        ///  Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2
                        B_0xA = 0xa,
                        ///  Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2
                        B_0xB = 0xb,
                        ///  Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2
                        B_0xC = 0xc,
                        ///  Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2
                        B_0xD = 0xd,
                        ///  Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2
                        B_0xE = 0xe,
                        ///  Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2
                        B_0xF = 0xf,
                    },
                },
                padding: u8,
            }),
            ///  TIM1 slave mode control register
            TIM1_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS[0]: Slave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Codes above 1000: Reserved. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.
                SMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                        B_0x0 = 0x0,
                        ///  Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
                        B_0x1 = 0x1,
                        ///  Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
                        B_0x2 = 0x2,
                        ///  Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                        B_0x3 = 0x3,
                        ///  Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                        B_0x4 = 0x4,
                        ///  Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                        B_0x5 = 0x5,
                        ///  Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                        B_0x6 = 0x6,
                        ///  External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
                        B_0x7 = 0x7,
                    },
                },
                ///  OCREF clear selection This bit is used to select the OCREF clear source.
                OCCS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIM1_OR1.OCREF_CLR
                        B_0x0 = 0x0,
                        ///  OCREF_CLR_INT is connected to ETRF
                        B_0x1 = 0x1,
                    },
                },
                ///  TS[0]: Trigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See Table1118: TIM1 internal trigger connection on page1561 for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.
                TS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Internal Trigger 0 (ITR0)
                        B_0x0 = 0x0,
                        ///  Internal Trigger 1 (ITR1)
                        B_0x1 = 0x1,
                        ///  Internal Trigger 2 (ITR2)
                        B_0x2 = 0x2,
                        ///  Internal Trigger 3 (ITR3)
                        B_0x3 = 0x3,
                        ///  TI1 Edge Detector (TI1F_ED)
                        B_0x4 = 0x4,
                        ///  Filtered Timer Input 1 (TI1FP1)
                        B_0x5 = 0x5,
                        ///  Filtered Timer Input 2 (TI2FP2)
                        B_0x6 = 0x6,
                        ///  External Trigger input (ETRF)
                        B_0x7 = 0x7,
                    },
                },
                ///  Master/slave mode
                MSM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger filter This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
                ETF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at f<sub>DTS</sub>
                        B_0x0 = 0x0,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2
                        B_0x1 = 0x1,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4
                        B_0x2 = 0x2,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8
                        B_0x3 = 0x3,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5
                        B_0xA = 0xa,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6
                        B_0xB = 0xb,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8
                        B_0xC = 0xc,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5
                        B_0xD = 0xd,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6
                        B_0xE = 0xe,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  External trigger prescaler External trigger signal ETRP frequency must be at most 1/4 of f<sub>CK_INT</sub> frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
                ETPS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaler OFF
                        B_0x0 = 0x0,
                        ///  ETRP frequency divided by 2
                        B_0x1 = 0x1,
                        ///  ETRP frequency divided by 4
                        B_0x2 = 0x2,
                        ///  ETRP frequency divided by 8
                        B_0x3 = 0x3,
                    },
                },
                ///  External clock enable This bit enables External clock mode 2. Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111). Note: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.
                ECE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  External clock mode 2 disabled
                        B_0x0 = 0x0,
                        ///  External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger polarity This bit selects whether ETR or ETR is used for trigger operations
                ETP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ETR is non-inverted, active at high level or rising edge.
                        B_0x0 = 0x0,
                        ///  ETR is inverted, active at low level or falling edge.
                        B_0x1 = 0x1,
                    },
                },
                ///  SMS[3]
                SMS_1: u1,
                reserved20: u3,
                ///  TS[4:3]
                TS_1: u2,
                padding: u10,
            }),
            ///  TIM1 DMA/interrupt enable register
            TIM1_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC1 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt enable
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC2 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 3 interrupt enable
                CC3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC3 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 4 interrupt enable
                CC4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 interrupt disabled
                        B_0x0 = 0x0,
                        ///  CC4 interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  COM interrupt enable
                COMIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COM interrupt disabled
                        B_0x0 = 0x0,
                        ///  COM interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger interrupt enable
                TIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger interrupt disabled
                        B_0x0 = 0x0,
                        ///  Trigger interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Break interrupt enable
                BIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break interrupt disabled
                        B_0x0 = 0x0,
                        ///  Break interrupt enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 DMA request enable
                CC1DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 DMA request disabled
                        B_0x0 = 0x0,
                        ///  CC1 DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 DMA request enable
                CC2DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 DMA request disabled
                        B_0x0 = 0x0,
                        ///  CC2 DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 3 DMA request enable
                CC3DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 DMA request disabled
                        B_0x0 = 0x0,
                        ///  CC3 DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 4 DMA request enable
                CC4DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 DMA request disabled
                        B_0x0 = 0x0,
                        ///  CC4 DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  COM DMA request enable
                COMDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COM DMA request disabled
                        B_0x0 = 0x0,
                        ///  COM DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger DMA request enable
                TDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger DMA request disabled
                        B_0x0 = 0x0,
                        ///  Trigger DMA request enabled
                        B_0x1 = 0x1,
                    },
                },
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM1 status register
            TIM1_SR: mmio.Mmio(packed struct(u32) {
                ///  Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by a trigger event (refer to Section122.4.3: TIM1 slave mode control register (TIM1_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register.
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred.
                        B_0x0 = 0x0,
                        ///  Update interrupt pending. This bit is set by hardware when the registers are updated:
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No compare match / No input capture occurred
                        B_0x0 = 0x0,
                        ///  A compare match or an input capture occurred.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt flag Refer to CC1IF description
                CC2IF: u1,
                ///  Capture/Compare 3 interrupt flag Refer to CC1IF description
                CC3IF: u1,
                ///  Capture/Compare 4 interrupt flag Refer to CC1IF description
                CC4IF: u1,
                ///  COM interrupt flag This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.
                COMIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No COM event occurred.
                        B_0x0 = 0x0,
                        ///  COM interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger interrupt flag This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
                TIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No trigger event occurred.
                        B_0x0 = 0x0,
                        ///  Trigger interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                ///  Break interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
                BIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break event occurred.
                        B_0x0 = 0x0,
                        ///  An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Break 2 interrupt flag This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.
                B2IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break event occurred.
                        B_0x0 = 0x0,
                        ///  An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to 0.
                CC1OF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overcapture has been detected.
                        B_0x0 = 0x0,
                        ///  The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 overcapture flag Refer to CC1OF description
                CC2OF: u1,
                ///  Capture/Compare 3 overcapture flag Refer to CC1OF description
                CC3OF: u1,
                ///  Capture/Compare 4 overcapture flag Refer to CC1OF description
                CC4OF: u1,
                ///  System Break interrupt flag This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active. This flag must be reset to re-start PWM operation.
                SBIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No break event occurred.
                        B_0x0 = 0x0,
                        ///  An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.
                        B_0x1 = 0x1,
                    },
                },
                reserved16: u2,
                ///  Compare 5 interrupt flag Refer to CC1IF description (Note: Channel 5 can only be configured as output)
                CC5IF: u1,
                ///  Compare 6 interrupt flag Refer to CC1IF description (Note: Channel 6 can only be configured as output)
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM1 event generation register
            TIM1_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation This bit can be set by software, it is automatically cleared by hardware.
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  Reinitialize the counter and generates an update of the registers. The prescaler internal counter is also cleared (the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
                CC1G: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A capture/compare event is generated on channel 1:
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 generation Refer to CC1G description
                CC2G: u1,
                ///  Capture/Compare 3 generation Refer to CC1G description
                CC3G: u1,
                ///  Capture/Compare 4 generation Refer to CC1G description
                CC4G: u1,
                ///  Capture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware Note: This bit acts only on channels having a complementary output.
                COMG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated.
                        B_0x1 = 0x1,
                    },
                },
                ///  Trigger generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
                TG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Break generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
                BG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Break 2 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
                B2G: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  TIM1 capture/compare mode register 1
            TIM1_CCMR1_INPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
                CC1S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC1 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI1
                        B_0x1 = 0x1,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI2
                        B_0x2 = 0x2,
                        ///  CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
                IC1F: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at f<sub>DTS</sub>
                        B_0x0 = 0x0,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2
                        B_0x1 = 0x1,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4
                        B_0x2 = 0x2,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8
                        B_0x3 = 0x3,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5
                        B_0xA = 0xa,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6
                        B_0xB = 0xb,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8
                        B_0xC = 0xc,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5
                        B_0xD = 0xd,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6
                        B_0xE = 0xe,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  Capture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).
                CC2S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC2 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI2
                        B_0x1 = 0x1,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI1
                        B_0x2 = 0x2,
                        ///  CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 2 prescaler Refer to IC1PSC[1:0] description.
                IC2PSC: u2,
                ///  Input capture 2 filter Refer to IC1F[3:0] description.
                IC2F: u4,
                padding: u16,
            }),
            ///  TIM1 capture/compare mode register 2
            TIM1_CCMR2_INPUT: mmio.Mmio(packed struct(u32) {
                ///  Capture/compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).
                CC3S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC3 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC3 channel is configured as input, IC3 is mapped on TI3
                        B_0x1 = 0x1,
                        ///  CC3 channel is configured as input, IC3 is mapped on TI4
                        B_0x2 = 0x2,
                        ///  CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 3 prescaler Refer to IC1PSC[1:0] description.
                IC3PSC: u2,
                ///  Input capture 3 filter Refer to IC1F[3:0] description.
                IC3F: u4,
                ///  Capture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).
                CC4S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC4 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC4 channel is configured as input, IC4 is mapped on TI4
                        B_0x1 = 0x1,
                        ///  CC4 channel is configured as input, IC4 is mapped on TI3
                        B_0x2 = 0x2,
                        ///  CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 4 prescaler Refer to IC1PSC[1:0] description.
                IC4PSC: u2,
                ///  Input capture 4 filter Refer to IC1F[3:0] description.
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM1 capture/compare enable register
            TIM1_CCER: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table1119 for details. Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.
                CC1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture mode disabled / OC1 is not active (see below)
                        B_0x0 = 0x0,
                        ///  Capture mode enabled / OC1 signal is output on the corresponding output pin
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: The configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
                CC1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x0 = 0x0,
                        ///  OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 complementary output enable On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.
                CC1NE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
                        B_0x0 = 0x0,
                        ///  On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (channel configured as output). On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.
                CC1NP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1N active high.
                        B_0x0 = 0x0,
                        ///  OC1N active low.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 output enable Refer to CC1E description
                CC2E: u1,
                ///  Capture/Compare 2 output polarity Refer to CC1P description
                CC2P: u1,
                ///  Capture/Compare 2 complementary output enable Refer to CC1NE description
                CC2NE: u1,
                ///  Capture/Compare 2 complementary output polarity Refer to CC1NP description
                CC2NP: u1,
                ///  Capture/Compare 3 output enable Refer to CC1E description
                CC3E: u1,
                ///  Capture/Compare 3 output polarity Refer to CC1P description
                CC3P: u1,
                ///  Capture/Compare 3 complementary output enable Refer to CC1NE description
                CC3NE: u1,
                ///  Capture/Compare 3 complementary output polarity Refer to CC1NP description
                CC3NP: u1,
                ///  Capture/Compare 4 output enable Refer to CC1E description
                CC4E: u1,
                ///  Capture/Compare 4 output polarity Refer to CC1P description
                CC4P: u1,
                reserved15: u1,
                ///  Capture/Compare 4 complementary output polarity Refer to CC1NP description
                CC4NP: u1,
                ///  Capture/Compare 5 output enable Refer to CC1E description
                CC5E: u1,
                ///  Capture/Compare 5 output polarity Refer to CC1P description
                CC5P: u1,
                reserved20: u2,
                ///  Capture/Compare 6 output enable Refer to CC1E description
                CC6E: u1,
                ///  Capture/Compare 6 output polarity Refer to CC1P description
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM1 counter
            TIM1_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.
                UIFCPY: u1,
            }),
            ///  TIM1 prescaler
            TIM1_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value The counter clock frequency (CK_CNT) is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1). PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode).
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM1 auto-reload register
            TIM1_ARR: mmio.Mmio(packed struct(u16) {
                ///  Auto-reload value ARR is the value to be loaded in the actual auto-reload register. Refer to the Section122.3.1: Time-base unit on page1497 for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null.
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM1 repetition counter register
            TIM1_RCR: mmio.Mmio(packed struct(u16) {
                ///  Repetition counter value These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable. Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event U_RC, any write to the TIMx_RCR register is not taken in account until the next repetition update event. It means in PWM mode (REP+1) corresponds to: the number of PWM periods in edge-aligned mode the number of half PWM period in center-aligned mode.
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM1 capture/compare register 1
            TIM1_CCR1: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output. If channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM1 capture/compare register 2
            TIM1_CCR2: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC2 output. If channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM1 capture/compare register 3
            TIM1_CCR3: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare value If channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output. If channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM1 capture/compare register 4
            TIM1_CCR4: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare value If channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output. If channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed.
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  TIM1 break and dead-time register
            TIM1_BDTR: mmio.Mmio(packed struct(u32) {
                ///  Dead-time generator setup
                DTG: u8,
                ///  Lock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
                LOCK: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LOCK OFF - No bit is write protected.
                        B_0x0 = 0x0,
                        ///  LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits in TIMx_BDTR register can no longer be written.
                        B_0x1 = 0x1,
                        ///  LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
                        B_0x2 = 0x2,
                        ///  LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
                        B_0x3 = 0x3,
                    },
                },
                ///  Off-state selection for Idle mode This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs. See OC/OCN enable description for more details (Section122.4.11: TIM1 capture/compare enable register (TIM1_CCER)). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
                OSSI: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state).
                        B_0x0 = 0x0,
                        ///  When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output.
                        B_0x1 = 0x1,
                    },
                },
                ///  Off-state selection for Run mode This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (Section122.4.11: TIM1 capture/compare enable register (TIM1_CCER)). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
                OSSR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state).
                        B_0x0 = 0x0,
                        ///  When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
                        B_0x1 = 0x1,
                    },
                },
                ///  Break enable This bit enables the complete break protection (including all sources connected to bk_acth and BRK sources, as per Figure1152: Break and Break2 circuitry overview). Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
                BKE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break function disabled
                        B_0x0 = 0x0,
                        ///  Break function enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Break polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
                BKP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK is active low
                        B_0x0 = 0x0,
                        ///  Break input BRK is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  Automatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                AOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  MOE can be set only by software
                        B_0x0 = 0x0,
                        ///  MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)
                        B_0x1 = 0x1,
                    },
                },
                ///  Main output enable This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit. See OC/OCN enable description for more details (Section122.4.11: TIM1 capture/compare enable register (TIM1_CCER)).
                MOE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  In response to a break 2 event. OC and OCN outputs are disabled
                        B_0x0 = 0x0,
                        ///  OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register).
                        B_0x1 = 0x1,
                    },
                },
                ///  Break filter This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, BRK acts asynchronously
                        B_0x0 = 0x0,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2
                        B_0x1 = 0x1,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4
                        B_0x2 = 0x2,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8
                        B_0x3 = 0x3,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5
                        B_0xA = 0xa,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6
                        B_0xB = 0xb,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8
                        B_0xC = 0xc,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5
                        B_0xD = 0xd,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6
                        B_0xE = 0xe,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  Break 2 filter This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2F: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, BRK2 acts asynchronously
                        B_0x0 = 0x0,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2
                        B_0x1 = 0x1,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4
                        B_0x2 = 0x2,
                        ///  f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8
                        B_0x3 = 0x3,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5
                        B_0xA = 0xa,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6
                        B_0xB = 0xb,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8
                        B_0xC = 0xc,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5
                        B_0xD = 0xd,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6
                        B_0xE = 0xe,
                        ///  f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  Break 2 enable Note: The BRK2 must only be used with OSSR = OSSI = 1. Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
                BK2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK2 disabled
                        B_0x0 = 0x0,
                        ///  Break input BRK2 enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Break 2 polarity Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
                BK2P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK2 is active low
                        B_0x0 = 0x0,
                        ///  Break input BRK2 is active high
                        B_0x1 = 0x1,
                    },
                },
                ///  Break Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
                BKDSRM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK is armed
                        B_0x0 = 0x0,
                        ///  Break input BRK is disarmed
                        B_0x1 = 0x1,
                    },
                },
                ///  Break2 Disarm Refer to BKDSRM description
                BK2DSRM: u1,
                ///  Break Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
                BKBID: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Break input BRK in input mode
                        B_0x0 = 0x0,
                        ///  Break input BRK in bidirectional mode
                        B_0x1 = 0x1,
                    },
                },
                ///  Break2 bidirectional Refer to BKBID description
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM1 DMA control register
            TIM1_DCR: mmio.Mmio(packed struct(u16) {
                ///  DMA base address This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ...
                DBA: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  TIMx_CR1,
                        B_0x0 = 0x0,
                        ///  TIMx_CR2,
                        B_0x1 = 0x1,
                        ///  TIMx_SMCR,
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved8: u3,
                ///  DMA burst length This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below). ... Example: Let us consider the following transfer: DBL = 7 bytes & DBA = TIMx_CR1. If DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation: (TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA According to the configuration of the DMA Data Size, several cases may occur: If the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers. If the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.
                DBL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  1 transfer
                        B_0x0 = 0x0,
                        ///  2 transfers
                        B_0x1 = 0x1,
                        ///  3 transfers
                        B_0x2 = 0x2,
                        ///  18 transfers
                        B_0x11 = 0x11,
                        _,
                    },
                },
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM1 DMA address for full transfer
            TIM1_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMA register for burst accesses A read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4 where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).
                DMAB: u32,
            }),
            ///  TIM1 option register 1
            TIM1_OR1: mmio.Mmio(packed struct(u32) {
                ///  Ocref_clr source selection This bit selects the ocref_clr input source. Others: Reserved Note: COMP3 is available on STM32G0B1xx and STM32G0C1xx salestypes only.
                OCREF_CLR: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  COMP1 output is connected to the OCREF_CLR input
                        B_0x0 = 0x0,
                        ///  COMP2 output is connected to the OCREF_CLR input
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u30,
            }),
            ///  TIM1 capture/compare mode register 3
            TIM1_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Output compare 5 fast enable Refer to OC1FE description.
                OC5FE: u1,
                ///  Output compare 5 preload enable Refer to OC1PE description.
                OC5PE: u1,
                ///  OC5M[0]: Output compare 5 mode Refer to OC1M description.
                OC5M: u3,
                ///  Output compare 5 clear enable Refer to OC1CE description.
                OC5CE: u1,
                reserved10: u2,
                ///  Output compare 6 fast enable Refer to OC1FE description.
                OC6FE: u1,
                ///  Output compare 6 preload enable Refer to OC1PE description.
                OC6PE: u1,
                ///  OC6M[0]: Output compare 6 mode Refer to OC1M description.
                OC6M: u3,
                ///  Output compare 6 clear enable Refer to OC1CE description.
                OC6CE: u1,
                ///  OC5M[3]
                OC5M_1: u1,
                reserved24: u7,
                ///  OC6M[3]
                OC6M_1: u1,
                padding: u7,
            }),
            ///  TIM1 capture/compare register 5
            TIM1_CCR5: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 5 value CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output.
                CCR5: u16,
                reserved29: u13,
                ///  Group Channel 5 and Channel 1 Distortion on Channel 1 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1). Note: it is also possible to apply this distortion on combined PWM signals.
                GC5C1: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect of OC5REF on OC1REFC5
                        B_0x0 = 0x0,
                        ///  OC1REFC is the logical AND of OC1REFC and OC5REF
                        B_0x1 = 0x1,
                    },
                },
                ///  Group Channel 5 and Channel 2 Distortion on Channel 2 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1). Note: it is also possible to apply this distortion on combined PWM signals.
                GC5C2: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect of OC5REF on OC2REFC
                        B_0x0 = 0x0,
                        ///  OC2REFC is the logical AND of OC2REFC and OC5REF
                        B_0x1 = 0x1,
                    },
                },
                ///  Group Channel 5 and Channel 3 Distortion on Channel 3 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2). Note: it is also possible to apply this distortion on combined PWM signals.
                GC5C3: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No effect of OC5REF on OC3REFC
                        B_0x0 = 0x0,
                        ///  OC3REFC is the logical AND of OC3REFC and OC5REF
                        B_0x1 = 0x1,
                    },
                },
            }),
            ///  TIM1 capture/compare register 6
            TIM1_CCR6: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 6 value CCR6 is the value to be loaded in the actual capture/compare 6 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC6 output.
                CCR6: u16,
            }),
            reserved96: [2]u8,
            ///  TIM1 alternate function option register 1
            TIM1_AF1: mmio.Mmio(packed struct(u32) {
                ///  BRK BKIN input enable This bit enables the BKIN alternate function input for the timers BRK input. BKIN input is ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKINE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN input disabled
                        B_0x0 = 0x0,
                        ///  BKIN input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP1 enable This bit enables the COMP1 for the timers BRK input. COMP1 output is ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKCMP1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input disabled
                        B_0x0 = 0x0,
                        ///  COMP1 input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP2 enable This bit enables the COMP2 for the timers BRK input. COMP2 output is ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKCMP2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input disabled
                        B_0x0 = 0x0,
                        ///  COMP2 input enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u6,
                ///  BRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKINP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN input polarity is not inverted (active low if BKP=0, active high if BKP=1)
                        B_0x0 = 0x0,
                        ///  BKIN input polarity is inverted (active high if BKP=0, active low if BKP=1)
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKCMP1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input polarity is not inverted (active low if BKP=0, active high if BKP=1)
                        B_0x0 = 0x0,
                        ///  COMP1 input polarity is inverted (active high if BKP=0, active low if BKP=1)
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BKCMP2P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input polarity is not inverted (active low if BKP=0, active high if BKP=1)
                        B_0x0 = 0x0,
                        ///  COMP2 input polarity is inverted (active high if BKP=0, active low if BKP=1)
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u2,
                ///  ETR source selection These bits select the ETR input source. Others: Reserved Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                ETRSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  ETR legacy mode
                        B_0x0 = 0x0,
                        ///  COMP1 output
                        B_0x1 = 0x1,
                        ///  COMP2 output
                        B_0x2 = 0x2,
                        ///  ADC1 AWD1
                        B_0x3 = 0x3,
                        ///  ADC1 AWD2
                        B_0x4 = 0x4,
                        ///  ADC1 AWD3
                        B_0x5 = 0x5,
                        ///  COMP3 output (available on STM32G0B1xx and STM32G0C1xx salestypes only)
                        B_0x6 = 0x6,
                        _,
                    },
                },
                padding: u14,
            }),
            ///  TIM1 Alternate function register 2
            TIM1_AF2: mmio.Mmio(packed struct(u32) {
                ///  BRK2 BKIN input enable This bit enables the BKIN2 alternate function input for the timers BRK2 input. BKIN2 input is ORed with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2INE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN2 input disabled
                        B_0x0 = 0x0,
                        ///  BKIN2 input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK2 COMP1 enable This bit enables the COMP1 for the timers BRK2 input. COMP1 output is ORed with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2CMP1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input disabled
                        B_0x0 = 0x0,
                        ///  COMP1 input enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK2 COMP2 enable This bit enables the COMP2 for the timers BRK2 input. COMP2 output is ORed with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2CMP2E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input disabled
                        B_0x0 = 0x0,
                        ///  COMP2 input enabled
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u6,
                ///  BRK2 BKIN2 input polarity This bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2INP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  BKIN2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)
                        B_0x0 = 0x0,
                        ///  BKIN2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK2 COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2CMP1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP1 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)
                        B_0x0 = 0x0,
                        ///  COMP1 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)
                        B_0x1 = 0x1,
                    },
                },
                ///  BRK2 COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
                BK2CMP2P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  COMP2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)
                        B_0x0 = 0x0,
                        ///  COMP2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)
                        B_0x1 = 0x1,
                    },
                },
                padding: u20,
            }),
            ///  TIM1 timer input selection register
            TIM1_TISEL: mmio.Mmio(packed struct(u32) {
                ///  selects TI1[0] to TI1[15] input Others: Reserved
                TI1SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM1_CH1 input
                        B_0x0 = 0x0,
                        ///  COMP1 output
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved8: u4,
                ///  selects TI2[0] to TI2[15] input Others: Reserved
                TI2SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM1_CH2 input
                        B_0x0 = 0x0,
                        ///  COMP2 output
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved16: u4,
                ///  selects TI3[0] to TI3[15] input Others: Reserved
                TI3SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM1_CH3 input
                        B_0x0 = 0x0,
                        _,
                    },
                },
                reserved24: u4,
                ///  selects TI4[0] to TI4[15] input Others: Reserved
                TI4SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM1_CH4 input
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u4,
            }),
        };

        ///  TIM2 address block description
        pub const TIM2 = extern struct {
            ///  TIM2 control register 1
            TIM2_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled.
                        B_0x0 = 0x0,
                        ///  UEV disabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generate an update interrupt or DMA request if enabled.
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  One-pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the bit CEN)
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter used as upcounter
                        B_0x0 = 0x0,
                        ///  Counter used as downcounter
                        B_0x1 = 0x1,
                    },
                },
                ///  Center-aligned mode selection
                CMS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Edge-aligned mode.
                        B_0x0 = 0x0,
                        ///  Center-aligned mode 1.
                        B_0x1 = 0x1,
                        ///  Center-aligned mode 2.
                        B_0x2 = 0x2,
                        ///  Center-aligned mode 3.
                        B_0x3 = 0x3,
                    },
                },
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock division
                CKD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  B_0x0
                        B_0x0 = 0x0,
                        ///  B_0x1
                        B_0x1 = 0x1,
                        ///  B_0x2
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping.
                        B_0x0 = 0x0,
                        ///  Remapping enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM2 control register 2
            TIM2_CR2: mmio.Mmio(packed struct(u16) {
                reserved3: u3,
                ///  Capture/compare DMA selection
                CCDS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCx DMA request sent when CCx event occurs
                        B_0x0 = 0x0,
                        ///  CCx DMA requests sent when update event occurs
                        B_0x1 = 0x1,
                    },
                },
                ///  Master mode selection
                MMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO).
                        B_0x0 = 0x0,
                        ///  Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO).
                        B_0x1 = 0x1,
                        ///  Update - The update event is selected as trigger output (TRGO).
                        B_0x2 = 0x2,
                        ///  Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred.
                        B_0x3 = 0x3,
                        ///  Compare - OC1REFC signal is used as trigger output (TRGO)
                        B_0x4 = 0x4,
                        ///  Compare - OC2REFC signal is used as trigger output (TRGO)
                        B_0x5 = 0x5,
                        ///  Compare - OC3REFC signal is used as trigger output (TRGO)
                        B_0x6 = 0x6,
                        ///  Compare - OC4REFC signal is used as trigger output (TRGO)
                        B_0x7 = 0x7,
                    },
                },
                ///  TI1 selection
                TI1S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The TIMx_CH1 pin is connected to TI1 input
                        B_0x0 = 0x0,
                        ///  The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also Section23.
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            reserved8: [2]u8,
            ///  TIM2 slave mode control register
            TIM2_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS[2:0]: Slave mode selection
                SMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                        B_0x0 = 0x0,
                        ///  Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
                        B_0x1 = 0x1,
                        ///  Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
                        B_0x2 = 0x2,
                        ///  Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                        B_0x3 = 0x3,
                        ///  Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                        B_0x4 = 0x4,
                        ///  Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high.
                        B_0x5 = 0x5,
                        ///  Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset).
                        B_0x6 = 0x6,
                        ///  External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
                        B_0x7 = 0x7,
                    },
                },
                ///  OCREF clear selection
                OCCS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIMx_OR1.
                        B_0x0 = 0x0,
                        ///  OCREF_CLR_INT is connected to ETRF
                        B_0x1 = 0x1,
                    },
                },
                ///  TS[2:0]: Trigger selection
                TS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Internal Trigger 0 (ITR0)
                        B_0x0 = 0x0,
                        ///  Internal Trigger 1 (ITR1)
                        B_0x1 = 0x1,
                        ///  Internal Trigger 2 (ITR2)
                        B_0x2 = 0x2,
                        ///  Internal Trigger 3 (ITR3)
                        B_0x3 = 0x3,
                        ///  TI1 Edge Detector (TI1F_ED)
                        B_0x4 = 0x4,
                        ///  Filtered Timer Input 1 (TI1FP1)
                        B_0x5 = 0x5,
                        ///  Filtered Timer Input 2 (TI2FP2)
                        B_0x6 = 0x6,
                        ///  External Trigger input (ETRF)
                        B_0x7 = 0x7,
                    },
                },
                ///  Master/Slave mode
                MSM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO).
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger filter
                ETF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at fless thansub>DTSless than/sub>
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  External trigger prescaler
                ETPS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaler OFF
                        B_0x0 = 0x0,
                        ///  ETRP frequency divided by 2
                        B_0x1 = 0x1,
                        ///  ETRP frequency divided by 4
                        B_0x2 = 0x2,
                        ///  ETRP frequency divided by 8
                        B_0x3 = 0x3,
                    },
                },
                ///  External clock enable
                ECE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  External clock mode 2 disabled
                        B_0x0 = 0x0,
                        ///  External clock mode 2 enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger polarity
                ETP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ETR is non-inverted, active at high level or rising edge
                        B_0x0 = 0x0,
                        ///  ETR is inverted, active at low level or falling edge
                        B_0x1 = 0x1,
                    },
                },
                ///  SMS[3]
                SMS_1: u1,
                reserved20: u3,
                ///  TS[4:3]
                TS_1: u2,
                padding: u10,
            }),
            ///  TIM2 DMA/Interrupt enable register
            TIM2_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC1 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt enable
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC2 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 3 interrupt enable
                CC3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC3 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 4 interrupt enable
                CC4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC4 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved6: u1,
                ///  Trigger interrupt enable
                TIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Trigger interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u1,
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled.
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 DMA request enable
                CC1DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC1 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 DMA request enable
                CC2DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC2 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 3 DMA request enable
                CC3DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC3 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 4 DMA request enable
                CC4DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC4 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  Trigger DMA request enable
                TDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger DMA request disabled.
                        B_0x0 = 0x0,
                        ///  Trigger DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM2 status register
            TIM2_SR: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt flag
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred
                        B_0x0 = 0x0,
                        ///  Update interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 interrupt flag
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No compare match / No input capture occurred
                        B_0x0 = 0x0,
                        ///  A compare match or an input capture occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt flag
                CC2IF: u1,
                ///  Capture/Compare 3 interrupt flag
                CC3IF: u1,
                ///  Capture/Compare 4 interrupt flag
                CC4IF: u1,
                reserved6: u1,
                ///  Trigger interrupt flag
                TIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No trigger event occurred.
                        B_0x0 = 0x0,
                        ///  Trigger interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u2,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overcapture has been detected.
                        B_0x0 = 0x0,
                        ///  The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 overcapture flag
                CC2OF: u1,
                ///  Capture/Compare 3 overcapture flag
                CC3OF: u1,
                ///  Capture/Compare 4 overcapture flag
                CC4OF: u1,
                padding: u3,
            }),
            reserved20: [2]u8,
            ///  TIM2 event generation register
            TIM2_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  Re-initialize the counter and generates an update of the registers.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 generation
                CC1G: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A capture/compare event is generated on channel 1:
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 generation
                CC2G: u1,
                ///  Capture/compare 3 generation
                CC3G: u1,
                ///  Capture/compare 4 generation
                CC4G: u1,
                reserved6: u1,
                ///  Trigger generation
                TG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The TIF flag is set in TIMx_SR register.
                        B_0x1 = 0x1,
                    },
                },
                padding: u9,
            }),
            reserved24: [2]u8,
            ///  TIM2 capture/compare mode register 1
            TIM2_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC1 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI1
                        B_0x1 = 0x1,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI2
                        B_0x2 = 0x2,
                        ///  CC1 channel is configured as input, IC1 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 prescaler
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 filter
                IC1F: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at f less thansub>DTSless than/sub>
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  Capture/compare 2 selection
                CC2S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC2 channel is configured as output.
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI2.
                        B_0x1 = 0x1,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI1.
                        B_0x2 = 0x2,
                        ///  CC2 channel is configured as input, IC2 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 2 prescaler
                IC2PSC: u2,
                ///  Input capture 2 filter
                IC2F: u4,
                padding: u16,
            }),
            ///  TIM2 capture/compare mode register 2
            TIM2_CCMR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 3 selection
                CC3S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC3 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC3 channel is configured as input, IC3 is mapped on TI3
                        B_0x1 = 0x1,
                        ///  CC3 channel is configured as input, IC3 is mapped on TI4
                        B_0x2 = 0x2,
                        ///  CC3 channel is configured as input, IC3 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 3 prescaler
                IC3PSC: u2,
                ///  Input capture 3 filter
                IC3F: u4,
                ///  Capture/Compare 4 selection
                CC4S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC4 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC4 channel is configured as input, IC4 is mapped on TI4
                        B_0x1 = 0x1,
                        ///  CC4 channel is configured as input, IC4 is mapped on TI3
                        B_0x2 = 0x2,
                        ///  CC4 channel is configured as input, IC4 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 4 prescaler
                IC4PSC: u2,
                ///  Input capture 4 filter
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM2 capture/compare enable register
            TIM2_CCER: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 output enable.
                CC1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture mode disabled / OC1 is not active
                        B_0x0 = 0x0,
                        ///  Capture mode enabled / OC1 signal is output on the corresponding output pin
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 output Polarity.
                CC1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x0 = 0x0,
                        ///  OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u1,
                ///  Capture/Compare 1 output Polarity.
                CC1NP: u1,
                ///  Capture/Compare 2 output enable.
                CC2E: u1,
                ///  Capture/Compare 2 output Polarity.
                CC2P: u1,
                reserved7: u1,
                ///  Capture/Compare 2 output Polarity.
                CC2NP: u1,
                ///  Capture/Compare 3 output enable.
                CC3E: u1,
                ///  Capture/Compare 3 output Polarity.
                CC3P: u1,
                reserved11: u1,
                ///  Capture/Compare 3 output Polarity.
                CC3NP: u1,
                ///  Capture/Compare 4 output enable.
                CC4E: u1,
                ///  Capture/Compare 4 output Polarity.
                CC4P: u1,
                reserved15: u1,
                ///  Capture/Compare 4 output Polarity.
                CC4NP: u1,
            }),
            reserved36: [2]u8,
            ///  TIM2 counter
            TIM2_CNT: mmio.Mmio(packed struct(u32) {
                ///  Least significant part of counter value
                CNT: u32,
            }),
            ///  TIM2 prescaler
            TIM2_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM2 auto-reload register
            TIM2_ARR: mmio.Mmio(packed struct(u32) {
                ///  Low Auto-reload value
                ARR: u32,
            }),
            reserved52: [4]u8,
            ///  TIM2 capture/compare register 1
            TIM2_CCR1: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare 1 value
                CCR1: u32,
            }),
            ///  TIM2 capture/compare register 2
            TIM2_CCR2: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare 2 value
                CCR2: u32,
            }),
            ///  TIM2 capture/compare register 3
            TIM2_CCR3: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare value
                CCR3: u32,
            }),
            ///  TIM2 capture/compare register 4
            TIM2_CCR4: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare value
                CCR4: u32,
            }),
            reserved72: [4]u8,
            ///  TIM2 DMA control register
            TIM2_DCR: mmio.Mmio(packed struct(u16) {
                ///  DMA base address
                DBA: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  TIMx_CR1
                        B_0x0 = 0x0,
                        ///  TIMx_CR2
                        B_0x1 = 0x1,
                        ///  TIMx_SMCR
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved8: u3,
                ///  DMA burst length
                DBL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  1 transfer,
                        B_0x0 = 0x0,
                        ///  2 transfers,
                        B_0x1 = 0x1,
                        ///  3 transfers,
                        B_0x2 = 0x2,
                        ///  18 transfers.
                        B_0x11 = 0x11,
                        _,
                    },
                },
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM2 DMA address for full transfer
            TIM2_DMAR: mmio.Mmio(packed struct(u16) {
                ///  DMA register for burst accesses
                DMAB: u16,
            }),
            reserved80: [2]u8,
            ///  TIM2 option register 1
            TIM2_OR1: mmio.Mmio(packed struct(u32) {
                ///  Ocref_clr source selection
                OCREF_CLR: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  COMP1 output is connected to the OCREF_CLR input
                        B_0x0 = 0x0,
                        ///  COMP2 output is connected to the OCREF_CLR input
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u30,
            }),
            reserved96: [12]u8,
            ///  TIM2 alternate function option register 1
            TIM2_AF1: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  ETR source selection
                ETRSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  ETR legacy mode
                        B_0x0 = 0x0,
                        ///  COMP1
                        B_0x1 = 0x1,
                        ///  COMP2
                        B_0x2 = 0x2,
                        ///  LSE
                        B_0x3 = 0x3,
                        ///  MCO
                        B_0x4 = 0x4,
                        ///  MCO2
                        B_0x5 = 0x5,
                        _,
                    },
                },
                padding: u14,
            }),
            reserved104: [4]u8,
            ///  TIM2 timer input selection register
            TIM2_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1[0] to TI1[15] input selection
                TI1SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM2_CH1 input
                        B_0x0 = 0x0,
                        ///  COMP1 output
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved8: u4,
                ///  TI2[0] to TI2[15] input selection
                TI2SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM2_CH2 input
                        B_0x0 = 0x0,
                        ///  COMP2 output
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved16: u4,
                ///  TI3[0] to TI3[15] input selection
                TI3SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM2_CH3 input
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u12,
            }),
        };

        ///  TIM3 address block description
        pub const TIM3 = extern struct {
            ///  TIM3 control register 1
            TIM3_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled.
                        B_0x0 = 0x0,
                        ///  UEV disabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generate an update interrupt or DMA request if enabled.
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  One-pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the bit CEN)
                        B_0x1 = 0x1,
                    },
                },
                ///  Direction
                DIR: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter used as upcounter
                        B_0x0 = 0x0,
                        ///  Counter used as downcounter
                        B_0x1 = 0x1,
                    },
                },
                ///  Center-aligned mode selection
                CMS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Edge-aligned mode.
                        B_0x0 = 0x0,
                        ///  Center-aligned mode 1.
                        B_0x1 = 0x1,
                        ///  Center-aligned mode 2.
                        B_0x2 = 0x2,
                        ///  Center-aligned mode 3.
                        B_0x3 = 0x3,
                    },
                },
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered
                        B_0x1 = 0x1,
                    },
                },
                ///  Clock division
                CKD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  B_0x0
                        B_0x0 = 0x0,
                        ///  B_0x1
                        B_0x1 = 0x1,
                        ///  B_0x2
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved11: u1,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping.
                        B_0x0 = 0x0,
                        ///  Remapping enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM3 control register 2
            TIM3_CR2: mmio.Mmio(packed struct(u16) {
                reserved3: u3,
                ///  Capture/compare DMA selection
                CCDS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CCx DMA request sent when CCx event occurs
                        B_0x0 = 0x0,
                        ///  CCx DMA requests sent when update event occurs
                        B_0x1 = 0x1,
                    },
                },
                ///  Master mode selection
                MMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO).
                        B_0x0 = 0x0,
                        ///  Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO).
                        B_0x1 = 0x1,
                        ///  Update - The update event is selected as trigger output (TRGO).
                        B_0x2 = 0x2,
                        ///  Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred.
                        B_0x3 = 0x3,
                        ///  Compare - OC1REFC signal is used as trigger output (TRGO)
                        B_0x4 = 0x4,
                        ///  Compare - OC2REFC signal is used as trigger output (TRGO)
                        B_0x5 = 0x5,
                        ///  Compare - OC3REFC signal is used as trigger output (TRGO)
                        B_0x6 = 0x6,
                        ///  Compare - OC4REFC signal is used as trigger output (TRGO)
                        B_0x7 = 0x7,
                    },
                },
                ///  TI1 selection
                TI1S: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  The TIMx_CH1 pin is connected to TI1 input
                        B_0x0 = 0x0,
                        ///  The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also Section23.
                        B_0x1 = 0x1,
                    },
                },
                padding: u8,
            }),
            reserved8: [2]u8,
            ///  TIM3 slave mode control register
            TIM3_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS[2:0]: Slave mode selection
                SMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                        B_0x0 = 0x0,
                        ///  Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
                        B_0x1 = 0x1,
                        ///  Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
                        B_0x2 = 0x2,
                        ///  Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                        B_0x3 = 0x3,
                        ///  Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                        B_0x4 = 0x4,
                        ///  Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high.
                        B_0x5 = 0x5,
                        ///  Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset).
                        B_0x6 = 0x6,
                        ///  External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
                        B_0x7 = 0x7,
                    },
                },
                ///  OCREF clear selection
                OCCS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIMx_OR1.
                        B_0x0 = 0x0,
                        ///  OCREF_CLR_INT is connected to ETRF
                        B_0x1 = 0x1,
                    },
                },
                ///  TS[2:0]: Trigger selection
                TS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Internal Trigger 0 (ITR0)
                        B_0x0 = 0x0,
                        ///  Internal Trigger 1 (ITR1)
                        B_0x1 = 0x1,
                        ///  Internal Trigger 2 (ITR2)
                        B_0x2 = 0x2,
                        ///  Internal Trigger 3 (ITR3)
                        B_0x3 = 0x3,
                        ///  TI1 Edge Detector (TI1F_ED)
                        B_0x4 = 0x4,
                        ///  Filtered Timer Input 1 (TI1FP1)
                        B_0x5 = 0x5,
                        ///  Filtered Timer Input 2 (TI2FP2)
                        B_0x6 = 0x6,
                        ///  External Trigger input (ETRF)
                        B_0x7 = 0x7,
                    },
                },
                ///  Master/Slave mode
                MSM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO).
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger filter
                ETF: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at fless thansub>DTSless than/sub>
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  External trigger prescaler
                ETPS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaler OFF
                        B_0x0 = 0x0,
                        ///  ETRP frequency divided by 2
                        B_0x1 = 0x1,
                        ///  ETRP frequency divided by 4
                        B_0x2 = 0x2,
                        ///  ETRP frequency divided by 8
                        B_0x3 = 0x3,
                    },
                },
                ///  External clock enable
                ECE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  External clock mode 2 disabled
                        B_0x0 = 0x0,
                        ///  External clock mode 2 enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  External trigger polarity
                ETP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  ETR is non-inverted, active at high level or rising edge
                        B_0x0 = 0x0,
                        ///  ETR is inverted, active at low level or falling edge
                        B_0x1 = 0x1,
                    },
                },
                ///  SMS[3]
                SMS_1: u1,
                reserved20: u3,
                ///  TS[4:3]
                TS_1: u2,
                padding: u10,
            }),
            ///  TIM3 DMA/Interrupt enable register
            TIM3_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 interrupt enable
                CC1IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC1 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt enable
                CC2IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC2 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 3 interrupt enable
                CC3IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC3 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 4 interrupt enable
                CC4IE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 interrupt disabled.
                        B_0x0 = 0x0,
                        ///  CC4 interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved6: u1,
                ///  Trigger interrupt enable
                TIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Trigger interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u1,
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled.
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 DMA request enable
                CC1DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC1 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC1 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 DMA request enable
                CC2DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC2 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC2 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 3 DMA request enable
                CC3DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC3 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC3 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 4 DMA request enable
                CC4DE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  CC4 DMA request disabled.
                        B_0x0 = 0x0,
                        ///  CC4 DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved14: u1,
                ///  Trigger DMA request enable
                TDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Trigger DMA request disabled.
                        B_0x0 = 0x0,
                        ///  Trigger DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM3 status register
            TIM3_SR: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt flag
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred
                        B_0x0 = 0x0,
                        ///  Update interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 interrupt flag
                CC1IF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No compare match / No input capture occurred
                        B_0x0 = 0x0,
                        ///  A compare match or an input capture occurred
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 2 interrupt flag
                CC2IF: u1,
                ///  Capture/Compare 3 interrupt flag
                CC3IF: u1,
                ///  Capture/Compare 4 interrupt flag
                CC4IF: u1,
                reserved6: u1,
                ///  Trigger interrupt flag
                TIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No trigger event occurred.
                        B_0x0 = 0x0,
                        ///  Trigger interrupt pending.
                        B_0x1 = 0x1,
                    },
                },
                reserved9: u2,
                ///  Capture/Compare 1 overcapture flag
                CC1OF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No overcapture has been detected.
                        B_0x0 = 0x0,
                        ///  The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 overcapture flag
                CC2OF: u1,
                ///  Capture/Compare 3 overcapture flag
                CC3OF: u1,
                ///  Capture/Compare 4 overcapture flag
                CC4OF: u1,
                padding: u3,
            }),
            reserved20: [2]u8,
            ///  TIM3 event generation register
            TIM3_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  Re-initialize the counter and generates an update of the registers.
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 1 generation
                CC1G: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  A capture/compare event is generated on channel 1:
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/compare 2 generation
                CC2G: u1,
                ///  Capture/compare 3 generation
                CC3G: u1,
                ///  Capture/compare 4 generation
                CC4G: u1,
                reserved6: u1,
                ///  Trigger generation
                TG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action
                        B_0x0 = 0x0,
                        ///  The TIF flag is set in TIMx_SR register.
                        B_0x1 = 0x1,
                    },
                },
                padding: u9,
            }),
            reserved24: [2]u8,
            ///  TIM3 capture/compare mode register 1
            TIM3_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC1 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI1
                        B_0x1 = 0x1,
                        ///  CC1 channel is configured as input, IC1 is mapped on TI2
                        B_0x2 = 0x2,
                        ///  CC1 channel is configured as input, IC1 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 prescaler
                IC1PSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  no prescaler, capture is done each time an edge is detected on the capture input
                        B_0x0 = 0x0,
                        ///  capture is done once every 2 events
                        B_0x1 = 0x1,
                        ///  capture is done once every 4 events
                        B_0x2 = 0x2,
                        ///  capture is done once every 8 events
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 1 filter
                IC1F: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  No filter, sampling is done at f less thansub>DTSless than/sub>
                        B_0x0 = 0x0,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=2
                        B_0x1 = 0x1,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=4
                        B_0x2 = 0x2,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>CK_INTless than/sub>, N=8
                        B_0x3 = 0x3,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=6
                        B_0x4 = 0x4,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/2, N=8
                        B_0x5 = 0x5,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=6
                        B_0x6 = 0x6,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/4, N=8
                        B_0x7 = 0x7,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=6
                        B_0x8 = 0x8,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/8, N=8
                        B_0x9 = 0x9,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=5
                        B_0xA = 0xa,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=6
                        B_0xB = 0xb,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/16, N=8
                        B_0xC = 0xc,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=5
                        B_0xD = 0xd,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=6
                        B_0xE = 0xe,
                        ///  fless thansub>SAMPLINGless than/sub>=fless thansub>DTSless than/sub>/32, N=8
                        B_0xF = 0xf,
                    },
                },
                ///  Capture/compare 2 selection
                CC2S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC2 channel is configured as output.
                        B_0x0 = 0x0,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI2.
                        B_0x1 = 0x1,
                        ///  CC2 channel is configured as input, IC2 is mapped on TI1.
                        B_0x2 = 0x2,
                        ///  CC2 channel is configured as input, IC2 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 2 prescaler
                IC2PSC: u2,
                ///  Input capture 2 filter
                IC2F: u4,
                padding: u16,
            }),
            ///  TIM3 capture/compare mode register 2
            TIM3_CCMR2: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 3 selection
                CC3S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC3 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC3 channel is configured as input, IC3 is mapped on TI3
                        B_0x1 = 0x1,
                        ///  CC3 channel is configured as input, IC3 is mapped on TI4
                        B_0x2 = 0x2,
                        ///  CC3 channel is configured as input, IC3 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 3 prescaler
                IC3PSC: u2,
                ///  Input capture 3 filter
                IC3F: u4,
                ///  Capture/Compare 4 selection
                CC4S: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CC4 channel is configured as output
                        B_0x0 = 0x0,
                        ///  CC4 channel is configured as input, IC4 is mapped on TI4
                        B_0x1 = 0x1,
                        ///  CC4 channel is configured as input, IC4 is mapped on TI3
                        B_0x2 = 0x2,
                        ///  CC4 channel is configured as input, IC4 is mapped on TRC.
                        B_0x3 = 0x3,
                    },
                },
                ///  Input capture 4 prescaler
                IC4PSC: u2,
                ///  Input capture 4 filter
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM3 capture/compare enable register
            TIM3_CCER: mmio.Mmio(packed struct(u16) {
                ///  Capture/Compare 1 output enable.
                CC1E: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Capture mode disabled / OC1 is not active
                        B_0x0 = 0x0,
                        ///  Capture mode enabled / OC1 signal is output on the corresponding output pin
                        B_0x1 = 0x1,
                    },
                },
                ///  Capture/Compare 1 output Polarity.
                CC1P: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x0 = 0x0,
                        ///  OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
                        B_0x1 = 0x1,
                    },
                },
                reserved3: u1,
                ///  Capture/Compare 1 output Polarity.
                CC1NP: u1,
                ///  Capture/Compare 2 output enable.
                CC2E: u1,
                ///  Capture/Compare 2 output Polarity.
                CC2P: u1,
                reserved7: u1,
                ///  Capture/Compare 2 output Polarity.
                CC2NP: u1,
                ///  Capture/Compare 3 output enable.
                CC3E: u1,
                ///  Capture/Compare 3 output Polarity.
                CC3P: u1,
                reserved11: u1,
                ///  Capture/Compare 3 output Polarity.
                CC3NP: u1,
                ///  Capture/Compare 4 output enable.
                CC4E: u1,
                ///  Capture/Compare 4 output Polarity.
                CC4P: u1,
                reserved15: u1,
                ///  Capture/Compare 4 output Polarity.
                CC4NP: u1,
            }),
            reserved36: [2]u8,
            ///  TIM3 counter
            TIM3_CNT: mmio.Mmio(packed struct(u32) {
                ///  Least significant part of counter value
                CNT: u32,
            }),
            ///  TIM3 prescaler
            TIM3_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM3 auto-reload register
            TIM3_ARR: mmio.Mmio(packed struct(u32) {
                ///  Low Auto-reload value
                ARR: u32,
            }),
            reserved52: [4]u8,
            ///  TIM3 capture/compare register 1
            TIM3_CCR1: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare 1 value
                CCR1: u32,
            }),
            ///  TIM3 capture/compare register 2
            TIM3_CCR2: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare 2 value
                CCR2: u32,
            }),
            ///  TIM3 capture/compare register 3
            TIM3_CCR3: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare value
                CCR3: u32,
            }),
            ///  TIM3 capture/compare register 4
            TIM3_CCR4: mmio.Mmio(packed struct(u32) {
                ///  Low Capture/Compare value
                CCR4: u32,
            }),
            reserved72: [4]u8,
            ///  TIM3 DMA control register
            TIM3_DCR: mmio.Mmio(packed struct(u16) {
                ///  DMA base address
                DBA: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  TIMx_CR1
                        B_0x0 = 0x0,
                        ///  TIMx_CR2
                        B_0x1 = 0x1,
                        ///  TIMx_SMCR
                        B_0x2 = 0x2,
                        _,
                    },
                },
                reserved8: u3,
                ///  DMA burst length
                DBL: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  1 transfer,
                        B_0x0 = 0x0,
                        ///  2 transfers,
                        B_0x1 = 0x1,
                        ///  3 transfers,
                        B_0x2 = 0x2,
                        ///  18 transfers.
                        B_0x11 = 0x11,
                        _,
                    },
                },
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM3 DMA address for full transfer
            TIM3_DMAR: mmio.Mmio(packed struct(u16) {
                ///  DMA register for burst accesses
                DMAB: u16,
            }),
            reserved80: [2]u8,
            ///  TIM3 option register 1
            TIM3_OR1: mmio.Mmio(packed struct(u32) {
                ///  Ocref_clr source selection
                OCREF_CLR: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  COMP1 output is connected to the OCREF_CLR input
                        B_0x0 = 0x0,
                        ///  COMP2 output is connected to the OCREF_CLR input
                        B_0x1 = 0x1,
                        _,
                    },
                },
                padding: u30,
            }),
            reserved96: [12]u8,
            ///  TIM3 alternate function option register 1
            TIM3_AF1: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  ETR source selection
                ETRSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  ETR legacy mode
                        B_0x0 = 0x0,
                        ///  COMP1 output
                        B_0x1 = 0x1,
                        ///  COMP2 output
                        B_0x2 = 0x2,
                        _,
                    },
                },
                padding: u14,
            }),
            reserved104: [4]u8,
            ///  TIM3 timer input selection register
            TIM3_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1[0] to TI1[15] input selection
                TI1SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM3_CH1 input
                        B_0x0 = 0x0,
                        ///  COMP1 output
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved8: u4,
                ///  TI2[0] to TI2[15] input selection
                TI2SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM3_CH2 input
                        B_0x0 = 0x0,
                        ///  COMP2 output
                        B_0x1 = 0x1,
                        _,
                    },
                },
                reserved16: u4,
                ///  TI3[0] to TI3[15] input selection
                TI3SEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  TIM3_CH3 input
                        B_0x0 = 0x0,
                        _,
                    },
                },
                padding: u12,
            }),
        };

        ///  TIM6 address block description
        pub const TIM6 = extern struct {
            ///  TIM6 control register 1
            TIM6_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled. The Update (UEV) event is generated by one of the following events:
                        B_0x0 = 0x0,
                        ///  UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generates an update interrupt or DMA request if enabled. These events can be:
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  One-pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the CEN bit).
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered.
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered.
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u3,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
                        B_0x0 = 0x0,
                        ///  Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM6 control register 2
            TIM6_CR2: mmio.Mmio(packed struct(u16) {
                reserved4: u4,
                ///  Master mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
                MMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
                        B_0x0 = 0x0,
                        ///  Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode.
                        B_0x1 = 0x1,
                        ///  Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
                        B_0x2 = 0x2,
                        _,
                    },
                },
                padding: u9,
            }),
            reserved12: [6]u8,
            ///  TIM6 DMA/Interrupt enable register
            TIM6_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u7,
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled.
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            reserved16: [2]u8,
            ///  TIM6 status register
            TIM6_SR: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS1=10 and UDIS1=10 in the TIMx_CR1 register.
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred.
                        B_0x0 = 0x0,
                        ///  Update interrupt pending. This bit is set by hardware when the registers are updated:
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            reserved20: [2]u8,
            ///  TIM6 event generation register
            TIM6_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation This bit can be set by software, it is automatically cleared by hardware.
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action.
                        B_0x0 = 0x0,
                        ///  Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            reserved36: [14]u8,
            ///  TIM6 counter
            TIM6_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.
                UIFCPY: u1,
            }),
            ///  TIM6 prescaler
            TIM6_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value The counter clock frequency CK_CNT is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1). PSC contains the value to be loaded into the active prescaler register at each update event. (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode).
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM6 auto-reload register
            TIM6_ARR: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value ARR is the value to be loaded into the actual auto-reload register. Refer to Section123.3.1: Time-base unit on page1596 for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null.
                ARR: u16,
            }),
        };

        ///  TIM7 address block description
        pub const TIM7 = extern struct {
            ///  TIM7 control register 1
            TIM7_CR1: mmio.Mmio(packed struct(u16) {
                ///  Counter enable Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.
                CEN: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter disabled
                        B_0x0 = 0x0,
                        ///  Counter enabled
                        B_0x1 = 0x1,
                    },
                },
                ///  Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.
                UDIS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  UEV enabled. The Update (UEV) event is generated by one of the following events:
                        B_0x0 = 0x0,
                        ///  UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
                        B_0x1 = 0x1,
                    },
                },
                ///  Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller
                URS: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Any of the following events generates an update interrupt or DMA request if enabled. These events can be:
                        B_0x0 = 0x0,
                        ///  Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
                        B_0x1 = 0x1,
                    },
                },
                ///  One-pulse mode
                OPM: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Counter is not stopped at update event
                        B_0x0 = 0x0,
                        ///  Counter stops counting at the next update event (clearing the CEN bit).
                        B_0x1 = 0x1,
                    },
                },
                reserved7: u3,
                ///  Auto-reload preload enable
                ARPE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  TIMx_ARR register is not buffered.
                        B_0x0 = 0x0,
                        ///  TIMx_ARR register is buffered.
                        B_0x1 = 0x1,
                    },
                },
                reserved11: u3,
                ///  UIF status bit remapping
                UIFREMAP: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
                        B_0x0 = 0x0,
                        ///  Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
                        B_0x1 = 0x1,
                    },
                },
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM7 control register 2
            TIM7_CR2: mmio.Mmio(packed struct(u16) {
                reserved4: u4,
                ///  Master mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
                MMS: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
                        B_0x0 = 0x0,
                        ///  Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode.
                        B_0x1 = 0x1,
                        ///  Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
                        B_0x2 = 0x2,
                        _,
                    },
                },
                padding: u9,
            }),
            reserved12: [6]u8,
            ///  TIM7 DMA/Interrupt enable register
            TIM7_DIER: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt enable
                UIE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update interrupt disabled.
                        B_0x0 = 0x0,
                        ///  Update interrupt enabled.
                        B_0x1 = 0x1,
                    },
                },
                reserved8: u7,
                ///  Update DMA request enable
                UDE: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  Update DMA request disabled.
                        B_0x0 = 0x0,
                        ///  Update DMA request enabled.
                        B_0x1 = 0x1,
                    },
                },
                padding: u7,
            }),
            reserved16: [2]u8,
            ///  TIM7 status register
            TIM7_SR: mmio.Mmio(packed struct(u16) {
                ///  Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS1=10 and UDIS1=10 in the TIMx_CR1 register.
                UIF: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No update occurred.
                        B_0x0 = 0x0,
                        ///  Update interrupt pending. This bit is set by hardware when the registers are updated:
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            reserved20: [2]u8,
            ///  TIM7 event generation register
            TIM7_EGR: mmio.Mmio(packed struct(u16) {
                ///  Update generation This bit can be set by software, it is automatically cleared by hardware.
                UG: packed union {
                    raw: u1,
                    value: enum(u1) {
                        ///  No action.
                        B_0x0 = 0x0,
                        ///  Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).
                        B_0x1 = 0x1,
                    },
                },
                padding: u15,
            }),
            reserved36: [14]u8,
            ///  TIM7 counter
            TIM7_CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter value
                CNT: u16,
                reserved31: u15,
                ///  UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.
                UIFCPY: u1,
            }),
            ///  TIM7 prescaler
            TIM7_PSC: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value The counter clock frequency CK_CNT is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1). PSC contains the value to be loaded into the active prescaler register at each update event. (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode).
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM7 auto-reload register
            TIM7_ARR: mmio.Mmio(packed struct(u16) {
                ///  Prescaler value ARR is the value to be loaded into the actual auto-reload register. Refer to Section123.3.1: Time-base unit on page1596 for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null.
                ARR: u16,
            }),
        };
    };
};
